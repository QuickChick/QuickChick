type name_provider = { next_name : unit -> string; }
val mk_name_provider : string -> name_provider
module Unknown :
  sig
    type t = NewGenericLib.var
    val to_string : NewGenericLib.var -> string
    val from_string : string -> NewGenericLib.var
    val from_var : 'a -> 'a
    val from_id : Names.Id.t -> NewGenericLib.var
    val undefined : NewGenericLib.var
  end
module UnknownOrd :
  sig
    type t = Unknown.t
    val compare : NewGenericLib.var -> NewGenericLib.var -> int
  end
type unknown = Unknown.t
type range =
    Ctr of NewGenericLib.constructor * range list
  | Unknown of unknown
  | Undef of NewGenericLib.rocq_constr
  | FixedInput
  | Parameter of NewGenericLib.ty_param
  | RangeHole
val is_parameter : range -> bool
val range_to_string : range -> string
module UM : CMap.ExtS with type key = Unknown.t and module Set := Set.Make(UnknownOrd)
type umap = range UM.t
val umfind : UM.key -> 'a UM.t -> 'a
val lookup : unknown -> umap -> range option
module OrdTSS :
  sig type t = unknown * unknown val compare : 'a -> 'a -> int end
(*#if COQ_VERSION >= (8, 21, 0)
module EqSet : CSet.ExtS with type elt = OrdTSS.t
#else
module EqSet : Set.S with type elt = OrdTSS.t
#endif
val eq_set_add : unknown -> unknown -> EqSet.t -> EqSet.t
module OrdTyp :
  sig type t = NewGenericLib.rocq_constr val compare : 'a -> 'a -> int end
#if COQ_VERSION >= (8, 21, 0)
module ArbSet : CSet.ExtS with type elt = OrdTyp.t
#else
module ArbSet : Set.S with type elt = OrdTyp.t
#endif
type unknown_provider = { next_unknown : unit -> Unknown.t; }
val unk_provider : unknown_provider
val raiseMatch :
  umap ->
  NewGenericLib.constructor ->
  range list -> EqSet.t -> (umap * NewGenericLib.matcher_pat * EqSet.t) option
val unify :
  umap ->
  range ->
  range ->
  EqSet.t ->
  (umap * range * EqSet.t * (unknown * NewGenericLib.matcher_pat) list) option
val fixRange : UM.key -> range -> range UM.t -> range UM.t
val fixVariable : UM.key -> range UM.t -> range UM.t
val convert_to_range : NewGenericLib.rocq_constr -> range option
val is_fixed : range UM.t -> NewGenericLib.rocq_constr -> bool option
val range_to_coq_expr : range UM.t -> range -> NewGenericLib.coq_expr
val dt_to_coq_expr :
  range UM.t -> NewGenericLib.rocq_constr -> NewGenericLib.coq_expr
val is_rocq_constr : NewGenericLib.rocq_constr -> bool
type check = (NewGenericLib.coq_expr -> NewGenericLib.coq_expr) * int
module CMap : CMap.ExtS with type key = NewGenericLib.OrdDepType.t and module Set := Set.Make(NewGenericLib.OrdDepType)

type cmap = check list CMap.t
val lookup_checks : CMap.key -> 'a CMap.t -> 'a option
val handle_equalities :
  NewGenericLib.coq_expr ->
  EqSet.t ->
  (NewGenericLib.coq_expr -> 'a -> 'a -> 'a -> 'a) -> 'a -> 'a -> 'a -> 'a
type mode =
    Recursive of (Unknown.t * NewGenericLib.rocq_constr) list *
      (Unknown.t * NewGenericLib.rocq_constr) list * range list
  | NonRecursive of (Unknown.t * NewGenericLib.rocq_constr) list
val mode_analysis :
  NewGenericLib.ty_ctr ->
  NewGenericLib.ty_ctr ->
  range list -> range UM.t -> range list -> range UM.t -> mode
val isTyParam : NewGenericLib.rocq_constr -> bool
val warn_uninstantiated_variables : ?loc:Loc.t -> NewGenericLib.var list -> unit
val handle_branch :
  string list ->
  NewGenericLib.rocq_constr ->
  NewGenericLib.coq_expr ->
  NewGenericLib.coq_expr ->
  NewGenericLib.coq_expr ->
  (NewGenericLib.coq_expr -> NewGenericLib.coq_expr) ->
  NewGenericLib.coq_expr ->
  (int -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr) ->
  (bool -> NewGenericLib.coq_expr -> string -> (NewGenericLib.var -> NewGenericLib.coq_expr) -> NewGenericLib.coq_expr) ->
  (int -> unknown list option -> NewGenericLib.coq_expr list -> NewGenericLib.coq_expr) ->
  (bool -> NewGenericLib.coq_expr -> string -> (NewGenericLib.var -> NewGenericLib.coq_expr) -> NewGenericLib.coq_expr) ->
  (bool ->
   NewGenericLib.coq_expr ->
   string -> ((NewGenericLib.coq_expr -> NewGenericLib.coq_expr) * int) list -> NewGenericLib.coq_expr) ->
  (int -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr) ->
  (NewGenericLib.var -> NewGenericLib.matcher_pat -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr) ->
  (string -> NewGenericLib.coq_expr -> (NewGenericLib.var -> NewGenericLib.coq_expr) -> NewGenericLib.coq_expr) ->
  (NewGenericLib.var -> NewGenericLib.var list -> NewGenericLib.coq_expr -> NewGenericLib.coq_expr) ->
  NewGenericLib.ty_ctr ->
  range UM.t ->
  NewGenericLib.rocq_constr UM.t ->
  range list -> Unknown.t -> NewGenericLib.dep_ctr -> NewGenericLib.coq_expr * bool *)

val type_to_schedules : NewGenericLib.rocq_constr ->
            NewGenericLib.ty_ctr option ->
            NewGenericLib.ty_ctr option ->
            (unknown * NewGenericLib.rocq_constr) list ->
            unknown list ->
            NewGenericLib.derive_sort ->
            bool ->
            (NewGenericLib.schedule * (unknown * NewGenericLib.pat) list * (unknown * unknown) list) list

val match_schedule_to_string : NewGenericLib.schedule ->
            (unknown * NewGenericLib.pat) list ->
            (unknown * unknown) list ->
            string

val match_schedule_as_pp_constr_expr : NewGenericLib.schedule -> (unknown * NewGenericLib.pat) list -> (unknown * unknown) list -> NewGenericLib.derive_sort -> Pp.t

