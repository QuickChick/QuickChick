{
(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

  open Ltac_plugin
  open Error
  open Pp
  open Stdarg
  open DepDriver
  open GenericLib

}

DECLARE PLUGIN "coq-quickchick.plugin"

{
let merge_sound =
  let rec get_hyps (s : Evd.evar_map) (c : EConstr.constr) =
    if EConstr.isProd s c then
      let (x,t1,t2) = EConstr.destProd s c in
      (x,t1) :: get_hyps s t2
    else []
  in 
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let s = Proofview.Goal.sigma gl in
    let to_intro = get_hyps s c in
    let rec calc_ids acc opts =
      match opts with
      | [] -> begin match acc with
              | to_ind::rest -> (to_ind, List.rev acc)
              | _ -> failwith "No product/merge_sound"
              end
      | (nb,_) :: nbs ->
         begin match Context.binder_name nb with
         | Names.Name id -> calc_ids (id :: acc) nbs
         | Names.Anonymous -> calc_ids (Names.Id.of_string "H" :: acc) nbs
         end in
    match calc_ids [] to_intro with
    | (_to_induct, opts) ->
       Tactics.intros_using_then opts (fun ids ->
           Tacticals.tclTHENLIST
             [ Tacticals.onLastHyp Tactics.simplest_elim
             ; Tactics.intros 
         ])
  end;;

let remember_induct h =
  Proofview.Goal.enter begin fun gl ->
    let s = Proofview.Goal.sigma gl in
    let env = Proofview.Goal.env gl in
    let cn = EConstr.mkVar h in
    Tacticals.tclTYPEOFTHEN cn (fun evm ct -> 
        msg_debug (str "Here: " ++ Printer.pr_constr_env env s (EConstr.to_constr s ct) ++ fnl());
        let to_remember = 
          if EConstr.isApp s ct then begin
              let (ctr, cs) = EConstr.destApp s ct in
              let to_remember = ref [] in
              Array.iter (fun cx ->
                  if EConstr.isApp s cx then
                    to_remember := cx :: !to_remember
                  else if EConstr.isConstruct s cx then
                    to_remember := cx :: !to_remember
                  else msg_debug (str "All good" ++ fnl ())) cs;
              !to_remember
            end
          else failwith "Not App" in
        let eqpat = CAst.make @@ Namegen.IntroAnonymous in 
        let cl =
          { Locus.onhyps = None
          ; Locus.concl_occs = Locus.AllOccurrences } in 
        let rec do_remembers (pats : EConstr.constr list) =
          match pats with
          | [] ->
#if COQ_VERSION >= (8, 19, 0)
            Induction.induction false None cn None None
#else
            Tactics.induction false None cn None None
#endif
          | p :: ps ->
             Tacticals.tclTHEN
#if COQ_VERSION >= (8, 18, 0)             
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (Some s, p) cl)
#else
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (s, p) cl)
#endif                 
                   (do_remembers ps) in
        msg_debug (int (List.length to_remember) ++ fnl ());
        do_remembers to_remember
      )
    end 

  let grab_dependencies = 
    Proofview.Goal.enter begin fun gl ->
      
      (* Convert goal to a constr_expr *)
      let c = Proofview.Goal.concl gl in
      let e = Proofview.Goal.env gl in
      let evd = Evd.from_env e in

      match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
      | Some dt ->
        begin
          msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
          let open GenericLib in
          let rec printlist : (var * (int * int) list) list -> unit = function
            | [] -> ()
            | (var, rels) :: rest ->
              let tuple_to_string (i,j) = "(" ^ string_of_int i ^ ", " ^ string_of_int j ^ ")" in
              msg_debug (str (var_to_string var) ++ str " : " ++ str (String.concat ", " (List.map (fun i -> (tuple_to_string i)) rels)) ++ fnl ());
              printlist rest
          in
          printlist (dep_type_var_relation_uses dt);          
          Tacticals.tclIDTAC
        end
      | None -> failwith "Failed to Parse type"
    end

  let print_typeclass_bindings d c =
    let open GenericLib in
    let string_of_bool' = function
      | true -> "true"
      | false -> "false" in
    let the_type = c |> Names.Id.to_string |> injectCtr |> ctr_to_ty_ctr in
    let the_typeclass = Names.Id.to_string d in
    let bindings = find_typeclass_bindings the_typeclass the_type in
    let show_bindings = List.map (List.map string_of_bool') bindings 
                     |> List.map (String.concat "; ") 
                     |> List.map (fun s -> "[" ^ s ^ "]")
                     |> (String.concat ", ") in
    let bracket_bindings = "{" ^ show_bindings ^ "}" in
    msg_debug (str bracket_bindings ++ fnl ());
    Tacticals.tclIDTAC

(* Given a dep_type, if it is an inductive, extract its name and call find_typeclass_bindings *)
  let find_typeclass_bindings_dep_type env (typ_class : string) (dt : dep_type) : (bool list) list =
    match dt with
    | DTyCtr (c, dts) -> find_typeclass_bindings ~env_opt:(Some env) typ_class c(*constructor_to_string c |> injectCtr |> ctr_to_ty_ctr*)
    | _ -> []

  let safe_assoc i l = try List.assoc i l with _ -> []
  
  let find_arbitrary env (dt : dep_type) : coq_expr option =
    match find_typeclass_bindings_dep_type env "Arbitrary" dt with
    | [] -> None
    | _ -> Some g_arbitrary
  
  let make_bool_sig (idx : int) (dt : dep_type) : bool list =
    let len = List.length (dep_type_one_relation_variables dt) in
    List.init len (fun i -> i = (idx - 1))
  
  let rec freshen_names_in_prop (dt : dep_type) : dep_type =
    match dt with
    | DTyCtr (c, dts) -> DTyCtr (c, List.map freshen_names_in_prop dts)
    | DCtr (c, dts) -> DCtr (c, List.map freshen_names_in_prop dts)
    | DTyVar x -> DTyVar (fresh_name (var_to_string x))
  
  
  let find_arbitrary_st env (x_dt : dep_type) (dt : dep_type) (idx : int) : coq_expr option =
    match find_typeclass_bindings_dep_type env "GenSizedSuchThat" dt with
    | [] -> msg_debug (str "No such binding" ++ fnl ()); None
    | bindings ->
       let bool_sig = make_bool_sig idx dt in
       msg_debug (str "BOOLSIG: [" ++ str (List.map string_of_bool bool_sig |> String.concat ", ") ++ str "]" ++ fnl ());
       let freshen_names = freshen_names_in_prop dt in
       let output_var_name = try List.nth (dep_type_one_relation_variables (freshen_names)) (idx - 1) with _ -> CErrors.user_err (str (dep_type_to_string (freshen_names)) ++ str "\n" ++ str "dep_typ_vars freshname1" ++ str "nth failed: " ++ int (idx - 1) ++ fnl ())
      in
       if List.mem bool_sig bindings then Some (g_arbitraryST (gFunWithArgs [gArg ~assumName:(gVar output_var_name) ()] (fun [v] -> gType' [] freshen_names)))
       else None
  
  let derive_arbitrary dt = g_arbitrary
  
  let derive_arbitrary_st x_dt dt idx =
    let freshen_names = freshen_names_in_prop dt in
    let output_var_name = try List.nth (dep_type_one_relation_variables (freshen_names)) (idx - 1) with _ -> CErrors.user_err (str "dep_typ_vars freshname2" ++ str "nth failed: " ++ int (idx - 1) ++ fnl ())
    in
    let ind = gFunWithArgs [gArg ~assumName:(gVar output_var_name) ()] (fun [v] -> gType' [] freshen_names) in
    let id = (DepDriver.dep_dispatch (unsafe_coq_expr_to_constr_expr ind) GenSizedSuchThat) in
    msg_debug (Names.Id.print id ++ fnl ());
    g_arbitraryST ind
  
  let derive_or_find_arbitrary env (x_dt : dep_type) : coq_expr =
    match find_arbitrary env x_dt with
    | Some c -> c
    | None -> derive_arbitrary x_dt
    
  let derive_or_find_arbitrary_st env (x_dt : dep_type) (dt : dep_type) (idx : int) : coq_expr =
    match find_arbitrary_st env x_dt dt idx with
    | Some c -> c
    | None -> derive_arbitrary_st x_dt dt idx
  
  let derive_or_find_generators env (x, x_dt, opt_dt) : var * coq_expr * bool =
    match opt_dt with
    | None -> (x, derive_or_find_arbitrary env x_dt, false)
    | Some (dt, idx) -> (x, derive_or_find_arbitrary_st env x_dt dt idx, true)
    
    (*forall (a : nat) b c, P (S a) b -> Q c b -> R c*)
  
  let bindForAlls (generators : (var * coq_expr * bool) list) (concl : coq_expr) : coq_expr =
    List.fold_right (fun (x,g,hasInductive) acc -> 
      (*If hasInductive, then I want to generate a pattern match on the variable x as an option, and if it is Some x, then return the acc, else return g_checker gTT*)
      msg_debug (str "GENERATOR: " ++ str (var_to_string x) ++ str " : " ++ pp_coq_expr g ++ fnl ());
      let body = if hasInductive then 
        construct_match (gVar x) ~catch_all:(Some (g_checker gTT)) [(MatchCtr (injectCtr "Coq.Init.Datatypes.Some", [MatchParameter (inject_ty_param "_"); MatchU x]), acc)]
                 else acc 
          in 
      g_forAll g (gFunWithArgs [gArg ~assumName:(gVar x) ()] (fun [_] -> body))) (List.rev generators) concl
  
  let check_remaining_inductives (inductives : dep_type list) (concl : coq_expr) : coq_expr =
    let decide prop = decOptToBool (g_decOpt prop (gInt 1000)) in
    List.fold_right (fun ind acc -> gIf (decide (gType' [] ind)) acc (g_checker gTT)) inductives concl
  
  let rec fold_right_manip_remaining (f : 'a -> 'a list -> 'b -> ('b * 'a list)) (l : 'a list) (acc : 'b) : 'b =
    match l with
    | [] -> acc
    | x :: xs -> let (acc', remaining) = f x xs acc in fold_right_manip_remaining f remaining acc'
  
  (*Each element of the list is a triple (variable, variable_type, inductive_relation_binding_the_variable_and_the_index_of_variable_use) *)
  let makeBindings (theorem : dep_type) : ((var * dep_type * (dep_type * int) option) list) * dep_type list =
    let type_vars = dep_type_var_types theorem in
    let variable_uses = dep_type_var_relation_uses theorem in
    let ind_vars = dep_type_relation_variables theorem in
    let theorem_relations = dep_type_relations theorem in
    let choose_inductive_binding (v : var) var_uses : (dep_type * int * int) option =
      match List.assoc_opt v var_uses with
      | Some ((idx, var_idx) :: _) ->
        let relation = List.assoc idx theorem_relations in
        Some (relation, idx, var_idx) 
      | Some [] -> None
      | _ -> failwith "makeBindings: variable not found in variable uses"
      in 
    let aux (v,t) typed_vars (acc, var_uses, ind_vars) = 
      match choose_inductive_binding v var_uses with
      | Some (rel,idx,var_idx) -> 
        let depends = safe_assoc idx ind_vars in
        let different_depends = List.filter (fun v' -> v' <> v) depends in
        let (variables_to_arb,remaining_typed_vars) = List.partition (fun (v',_) -> (List.mem v' different_depends)) typed_vars in
        let variables_to_arb' = List.map (fun (v',t') -> (v',t',None)) variables_to_arb in
        let (var_uses', ind_vars') = GenericLib.remove_dependencies idx var_idx v var_uses ind_vars in
          (((v,t,Some (rel,var_idx)) :: variables_to_arb' @ acc, var_uses', ind_vars'), remaining_typed_vars)
      | None -> (((v,t,None) :: acc, var_uses, ind_vars), typed_vars)
      in
    let (result, _, ind_vars') = (fold_right_manip_remaining aux type_vars ([], variable_uses, ind_vars)) in
    (result, List.map (fun (i, _) -> try List.assoc i theorem_relations with _ -> failwith "makeBindings: index not found in theorem relations") ind_vars')
    (* List.map (fun (v,t) -> (v,t,choose_inductive_binding v)) type_vars *)
  
  
  
  
    
    (*Given an association, and the original dep_type, for each variable take... remember to emit variabl deptype pairs at the end of the list*)
  let construct_constrained_generator' env (bindings : (var * dep_type * (dep_type * int) option) list) (checked_inductives : dep_type list) (concl : dep_type) : coq_expr =
    let bound_generators : (var * coq_expr * bool) list = List.map (derive_or_find_generators env) bindings in
    let decide prop = decOptToBool (g_decOpt prop (gInt 1000)) in
    bindForAlls bound_generators (check_remaining_inductives checked_inductives (g_checker (decide (gType' [] concl))))
  
  let construct_constrained_generator env (theorem : dep_type) : coq_expr =
    let (bindings, checked_inductives) = makeBindings theorem in
    let (_,concl) = dep_type_hyps_and_concl theorem in
    construct_constrained_generator' env bindings checked_inductives concl
  
  let derive_and_quickchick = 
    Proofview.Goal.enter_one begin fun gl ->
      let c = Proofview.Goal.concl gl in
      let e = Proofview.Goal.env gl in
      let evd = Evd.from_env e in
      
      match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
      | Some dt -> 
        begin
          msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
          let open GenericLib in 

          (* let to_run = GenericLib.interp_open_coq_expr e evd (g_show (g_quickCheck (  (construct_constrained_generator dt)))) in
          QuickChick.define_and_run to_run e evd; *)
          let e' = Global.env () in
          let constrained_gen = construct_constrained_generator e' dt in
          debug_coq_expr constrained_gen;
          let updated_env = Global.env () in
          let updated_evd = Evd.from_env updated_env in
          let to_run = GenericLib.interp_open_coq_expr updated_env updated_evd (g_show (g_quickCheck constrained_gen)) in
          QuickChick.define_and_run to_run updated_env updated_evd;
          Tacticals.tclIDTAC
        end
      | None -> failwith "Failed to Parse type"
    end
    
let quickchick_goal =
  Proofview.Goal.enter begin fun gl ->

    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    

(*
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif
 *)  
  match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
        let open GenericLib in 
        let decide prop = decOptToBool (g_decOpt prop (gInt 1000)) in
        let rec mkProperty = function
          | DProd ((var, _),body) -> 
              g_forAll g_arbitrary (gFun [var_to_string var] (fun [_] ->
                mkProperty body
                )) 
          | DArrow (x,y) ->
                
            GenericLib.debug_coq_expr (gType' [] x); gIf (decide (gType' [] x)) (mkProperty y) (g_checker gTT)
          | p -> g_checker (decide (gType' [] p)) 
              in
          
     (*     | DArrow (DTyCtr (tyctr, args), y) -> gIf (decide )
          | DTyParam typaram -> gTyParam typaram
          | DTyCtr (tyctr, args) -> gApp (gTyCtr tyctr) (List.map mkProperty args)
          | DCtr (ctr, args) -> gApp (gCtr ctr) (List.map mkProperty args)
          | DTyVar var -> gVar var
          | DApp (f, args) -> gApp (mkProperty f) (List.map mkProperty args)
          | DNot p -> *)
(*Use decOpt, for every arrow, assume instacne exists and match on it *)
            
        GenericLib.debug_coq_expr (mkProperty dt);
        (*run the generator called checker using QuickCheck.*)
        (*failwith "OUch!";*)
        let to_run = GenericLib.interp_open_coq_expr e evd (g_show (g_quickCheck (mkProperty dt))) in
        (*failwith "Oucher!";*)
        QuickChick.define_and_run to_run e evd;
        
        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end
(*Create dependency graph, anything that lacks a dependency, print becuase we need it to *)
(*    
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in

    Printf.printf "So far so good\n"; flush stdout;
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif

    (* Construct : show (quickCheck (_ : ct)) *)
    let  qct = CAst.make @@ Constrexpr.CApp (QuickChick.quickCheck, [ct, None]) in
    let sqct = CAst.make @@ Constrexpr.CApp (QuickChick.show, [(qct,None)]) in

    Printf.printf "So far so good2\n"; flush stdout;

    (* From here on I've tried a couple of things. 
       Calling run_test directly with qct. Fails.
       Internalize here before calling define and run, fails.

       It always seems to fail in the 'interp' phase, with an 
       unknown existential variable error. So I'm probably doing something
       stupid with the evar maps *)
    let evd, to_run = Constrintern.interp_open_constr e evd sqct in

    Printf.printf "So far so good 2.5\n"; flush stdout;
    
    QuickChick.define_and_run to_run e evd;

    Printf.printf "So far so good3\n"; flush stdout;

    (* TODO: This whole block doesn't look very monadic... *)
    Tacticals.tclIDTAC
  end

    (*
    (* Admit a constant with that type *)
    let tmpid = QuickChick.fresh_name "temporary_constant" in
    let _interp_st = Vernacentries.interp (CAst.make @@ Vernacexpr.VernacExpr ([],
      (* TODO: NoDischarge or DoDischarge? *)
      Vernacexpr.VernacAssumption ((NoDischarge, Decl_kinds.Conjectural),
                        NoInline,
                        [
                          (false,
                           (
                             [CAst.make tmpid, None]
                           ,
                             ct
                           )
                          )
                        ]
                       ))) in

    let s = QuickChick.runTest @@ CAst.make @@
      Constrexpr.CApp (QuickChick.quickCheck, [CAst.make @@ CRef (Libnames.qualid_of_ident tmpid,None), None]) in
    (* I need to create an existential of type Checkable ct, and then
       call QuickChick.quickChick on that in the ast, before running
       QuickChick.runTest on the constr_expr. *)

    
    (*

       HACK (there *has* to be a better way): 
         (\x : Checkable ct -> x) _ *)

    let base = Names.Id.of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in

    let binder_list = [CLocalAssum ([CAst.make @@ Names.Name xid], Default Explicit, ct)]  in
    let f_body = CAst.make @@ CRef (CAst.make @@ Libnames.Ident xid,None) in
    let f = mkCLambdaN binder_list f_body in
    let hack_value = mkAppC (f , [ CAst.make @@ CEVarHole (None, Misctypes.IntroAnonymous, None) ] ) in
     *)
(*

    (* Refactor - needs to see internals... *)
    let base = Names.id_of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in


    let f_body = mkAppC (QuickChick.show, [mkAppC (QuickChick.quickCheck, [mkAppC (QuickChick.mk_ref "checker", [ CRef (Ident ((Loc.dummy_loc, xid)),None) ])])]) in
    let f = mkCLambdaN Loc.dummy_loc bind_list f_body in

    let env = Global.env () in
    let evd = Evd.from_env env in
    let (cf,evd) = Constrintern.interp_constr env evd f in

    let actual_term = Constr.mkApp (cf, Array.of_list [c]) in
 *)



(*
    let concl = Proofview.Goal.concl gl in
    let sigma = Tacmach.project gl in
    let hyps = named_context_val (Proofview.Goal.env gl) in
    let store = Proofview.Goal.extra gl in
    let env = Proofview.Goal.env gl in
    let () = if check && mem_named_context_val id hyps then
      errorlabstrm "Tactics.introduction"
        (str "Variable " ++ pr_id id ++ str " is already declared.")
    in
    match kind_of_term (whd_evar sigma concl) with
    | Prod (_, t, b) -> unsafe_intro env store (LocalAssum (id, t)) b
    | LetIn (_, c, t, b) -> unsafe_intro env store (LocalDef (id, c, t)) b
    | _ -> raise (RefinerError IntroNeedsProduct)
  end
 *)

*)
}
TACTIC EXTEND quickchick
  | ["quickchick"] -> { quickchick_goal }
END

TACTIC EXTEND derive_and_quickchick
  | ["derive_and_quickchick"] -> { derive_and_quickchick }
END

TACTIC EXTEND merge_sound_core
  | ["merge_sound_core"] -> { merge_sound }
END

TACTIC EXTEND remember_induct
  | ["remember_induct" ident(h)] -> { remember_induct h }
END

TACTIC EXTEND grab_dependencies
  | ["grab_dependencies"] -> { grab_dependencies }
END

TACTIC EXTEND tc_bindings
  | ["tc_bindings" ident(d) ident(c)] -> { 
     print_typeclass_bindings d c
     
    }
END


