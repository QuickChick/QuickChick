{
(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

  open Ltac_plugin
  open Error
  open Pp
  open Stdarg
  (* open Declare *)

}

DECLARE PLUGIN "coq-quickchick.plugin"

{
let merge_sound =
  let rec get_hyps (s : Evd.evar_map) (c : EConstr.constr) =
    if EConstr.isProd s c then
      let (x,t1,t2) = EConstr.destProd s c in
      (x,t1) :: get_hyps s t2
    else []
  in 
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let s = Proofview.Goal.sigma gl in
    let to_intro = get_hyps s c in
    let rec calc_ids acc opts =
      match opts with
      | [] -> begin match acc with
              | to_ind::rest -> (to_ind, List.rev acc)
              | _ -> failwith "No product/merge_sound"
              end
      | (nb,_) :: nbs ->
         begin match Context.binder_name nb with
         | Names.Name id -> calc_ids (id :: acc) nbs
         | Names.Anonymous -> calc_ids (Names.Id.of_string "H" :: acc) nbs
         end in
    match calc_ids [] to_intro with
    | (_to_induct, opts) ->
       Tactics.intros_using_then opts (fun ids ->
           Tacticals.tclTHENLIST
             [ Tacticals.onLastHyp Tactics.simplest_elim
             ; Tactics.intros 
         ])
  end;;

let remember_induct h =
  Proofview.Goal.enter begin fun gl ->
    let s = Proofview.Goal.sigma gl in
    let env = Proofview.Goal.env gl in
    let cn = EConstr.mkVar h in
    Tacticals.tclTYPEOFTHEN cn (fun evm ct -> 
        msg_debug (str "Here: " ++ Printer.pr_constr_env env s (EConstr.to_constr s ct) ++ fnl());
        let to_remember = 
          if EConstr.isApp s ct then begin
              let (ctr, cs) = EConstr.destApp s ct in
              let to_remember = ref [] in
              Array.iter (fun cx ->
                  if EConstr.isApp s cx then
                    to_remember := cx :: !to_remember
                  else if EConstr.isConstruct s cx then
                    to_remember := cx :: !to_remember
                  else msg_debug (str "All good" ++ fnl ())) cs;
              !to_remember
            end
          else failwith "Not App" in
        let eqpat = CAst.make @@ Namegen.IntroAnonymous in 
        let cl =
          { Locus.onhyps = None
          ; Locus.concl_occs = Locus.AllOccurrences } in 
        let rec do_remembers (pats : EConstr.constr list) =
          match pats with
          | [] ->
#if COQ_VERSION >= (8, 19, 0)
            Induction.induction false None cn None None
#else
            Tactics.induction false None cn None None
#endif
          | p :: ps ->
             Tacticals.tclTHEN
#if COQ_VERSION >= (8, 18, 0)             
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (Some s, p) cl)
#else
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (s, p) cl)
#endif                 
                   (do_remembers ps) in
        msg_debug (int (List.length to_remember) ++ fnl ());
        do_remembers to_remember
      )
    end 

let quickchick_goal = Tacticals.tclIDTAC
  
  (*Tacticals.tclIDTAC;
  Proofview.Goal.enter begin fun gl ->

    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
(*
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif
 *)  
  match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
        let open NewGenericLib in 
        let decide prop = decOptToBool (g_decOpt prop (gInt 1000)) in
        let rec mkProperty = function
          | DProd ((var, _),body) -> 
              g_forAll g_arbitrary (gFun [var_to_string var] (fun [_] ->
                mkProperty body
                )) 
          | DArrow (x,y) -> NewGenericLib.debug_coq_expr (gType' [] x); gIf (decide (gType' [] x)) (mkProperty y) (g_checker gTT)
          | p -> g_checker (decide (gType' [] p)) 
              in
          
     (*     | DArrow (DTyCtr (tyctr, args), y) -> gIf (decide )
          | DTyParam typaram -> gTyParam typaram
          | DTyCtr (tyctr, args) -> gApp (gTyCtr tyctr) (List.map mkProperty args)
          | DCtr (ctr, args) -> gApp (gCtr ctr) (List.map mkProperty args)
          | DTyVar var -> gVar var
          | DApp (f, args) -> gApp (mkProperty f) (List.map mkProperty args)
          | DNot p -> *)
(*Use decOpt, for every arrow, assume instacne exists and match on it *)
            
        NewGenericLib.debug_coq_expr (mkProperty dt);
        (*run the generator called checker using QuickCheck.*)
        (*failwith "OUch!";*)
        let to_run = NewGenericLib.interp_open_coq_expr e evd (g_show (g_quickCheck (mkProperty dt))) in
        (*failwith "Oucher!";*)
#if COQ_VERSION >= (8, 20, 0)
        (* FRAGILE probably won't be allowed in the future? *)
        let opaque_access = Library.indirect_accessor[@@warning "-3"] in
        QuickChick.define_and_run ~opaque_access to_run e evd;
#else
        QuickChick.define_and_run to_run e evd;
#endif

        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end *)
(*Create dependency graph, anything that lacks a dependency, print becuase we need it to *)
(*    
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in

    Printf.printf "So far so good\n"; flush stdout;
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif

    (* Construct : show (quickCheck (_ : ct)) *)
    let  qct = CAst.make @@ Constrexpr.CApp (QuickChick.quickCheck, [ct, None]) in
    let sqct = CAst.make @@ Constrexpr.CApp (QuickChick.show, [(qct,None)]) in

    Printf.printf "So far so good2\n"; flush stdout;

    (* From here on I've tried a couple of things. 
       Calling run_test directly with qct. Fails.
       Internalize here before calling define and run, fails.

       It always seems to fail in the 'interp' phase, with an 
       unknown existential variable error. So I'm probably doing something
       stupid with the evar maps *)
    let evd, to_run = Constrintern.interp_open_constr e evd sqct in

    Printf.printf "So far so good 2.5\n"; flush stdout;
    
    QuickChick.define_and_run to_run e evd;

    Printf.printf "So far so good3\n"; flush stdout;

    (* TODO: This whole block doesn't look very monadic... *)
    Tacticals.tclIDTAC
  end

    (*
    (* Admit a constant with that type *)
    let tmpid = QuickChick.fresh_name "temporary_constant" in
    let _interp_st = Vernacentries.interp (CAst.make @@ Vernacexpr.VernacExpr ([],
      (* TODO: NoDischarge or DoDischarge? *)
      Vernacexpr.VernacAssumption ((NoDischarge, Decl_kinds.Conjectural),
                        NoInline,
                        [
                          (false,
                           (
                             [CAst.make tmpid, None]
                           ,
                             ct
                           )
                          )
                        ]
                       ))) in

    let s = QuickChick.runTest @@ CAst.make @@
      Constrexpr.CApp (QuickChick.quickCheck, [CAst.make @@ CRef (Libnames.qualid_of_ident tmpid,None), None]) in
    (* I need to create an existential of type Checkable ct, and then
       call QuickChick.quickChick on that in the ast, before running
       QuickChick.runTest on the constr_expr. *)

    
    (*

       HACK (there *has* to be a better way): 
         (\x : Checkable ct -> x) _ *)

    let base = Names.Id.of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in

    let binder_list = [CLocalAssum ([CAst.make @@ Names.Name xid], Default Explicit, ct)]  in
    let f_body = CAst.make @@ CRef (CAst.make @@ Libnames.Ident xid,None) in
    let f = mkCLambdaN binder_list f_body in
    let hack_value = mkAppC (f , [ CAst.make @@ CEVarHole (None, Misctypes.IntroAnonymous, None) ] ) in
     *)
(*

    (* Refactor - needs to see internals... *)
    let base = Names.id_of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in


    let f_body = mkAppC (QuickChick.show, [mkAppC (QuickChick.quickCheck, [mkAppC (QuickChick.mk_ref "checker", [ CRef (Ident ((Loc.dummy_loc, xid)),None) ])])]) in
    let f = mkCLambdaN Loc.dummy_loc bind_list f_body in

    let env = Global.env () in
    let evd = Evd.from_env env in
    let (cf,evd) = Constrintern.interp_constr env evd f in

    let actual_term = Constr.mkApp (cf, Array.of_list [c]) in
 *)



(*
    let concl = Proofview.Goal.concl gl in
    let sigma = Tacmach.project gl in
    let hyps = named_context_val (Proofview.Goal.env gl) in
    let store = Proofview.Goal.extra gl in
    let env = Proofview.Goal.env gl in
    let () = if check && mem_named_context_val id hyps then
      errorlabstrm "Tactics.introduction"
        (str "Variable " ++ pr_id id ++ str " is already declared.")
    in
    match kind_of_term (whd_evar sigma concl) with
    | Prod (_, t, b) -> unsafe_intro env store (LocalAssum (id, t)) b
    | LetIn (_, c, t, b) -> unsafe_intro env store (LocalDef (id, c, t)) b
    | _ -> raise (RefinerError IntroNeedsProduct)
  end
 *)

*)

open NewGenericLib

let is_inductive' (ty_name : ty_ctr) : bool =
  let locate_result = Nametab.locate_all (ty_name) in
  List.exists (function
               | Names.GlobRef.IndRef _ -> true
               | _ -> false) locate_result

let get_inductive_name name : Names.inductive option =
  let locate_result = Nametab.locate_all (name) in
  List.find_map (function
  | Names.GlobRef.IndRef ind -> Some ind
  | Names.GlobRef.ConstructRef constructor -> Some (Names.inductive_of_constructor constructor)
  | _ -> None) locate_result
  
let rec extract_inductives_from_type (typ : rocq_constr) : Names.inductive list =
  match typ with
  | DTyCtr (c, args) | DCtr (c, args)->
    (match get_inductive_name c with
    | Some ind -> ind :: List.concat_map extract_inductives_from_type args
    | None -> msg_debug (str ("Inductive not found: " ^ ty_ctr_to_string c)); [])
  | DApp (f, args) -> extract_inductives_from_type f @ List.concat_map extract_inductives_from_type args
  | _ -> []

let rec extract_inductives_rocq_constr (dt : rocq_constr) : Names.inductive list =
  match dt with
  | DProd ((_, t), dt) -> extract_inductives_from_type t @ extract_inductives_rocq_constr dt
  | DArrow (t, dt) -> extract_inductives_from_type t @ extract_inductives_rocq_constr dt
  | DTyCtr _ -> extract_inductives_from_type dt
  | _ -> failwith "Rule hypotheses and conclusions must be inductive."

let rec extract_names_rocq_constr (dt : rocq_constr) : ty_ctr list =
  match dt with
  | DProd ((_, DTyCtr (c,_)), ty2) -> 
    if is_inductive' c then
      c :: extract_names_rocq_constr ty2
    else
      failwith ("Rule hypotheses and conclusions must be inductive 1. Found: " ^ ty_ctr_to_string c ^ " " ^ rocq_constr_to_string dt)
  | DProd ((_, DTyVar _), ty2) -> extract_names_rocq_constr ty2
  | DProd ((_, DTyParam _), ty2) -> extract_names_rocq_constr ty2
  | DArrow (DTyCtr (c,_), ty2) -> 
    if is_inductive' c then
      c :: extract_names_rocq_constr ty2
    else
      failwith ("Rule hypotheses and conclusions must be inductive 2. Found: " ^ ty_ctr_to_string c ^ " " ^ rocq_constr_to_string dt)
  | DArrow (_, ty2) -> extract_names_rocq_constr ty2
  | DTyCtr (_, _) -> []
  | _ -> failwith ("Rule hypotheses and conclusions must be inductive 3. " ^ rocq_constr_to_string dt)

let overall_type_inductive_names ((ind_name, params, rules, overall_type) : rocq_relation) : ty_ctr list =
  extract_names_rocq_constr overall_type

let constructors_used_inductive_names ((ind_name, params, rules, overall_type) : rocq_relation) : ty_ctr list =
  remove_duplicates (List.concat_map (fun (cons, typ) -> extract_names_rocq_constr typ) rules)

let rocq_relation_used_inductives' ((ind_name, params, rules, overall_type) : rocq_relation) : Names.Indset.t =
  Names.Indset.of_list (extract_inductives_rocq_constr overall_type @ List.concat_map (fun (_,typ) -> extract_inductives_rocq_constr typ) rules)

let inductive_to_rocq_relation ((mind,ix) : Names.inductive) : rocq_relation =
  (* Lookup the mutual inductive body in the _global_ environment. *)
  let mib = Environ.lookup_mind mind (Global.env ()) in
  (* Parse each `one_inductive_body` into a rocq relation. All should succeed. *)
  let rs = sequenceM oib_to_rocq_relation (Array.to_list mib.Declarations.mind_packets) in
  match rs with
  | None -> failwith ("Inductive not found: " ^ Names.MutInd.to_string mind)
  | Some rs -> List.nth rs ix

let inductives_used_in_inductive (ind : Names.inductive) : Names.Indset.t =
  let rocq_relation = inductive_to_rocq_relation ind in
  Names.Indset.add ind (rocq_relation_used_inductives' rocq_relation)

module TyCtrMap = Map.Make(struct type t = ty_ctr let compare = compare end)

let rocq_relation_memo : rocq_relation TyCtrMap.t ref = ref TyCtrMap.empty

let ty_ctr_to_rocq_relation (tycon : ty_ctr) =
  match TyCtrMap.find_opt tycon !rocq_relation_memo with
  | Some r -> r
  | None -> begin
    match ty_ctr_to_rocq_relations tycon with
    | None -> failwith ("Inductive not found: " ^ ty_ctr_to_string tycon)
    | Some (idx, rels) -> 
      begin match List.nth_opt rels idx with
      | None -> failwith ("Inductive not found (nth failed in ty_ctr_to_rocq_relation): " ^ ty_ctr_to_string tycon)
      | Some r -> rocq_relation_memo := TyCtrMap.add tycon r !rocq_relation_memo; r
      end
    end

let seek_ind_types_from_overall_type root : ty_ctr list =
  let rec seek_ind_types ind_name visited : ty_ctr list =
    if List.mem ind_name visited then
      visited 
    else
      let rocq_relation = ty_ctr_to_rocq_relation ind_name in
      let used_inds = constructors_used_inductive_names rocq_relation in
      List.fold_left (fun visited' ind_name' -> seek_ind_types ind_name' visited') (ind_name :: visited) used_inds
    in
  let rocq_relation = ty_ctr_to_rocq_relation root in
  let used_inds = overall_type_inductive_names rocq_relation in
  
  List.fold_left (fun visited' ind_name' -> seek_ind_types ind_name' visited') [root] used_inds

let seek_rocq_relations root : rocq_relation list =
  let rec seek_ind_types ind_name visited : rocq_relation Names.Indmap.t =
    if Names.Indmap.mem ind_name visited then
      visited 
    else
      let rocq_relation = inductive_to_rocq_relation ind_name in
      let used_inds = rocq_relation_used_inductives' rocq_relation in
      Names.Indset.fold (fun ind_name' visited'  -> seek_ind_types ind_name' visited') used_inds (Names.Indmap.add ind_name rocq_relation visited)
    in
  let map = seek_ind_types root Names.Indmap.empty in
  List.map snd (Names.Indmap.bindings map)

let print_type_names (inds : ty_ctr list) : unit =
  List.iter (fun ind -> msg_debug (str (ty_ctr_to_string ind) ++ fnl ())) inds

let seek_all_rocq_relation root_ind_name : rocq_relation list =
  List.map (fun name -> ty_ctr_to_rocq_relation name) (seek_ind_types_from_overall_type root_ind_name)

type constraint_type = FunConstraint | ConConstraint | FunConConstraint

type constrained_arg =
  | Constrained of var list * constraint_type
  | Unconstrained of var

type ind = ty_ctr * rocq_constr list
  
type constrained_ind =  ty_ctr * constrained_arg list 

let constrain_check_ind ((ind_ctr, ind_args) : ind) : constrained_ind =
  let rec collect_vars (ct : rocq_constr) : var list =
    match ct with
    | DTyParam p -> [p]
    | DTyVar p -> [p]
    | DTyCtr (c, args) -> List.concat_map collect_vars args
    | DCtr (c, args) -> List.concat_map collect_vars args
    | DApp (f, args) -> collect_vars f @ List.concat_map collect_vars args
    | _ -> failwith "Inductive arguments must be constructors or params." in

  let rec contains_constructor = function
    | DTyCtr (_, _) | DCtr (_, _) -> true
    | DApp (f, args) -> contains_constructor f || List.exists contains_constructor args
    | _ -> false in

  let rec contains_application = function
    | DTyCtr (_, args) -> List.exists contains_application args
    | DCtr (_, args) -> List.exists contains_application args
    | DApp (_, _) -> true
    | _ -> false in

  let check_constraints (ct : rocq_constr) : constrained_arg =
    match ct with
    | DTyParam p | DTyVar p -> Unconstrained p 
    | _ ->
      let contains_constructor = contains_constructor ct in
      let contains_application = contains_application ct in
      if contains_constructor && contains_application then
        Constrained (collect_vars ct, FunConConstraint)
      else if contains_constructor then
        Constrained (collect_vars ct, ConConstraint)
      else if contains_application then
        Constrained (collect_vars ct, FunConstraint)
      else
        failwith ("Inductive arguments must be constructors or params. This is not: " ^ rocq_constr_to_string ct) in
  (ind_ctr, List.map check_constraints ind_args)

type arity = int

type output_index = int

type rule = ty_ctr * constructor * arity * constrained_ind list * constrained_ind

let rec rocq_constr_arity = function
  | DProd ((_, _), t2) -> 1 + rocq_constr_arity t2
  | DArrow (_, y) -> 1 + rocq_constr_arity y
  | _ -> 0

let rocq_relation_arity ((ind_name, params, rules, overall_type) : rocq_relation) : int =
  match rules with
  | [] -> rocq_constr_arity overall_type
  | (cname, ctype) :: xs -> 
    (match type_info ctype with
    | (_,_,DTyCtr (ind, args)) -> List.length args
    | _ -> failwith "Rule hypotheses and conclusions must be inductive.")

let types_to_constructor_lookup (types : rocq_relation list) : (constructor * (constructor * arity) list) list =
  let rocq_relation_collect_constructors ((ind_name, params, rules, overall_type) : rocq_relation) : (constructor * arity) list =
    List.map (fun (name, typ) -> (name, rocq_constr_arity typ)) rules in
  let constructor_to_constructors_map (a : ('a * 'b) list) : ('a * ('a * 'b) list) list =
    List.map (fun (x,_) -> (x, a)) a in
  List.concat_map (fun ind_rules -> constructor_to_constructors_map (rocq_relation_collect_constructors ind_rules)) types

type constructor_map = (constructor * (constructor * arity) list) list

let eq_basename c1 c2 = Libnames.qualid_basename c1 = Libnames.qualid_basename c2
let eq_tyctr_basename c1 c2 = ty_ctr_basename c1 = ty_ctr_basename c2

let find_type (c : constructor) (types : constructor_map) : (constructor * arity) list =
  let rec assoc_opt_eq c l eq = match l with
    | [] -> None
    | (a, b) :: l -> if eq a c then Some b else assoc_opt_eq c l eq in 
  match assoc_opt_eq c types eq_basename with
  | None -> failwith ("Constructor not found: " ^ constructor_to_string c ^ " map: " ^ List.fold_left (fun acc (c, _) -> acc ^ ", " ^ constructor_to_string c) "" types)
  | Some cs ->
    msg_debug (str (List.fold_right (fun (c, a) acc -> constructor_to_string c ^ " " ^ string_of_int a ^ ", " ^ acc) cs "") ++ fnl ());
      cs 

type pattern =
| PCtr of constructor * pattern list
| PWild

let rec string_of_pattern = 
  function
  | PCtr (c, []) -> constructor_to_string c
  | PCtr (c, p :: ps) -> 
    let cstr = constructor_to_string c in
    (if cstr = "Tuple_" then "" else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
  | PWild -> "_"

let tuple_name = ty_ctr_of_string "Tuple_"

let rec map_maybe f = function
  | [] -> []
  | x :: xs -> 
    (match f x with
    | None -> map_maybe f xs
    | Some y -> y :: map_maybe f xs)

(*Gets patterns from conclusion of constructor*)
let pattern_of_rocq_ctr (ctr : rocq_ctr) : constructor * pattern =
  let rec pattern_args = function
    | DCtr (c, args) -> Some (PCtr (c, map_maybe pattern_args args))
    | DApp (DTyVar f, args) -> Some PWild
    | DTyVar _ -> Some PWild
    | DTyParam _ -> Some PWild
    | DTyCtr (_,_) -> None (*Type argument*)
    | a -> failwith ("Argument to " ^ constructor_to_string (fst ctr) ^ " must be constructors or function applications or variables. Found: " ^ rocq_constr_to_string a) in
  let rec pattern_of_rocq_constr = function
    | DProd ((_, _), t2) -> pattern_of_rocq_constr t2
    | DArrow (_, y) -> pattern_of_rocq_constr y
    | DTyCtr (ind, args) -> PCtr (tuple_name, map_maybe pattern_args args)
    | a -> failwith ("Rule hypotheses and conclusions must be inductive: " ^ rocq_constr_to_string a) in
  let (name, ctr_typ) = ctr in
  msg_debug (str (rocq_constr_to_string ctr_typ) ++ fnl ());
  (name, pattern_of_rocq_constr ctr_typ)

let input_pattern_of_rocq_ctr (ctr : rocq_ctr) (ois : output_index list) : constructor * pattern =
  let (cons, PCtr (_,patterns)) = pattern_of_rocq_ctr ctr in
  let wildcard_indices ois patterns = List.mapi (fun i p -> if List.mem i ois then PWild else p) patterns in
  (cons, PCtr (tuple_name, wildcard_indices ois patterns))

let input_patterns_of_rocq_relation ((ind_name, params, rules, overall_type) : rocq_relation) (ois : output_index list) : (constructor * pattern) list =
  List.map (fun ctr -> input_pattern_of_rocq_ctr ctr ois) rules

(*Type of search trees*)
type pattern_coverage_tree =
  | PatternLeaf of pattern * constructor list 
    (*the pattern describes the least granular space needed to describe coverage at this point, and the list of rules which provide coverage to it, if any.*)
  | PatternNode of pattern * constructor list * int list * (constructor * pattern_coverage_tree) list (*The int list represents the path to the current wildcard thats being split*)

let print_decomposed_pattern (dec : (constructor * int * int list) list) : unit =
  msg_debug (str "Printing Decomposed Pattern" ++ fnl ());
  let string_of_dec (c, n, path) = constructor_to_string c ^ " " ^ string_of_int n ^ " :" ^ List.fold_left (fun acc i -> acc ^ ", " ^ string_of_int i) "" path in 
  List.iter (fun d -> msg_debug (str (string_of_dec d) ++ fnl ())) dec;
  msg_debug (str "Finished Decomposed Pattern" ++ fnl ())

let enumerate_list = List.mapi (fun i p -> p,i)

let rec decompose_pattern_path (p : pattern) (path : int list): (constructor * int * int list) list =
  match p with
  | PCtr (c, ps) -> 
      (c, List.length ps, path) :: List.concat_map (fun (p, i) -> decompose_pattern_path p (path @ [i])) (enumerate_list ps)
  | PWild -> []

let decompose_pattern (p : pattern) : (constructor * int * int list) list =
  let dec = decompose_pattern_path p [] in print_decomposed_pattern dec; msg_debug (fnl ()); dec

let rec apply_at (f : 'a -> 'a) (i : int) (l : 'a list) : 'a list =
  match l, i with
  | [], _ -> []
  | x :: xs, 0 -> f x :: xs 
  | x :: xs, i -> x :: apply_at f (i - 1) xs

let rec apply_lookup eq (f : 'a -> 'a) (i : 'i) (l : ('i * 'a) list) : ('i * 'a) list =
  match l with
  | [] -> []
  | (i', x) :: xs -> if eq i i' then (i', f x) :: xs else (i', x) :: apply_lookup eq f i xs

let rec insert_at_path (p : pattern) (path : int list) (c : constructor) wilds : pattern =
  match path with
  | [] -> PCtr (c, wilds)
  | i :: is -> 
      match p with
      | PCtr (c', ps) -> PCtr (c', apply_at (fun p' -> insert_at_path p' is c wilds) i ps)
      | PWild -> failwith "Path is too long"

let rec make_wilds n =
  if n > 0 then PWild :: make_wilds (n - 1)
  else [] 

let rec label_tree label ptree : pattern_coverage_tree =
  match ptree with
  | PatternLeaf (p, rules) -> PatternLeaf (p, label :: rules)
  | PatternNode (p, rules, path, branches) -> PatternNode (p, label :: rules, path, List.map (fun (c, p') -> (c, label_tree label p')) branches) 

let rec pattern_at_path (path : int list) (p : pattern) : pattern =
  match path with
  | [] -> p
  | i :: is ->
      match p with
      | PCtr (c, ps) -> pattern_at_path is (List.nth ps i)
      | PWild -> PWild  

let rec cover_single_pattern_layer (con : constructor)
    (path : int list) (pat_so_far : pattern) (p : pattern_coverage_tree) 
    (types : constructor_map) : pattern_coverage_tree =
  match p with
  | PatternLeaf (pat, rules)-> 
      let constructors = find_type con types in
      let new_pattern c arity = insert_at_path pat path c (make_wilds arity) in
      let new_pattern_leaves = List.map (fun (c, arity) -> c, PatternLeaf (new_pattern c arity, rules)) constructors in
      PatternNode (pat, rules, path, new_pattern_leaves)
  | PatternNode (pat, rules, path', branches)->
      if path = path' then 
        PatternNode (pat, rules, path', branches)
      else
        begin match pattern_at_path path' pat_so_far with
        | PWild -> 
            PatternNode (pat, rules, path', 
                         List.map (fun (c, p') -> (c, cover_single_pattern_layer con path pat_so_far p' types)) branches
                        )
        | PCtr (c, _) -> 
            PatternNode (pat, rules, path', 
                         apply_lookup eq_basename (fun p' -> cover_single_pattern_layer con path pat_so_far p' types) c branches
                        )
        end

let rec subpattern (sub : pattern) (pat : pattern) : bool =
  msg_debug (str ("sub: " ^ string_of_pattern sub ^ " | sup: " ^ string_of_pattern pat) ++ fnl ());
  match sub, pat with
  | _, PWild -> true
  | PWild, PCtr (c, ps) -> false
  | PCtr (subc, subps), PCtr (c, ps) -> 
    if eq_basename subc c then
      try (List.for_all2 (fun sub sup -> subpattern sub sup) subps ps) with Invalid_argument _ -> failwith "Patterns with same constructor have different argument count: subpattern"
    else false

let rec compatible_pattern (sub : pattern) (pat : pattern) : bool =
  match sub, pat with
  | _, PWild -> true
  | PWild, PCtr (c, ps) -> true
  | PCtr (subc, subps), PCtr (c, ps) ->
    if eq_basename subc c then
      try (List.for_all2 (fun sub sup -> compatible_pattern sub sup) subps ps) with Invalid_argument _ -> failwith "Patterns with same constructor have different argument count: compatible_pattern"
    else false

let rec label_subpatterns (rule_name : constructor) (pat : pattern) (pt : pattern_coverage_tree) : pattern_coverage_tree =
  match pt with
  | PatternLeaf (p, rules) -> if subpattern p pat then PatternLeaf (p, rule_name :: rules) else pt
  | PatternNode (p, rules, path, branches) ->
    msg_debug (str (constructor_to_string rule_name) ++ fnl ());
    if subpattern p pat then label_tree rule_name pt else
    if compatible_pattern p pat then
      PatternNode (p, rules, path, List.map (fun (c, p') -> (c, label_subpatterns rule_name pat p')) branches)
    else pt 

let rec cover_decomposed_pattern (pat_so_far : pattern) (dec : (constructor * int * int list) list) (p : pattern_coverage_tree) (types : constructor_map) : pattern_coverage_tree =
  match dec with
  | [] -> p
  | (c, n, path) :: rest ->
      let new_p = cover_single_pattern_layer c path pat_so_far p types in 
      let pat_so_far' = insert_at_path pat_so_far path c (make_wilds n) in
      cover_decomposed_pattern pat_so_far' rest new_p types

let pattern_tree_root : pattern_coverage_tree = PatternLeaf (PWild, [])

let cover_pattern' (rule_name : constructor) (p : pattern) (types : constructor_map) (ptree : pattern_coverage_tree) : pattern_coverage_tree =
  let dec = decompose_pattern p in
  label_subpatterns rule_name p (cover_decomposed_pattern PWild dec ptree types)

let cover_patterns (ps : (constructor * pattern) list) (types : constructor_map) root : pattern_coverage_tree =
  List.fold_left (fun ptree (c, p) -> cover_pattern' c p types ptree) root ps

let tuple_types arity = (tuple_name,[tuple_name,arity])

let cover_tuple_patterns ps arity types = cover_patterns ps (tuple_types arity :: types) pattern_tree_root

let rec map_patterns (f : pattern -> pattern) (tree : pattern_coverage_tree) : pattern_coverage_tree =
  let f' = function
    | PWild -> PWild
    | a -> f a in
  match tree with
  | PatternLeaf (p, cs) -> PatternLeaf (f' p, cs)
  | PatternNode (p, cs, path, branches) -> PatternNode (f' p, cs, path, List.map (fun (c, subtree) -> (c, map_patterns f' subtree)) branches) 

let print_coverage_tree (ind : ty_ctr) (tree : pattern_coverage_tree) (ois : output_index list) = 
  let replace_at_indices is x l = List.mapi (fun i y -> if List.mem i is then x else y) l in
  let insert_output_in_leaf (PCtr (c, ps)) = PCtr (c, replace_at_indices ois (PCtr (constructor_of_string "OUT",[])) ps) in
  let tree' = map_patterns insert_output_in_leaf tree in
  let rec string_of_pattern = 
    function
    | PCtr (c, []) -> constructor_to_string c
    | PCtr (c, p :: ps) -> 
      let cstr = constructor_to_string c in
      (if cstr = "Tuple_" then ty_ctr_to_string ind else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
    | PWild -> "_" in
  let string_of_constructors = function
    | [] -> "[]"
    | c :: cs -> "[" ^ constructor_to_string c ^ List.fold_left (fun acc c -> acc ^ "; " ^ constructor_to_string c) "" cs ^ "]" in
  let string_of_pattern_leaf (p, cs) = string_of_pattern p ^ " : " ^ string_of_constructors cs in
  let rec print_tree indent = function
    | PatternLeaf (p, cs) -> Feedback.msg_notice (str (String.make indent ' ' ^ string_of_pattern_leaf (p, cs)) ++ fnl ())
    | PatternNode (p, cs, path, branches) -> 
      Feedback.msg_notice (str (String.make indent ' ' ^ string_of_pattern p ^ " : " ^ string_of_constructors cs ) ++ fnl ());
      List.iter (fun (c, subtree) -> print_tree (indent + 2) subtree) branches
    in
  print_tree 0 tree'


(*Take in an inductive name and a rocq_ctr (a dependent constructor), and collect the hypotheses and conclusions*)
let rule_of_rocq_ctr ind_name (ctr : rocq_ctr) : rule =
  let (name, ctr_typ) = ctr in
  let rec hyp_conc = function
    | DProd ((_, _), t2) -> 
      let (hyps, conc, arity) = hyp_conc t2 in
      (hyps, conc, arity + 1)
    | DArrow (DTyCtr (ind, args), y) -> 
      let (hyps, conc, arity) = hyp_conc y in
      ((ind,args) :: hyps, conc, arity)
    | DArrow (DNot (DTyCtr (ind,args)),y) when eq_tyctr_basename ind (ty_ctr_of_string "Coq.Init.Logic.eq") ->  (* a <> b as a hypothesis affects the density little, 
                                                                                                     assuming a and b are independently generated.
                                                                                                     need to check for that later, for now, we just
                                                                                                     drop any <> hypothesis regardless of its args.*)
      let (hyps, conc, arity) = hyp_conc y in
      (hyps, conc, arity)
    | DTyCtr ((ind,args)) -> ([], (ind,args), 0)
    | _ -> failwith "Rule hypotheses and conclusions must be inductive." in 
  let (hyps, conc, arity) = hyp_conc ctr_typ in
  (ind_name, name, arity, List.map constrain_check_ind hyps, constrain_check_ind conc)

let rocq_relation_rules ((ind_name, params, rules, overall_type) : rocq_relation) : rule list =
  List.map (rule_of_rocq_ctr ind_name) rules

type rule_density = 
  | Checking
  | Backtracking
  | Neutral
  | Partial
  | Total

let rec collect_leaves (tree : pattern_coverage_tree) : (pattern * constructor list) list =
  match tree with
  | PatternLeaf (p, cs) -> [(p,cs)]
  | PatternNode (_, _, _, branches) ->
      List.concat_map (fun (_, subtree) -> collect_leaves subtree) branches

let density_to_string = function
  | Checking -> "Checking"
  | Backtracking -> "Backtracking"
  | Neutral -> "Neutral"
  | Partial -> "Partial"
  | Total -> "Total"

let print_pattern_leaves (ind : ty_ctr) (tree : pattern_coverage_tree) (ois : output_index list) (densities : (constructor * rule_density) list) : unit =
  let rec string_of_pattern = 
    function
    | PCtr (c, []) -> constructor_to_string c
    | PCtr (c, p :: ps) -> 
      let cstr = constructor_to_string c in
      (if cstr = "Tuple_" then ty_ctr_to_string ind else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
    | PWild -> "_" in
  let string_of_constructors = function
    | [] -> "[]"
    | (c,d) :: cs -> "[" ^ constructor_to_string c ^ ": " ^ density_to_string d ^ List.fold_left (fun acc (c,d) -> acc ^ "; " ^ constructor_to_string c ^ ": " ^ density_to_string d) "" cs ^ "]" in
  let string_of_pattern_leaf (p, cs) = string_of_pattern p ^ " : " ^ string_of_constructors cs in
  let replace_at_indices is x l = List.mapi (fun i y -> if List.mem i is then x else y) l in
  let insert_output_in_leaf (PCtr (c, ps), cs) = (PCtr (c, replace_at_indices ois (PCtr (constructor_of_string "OUT",[])) ps), cs) in
  let annotate_densities (p, cs) = (p, List.map (fun c -> (c, List.assoc c densities)) cs) in
  List.iter (fun (p, cs) -> Feedback.msg_notice (str (string_of_pattern_leaf (annotate_densities (insert_output_in_leaf (p, cs)))) ++ fnl ())) (collect_leaves tree)

let print_rule_densities (rs : (constructor * rule_density) list) : unit =
  List.iter (fun (c,d) -> Feedback.msg_notice (str (  constructor_to_string c ^ ": " ^ density_to_string d) ++ fnl ())) rs

let rec has_duplicates (lst : 'a list) : bool =
  match lst with
  | [] -> false
  | x :: xs -> List.mem x xs || has_duplicates xs

let remove_duplicates l =
  let rec remove_duplicates' l acc =
    match l with
    | [] -> acc
    | x :: xs -> if List.mem x acc then remove_duplicates' xs acc else remove_duplicates' xs (x :: acc) in
  remove_duplicates' l []

let print_duplicates lst  : string =
  Feedback.msg_notice (str (String.concat ", " (List.map var_to_string lst)) ++ fnl ());
  let rec print_duplicates' lst acc =
    match lst with
    | [] -> acc
    | x :: xs -> if List.mem x xs then print_duplicates' xs (acc ^ ", " ^ var_to_string x) else print_duplicates' xs acc in
  print_duplicates' lst ""

let not_pairwise_disjoint (xss : 'a list list) : bool =
  let sets = List.map remove_duplicates xss in
  if 
  has_duplicates (List.concat sets) 
  then
    (Feedback.msg_notice (str "Not pairwise disjoint: " ++ str (print_duplicates (List.concat sets)) ++ fnl ()); true)
  else false

let split_indices xs idxs =
  let rec go xs idxs i =
    match xs with
    | [] -> ([], [])
    | x :: xs -> 
      if List.mem i idxs then 
        let (inidx, outidx) = go xs idxs (i + 1) in
        (x :: inidx, outidx)
      else 
        let (ys, zs) = go xs idxs (i + 1) in
        (ys, x :: zs) 
    in
  go xs idxs 0

let density_to_string = function
  | Checking -> "Checking"
  | Backtracking -> "Backtracking"
  | Neutral -> "Neutral"
  | Partial -> "Partial"
  | Total -> "Total"

let subsets (xs : 'a list) : 'a list list =
  let rec subsets' xs acc =
    match xs with
    | [] -> acc
    | x :: xs -> subsets' xs (List.map (fun ys -> x :: ys) acc @ acc) in
  subsets' xs [[]]

let has_intersection (xs : 'a list) (ys : 'a list) : bool =
  List.exists (fun x -> List.mem x ys) xs

module RelationInstOrd = struct
  type t = ty_ctr * output_index list * derive_sort
  let compare (ty, args, ds) (ty', args', ds') =
    match (get_inductive_name ty, get_inductive_name ty') with
    | (Some ty, Some ty') -> (match compare ty ty' with
                              | 0 -> (match compare args args' with
                                      | 0 -> compare ds ds'
                                      | c -> c)
                              | c -> c)
    | Some _, None when ty_ctr_to_string ty' = "theorem" -> -1
    | None, Some _ when ty_ctr_to_string ty = "theorem" -> 1
    | None, None when ty_ctr_to_string ty = "theorem" && ty_ctr_to_string ty' = "theorem" -> compare ds ds' 
    | _ ->  failwith ("RelationInstOrd: Inductive name not found in " ^ ty_ctr_to_string ty ^ " or " ^ ty_ctr_to_string ty')
end

module RelationInstMap = Map.Make(RelationInstOrd)

let density_memo : rule_density RelationInstMap.t ref = ref RelationInstMap.empty

let density_inductive_memo : (inductive_schedule * rule_density) RelationInstMap.t ref = ref RelationInstMap.empty

(*Three heuristics detecting difficult to generate rules*)
let rec is_output_constrained_in_hypothesis ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let output_index_hyps = List.concat_map (fun (ind, args) -> fst (split_indices args ois)) recursive_hyps in
  if List.exists (fun arg -> match arg with
    | Constrained _ -> true
    | Unconstrained _ -> false) output_index_hyps
    then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": output constrained in hypothesis") ++ fnl ()); true) else false

and is_output_hyps_require_unification ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let collect_vars = function
    | Constrained (args,_) -> args
    | Unconstrained arg -> [arg] in
  let output_index_hyps : ty_param list list = List.map (fun (ind,args) -> List.concat_map collect_vars (fst (split_indices args ois))) recursive_hyps in
  Feedback.msg_notice (str (String.concat ", " (List.map string_of_int ois)) ++ fnl ());
  if not_pairwise_disjoint output_index_hyps then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": output hyps require unification") ++ fnl ()); true) else false

and is_input_conclusion_require_unification ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let conclusion_args = snd conc in
  let (_,input_conc_args) = split_indices conclusion_args ois in
  let collect_vars = function
    | Constrained (args,_) -> args
    | Unconstrained arg -> [arg] in
  let all_input_conc_vars = List.concat_map collect_vars input_conc_args in
  if has_duplicates all_input_conc_vars then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": input conc requires unification") ++ fnl ()); true) else false

and are_functions_constraining_conclusion_inputs_or_hyp_outputs ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let conclusion_args = snd conc in
  let (_,input_conc_args) = split_indices conclusion_args ois in
  let fun_constrained = function
    | Constrained (args, FunConstraint) | Constrained (args, FunConConstraint) -> true
    | _ -> false in
  if List.exists fun_constrained input_conc_args then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": functions constrain conclusion inputs") ++ fnl ()); true) else
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let output_index_hyps : constrained_arg list list = List.map (fun (ind, args) -> fst (split_indices args ois)) recursive_hyps in
  if List.exists (fun args -> List.exists fun_constrained args) output_index_hyps then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": functions constrain hypothesis outputs") ++ fnl ()); true) else false

and nonrecursive_disjoint_strictly_output_vars ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : (ty_ctr * (output_index * ty_param) list) list =
  let (conclusion_output_args,conclusion_input_args) = split_indices (snd conc) ois in
  let args_to_vars arg_list = List.concat_map (function Constrained (args,_) -> args | Unconstrained arg -> [arg]) arg_list in
  let conclusion_output_vars = args_to_vars conclusion_output_args in
  let conclusion_input_vars = args_to_vars conclusion_input_args in
  let (nonrecursive_hyps, recursive_hyps) = List.partition (fun (ind, args) -> ind <> ind_name) hyps in
  let recursive_output_vars = List.concat_map (fun (ind, args) -> args_to_vars (fst (split_indices args ois))) recursive_hyps in
  let nonrecursive_output_vars = List.map (fun (ind, args) -> 
    let numbered_args = List.mapi (fun i arg -> (i, arg)) args in
    let unconstrained_vars = List.concat_map (function (n,Unconstrained arg) -> [(n,arg)] | _ -> []) numbered_args in
    let unconstrained_output_vars = List.filter (fun (_,v) -> List.mem v conclusion_output_vars) unconstrained_vars in
    let unconstrained_output_noninput_vars = List.filter (fun (_,v) -> not (List.mem v conclusion_input_vars)) unconstrained_output_vars in
    let unconstrained_disjoint_output_noninput_vars = List.filter (fun (_,v) -> not (List.mem v recursive_output_vars)) unconstrained_output_noninput_vars in
    ind,unconstrained_disjoint_output_noninput_vars) nonrecursive_hyps in
  nonrecursive_output_vars
  
and filter_nonrecursive_empty_densities (nonrecurse : (ty_ctr * (output_index * ty_param) list)) =
  let (ind, output_vars) = nonrecurse in
  let rocq_relation = ty_ctr_to_rocq_relation ind in
  let output_subsets = subsets output_vars in
  let filtered_ovars = List.filter_map (fun ois_vars ->
    let density = final_density rocq_relation (List.map fst ois_vars) false D_Gen in
    match density with
    | Checking -> None
    | Backtracking | Partial | Neutral | Total -> Some (ois_vars, density)) output_subsets in
  ind,filtered_ovars

and nonrecursive_binding (nonrecursives : (ty_ctr * ((output_index * ty_param) list * rule_density) list) list) : ((ty_ctr * (output_index * ty_param) list * rule_density) list) option =
  match nonrecursives with
  | [] -> Some []
  | (ind, []) :: rest -> None
  | (ind, (oi_vs,Partial) :: ovars) :: rest ->
    let updated_rest = List.map (fun (ind, ovars) -> (ind, List.filter (fun (oi_vs',_) -> not (has_intersection oi_vs oi_vs')) ovars)) rest in
    (match nonrecursive_binding updated_rest with
    | None -> nonrecursive_binding ((ind, ovars) :: rest)
    | Some bindings -> Some ((ind, oi_vs, Partial) :: bindings))
  | (ind, (oi_vs,Backtracking) :: ovars) :: rest -> 
    let updated_rest = List.map (fun (ind, ovars) -> (ind, List.filter (fun (oi_vs',_) -> not (has_intersection oi_vs oi_vs')) ovars)) rest in
    (match nonrecursive_binding ((ind,ovars) :: rest) with
     | Some ((ind',oi_vs',Partial) :: bindings) -> Some ((ind', oi_vs', Partial) :: bindings)
     | _ -> (match nonrecursive_binding updated_rest with | None -> None | Some bindings -> Some ((ind, oi_vs, Backtracking) :: bindings)) 
    )
    
and is_nonrecursive_checked_or_overlapping_or_empty ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let nonrecursive_output_vars = nonrecursive_disjoint_strictly_output_vars (ind_name, ctr_name, arity, hyps, conc) ois in
  let filtered_nonrecursive_output_vars = List.map filter_nonrecursive_empty_densities nonrecursive_output_vars in
  match nonrecursive_binding filtered_nonrecursive_output_vars with
  | None -> (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": >= 1 nonrecursive bindings must be checked") ++ fnl ()) ; true)
  | Some [] -> false
  | Some bindings -> 
    Feedback.msg_notice (str "Printing nonrecursive bindings for: " ++ str (constructor_to_string ctr_name) ++ fnl ()); 
    List.iter (fun (ind, oi_vs, density) -> Feedback.msg_notice (str (ty_ctr_to_string ind ^ " argument #s: " ^ String.concat "," (List.map (fun (o,_) -> string_of_int o) oi_vs) ^ "; var names: " ^ String.concat "," (List.map (fun (_,v) -> ty_param_to_string v) oi_vs) ^ "; density: " ^ density_to_string density) ++ fnl ())) bindings;
    false (*In the future these bindings should be output and prederived.*)

and analyze_rule (r : rule) (ois : output_index list) : rule_density =
  msg_debug (str (List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());
  if is_output_hyps_require_unification r ois 
    || is_input_conclusion_require_unification r ois
    || are_functions_constraining_conclusion_inputs_or_hyp_outputs r ois
    || is_nonrecursive_checked_or_overlapping_or_empty r ois 
  then 
    Checking 
  else if is_output_constrained_in_hypothesis r ois then
    Backtracking
  else 
    Partial

and analyze_rules (rs : rule list) ois : (constructor * rule_density) list =
  List.map (fun (ind, cons, arity, hyps, conc) -> (cons, analyze_rule (ind, cons, arity, hyps, conc) ois)) rs

and final_density (dt : rocq_relation) ois (should_print : bool) (ds : derive_sort) : rule_density =
  let (ind_name, _, _, _) = dt in
  if RelationInstMap.mem (ind_name, ois, ds) !density_memo then RelationInstMap.find (ind_name, ois, ds) !density_memo
  else
  let inductive = (match get_inductive_name ind_name with | Some i -> i | None -> failwith "final_density: not an inductive type") in
  let tree = cover_tuple_patterns (input_patterns_of_rocq_relation dt ois) (rocq_relation_arity dt) (types_to_constructor_lookup (seek_rocq_relations inductive)) in
  let covered_patterns = collect_leaves tree in
  let densities = analyze_rules (rocq_relation_rules dt) ois in
  if should_print then (Feedback.msg_notice (str ("Rule densities for: " ^ ty_ctr_to_string ind_name ^ " with output indices: " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());
  print_rule_densities densities);
  (* let filter_empty_constructors = List.map (fun (p, cs) -> p, List.filter (fun c -> match List.assoc c densities with | Checking -> false | Partial | Backtracking -> true) cs) covered_patterns in
  let any_uncovered = List.exists (fun (p,cs) -> cs = []) filter_empty_constructors in
  let all_has_partial = List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities = Partial) cs) filter_empty_constructors in
  let result = if any_uncovered then Checking else if all_has_partial then Partial else Backtracking in *)
  let filter_uncovered_patterns = List.filter (fun (p, cs) -> match cs with | [] -> false | _ -> true) covered_patterns in
  let all_covered_has_nonempty = List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities <> Checking) cs) filter_uncovered_patterns in
  let result = if not all_covered_has_nonempty then 
                Checking 
               else if List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities = Partial) cs) filter_uncovered_patterns 
               then 
                Partial 
               else 
                Backtracking in
  density_memo := RelationInstMap.add (ind_name, ois, ds) result !density_memo;
  if should_print then (Feedback.msg_notice (str "Rule pattern coverage tree:" ++ fnl ());
                        print_coverage_tree ind_name tree ois; Feedback.msg_notice (fnl ());
                        Feedback.msg_notice (str "Set of patterns and densities of their covering rules:" ++ fnl ());
                        print_pattern_leaves ind_name tree ois densities; 
                        Feedback.msg_notice (str ("Inductive relation " ^ ty_ctr_to_string ind_name ^ " with output indices:"
                                                  ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois 
                                                  ^ " has overall density: " 
                                                  ^ (density_to_string result)) ++ fnl ()));
  result

let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs -> 
    match f x with
    | None -> None
    | Some y -> 
      match traverse f xs with
      | None -> None
      | Some ys -> Some (y :: ys)

type schedule_with_density = (schedule_step * rule_density) list * schedule_sort

let are_schedule_steps_valid i ((steps, sort) : schedule_with_density) : bool = true

let num_source_variables (s : source) : int =
  match s with
  | SrcNonrec (hyp) -> List.length (variables_in_hypothesis hyp)
  | SrcRec (_, args) -> List.length (List.concat_map variables_in_hypothesis args)
  | SrcMutrec (_, args) -> List.length (List.concat_map variables_in_hypothesis args)
  | SrcDef (_, args) -> List.length (List.concat_map variables_in_hypothesis args)

let density_score density ds =
  let how_sparse = 
  match density with
  | Checking -> 0
  | Backtracking -> 1
  | Neutral -> 2
  | Partial -> 3
  | Total -> 4
  in
  match ds with
  | D_Gen | D_Thm -> how_sparse
  | D_Check | D_Enum -> 4 - how_sparse

let num_source_bound_vars env (s : source) ds : int =
  let variables =
    match s with
    | SrcNonrec (hyp) -> variables_in_hypothesis hyp
    | SrcRec (_, args) -> List.concat_map variables_in_hypothesis args
    | SrcMutrec (_, args) -> List.concat_map variables_in_hypothesis args
    | SrcDef (_, args) -> List.concat_map variables_in_hypothesis args in
  List.fold_right (fun v acc ->
    match List.assoc_opt v env with
    | Some density -> density_score density ds + acc
    | None -> acc) variables 0

(* let num_source_bound_vars env (s : source) : int =
  List.length (match s with
  | SrcNonrec (hyp) -> List.filter (fun v -> List.mem v env) (variables_in_hypothesis hyp)
  | SrcRec (_, args) -> List.filter (fun v -> List.mem v env) (List.concat_map variables_in_hypothesis args)
  | SrcMutrec (_, args) -> List.filter (fun v -> List.mem v env) (List.concat_map variables_in_hypothesis args)
  | SrcDef (_, args) -> List.filter (fun v -> List.mem v env) (List.concat_map variables_in_hypothesis args)) *)

let add_bound_vars env step density = 
  match step with
  | S_UC (v, _, _) -> (v,density) :: env
  | S_Check _ -> env
  | S_ST (vs,_,_) -> (List.map (fun (v,_) -> v,density) vs) @ env
  | S_Match (_, pat) -> (List.map (fun v -> v,density) (pat_vars pat)) @ env
  | S_Let (v, _) -> (v, density) :: env

let get_num_var_uses ((steps, sort) : schedule_with_density) ds : int =
  let get_step_score env (step, density) =
    match step with
    | S_UC (_,s,_) -> num_source_bound_vars env s ds
    | S_Check (s,_) -> num_source_bound_vars env s ds
    | S_ST (_, s, _) -> num_source_bound_vars env s ds
    | S_Match (v, _) -> 
      (match List.assoc_opt v env with
      | Some density -> density_score density ds
      | None -> 0)
(*       
      (if List.mem v env then 1 else 0) *)
    | S_Let (_, c) -> num_source_bound_vars env (SrcNonrec c) ds (*Using srcnonrec because equivalent behavior, and it is always nonrecursive source.*)
  in
  
  let rec aux env = function
    | [] -> 0
    | (step,density) :: rest -> get_step_score env (step, density) + aux (add_bound_vars env step density) rest in

  aux [] steps


(* let schedule_density schedule : schedule_with_density =
  let step_density (step : schedule_step) ds : rule_density =
    match step with
    | S_UC _  -> Total (* For enumerations during a checker should unconstrained be empty? *)
    | S_Check _  -> Checking
    | S_ST (_, SrcRec _, _) -> (match ds with D_Gen | D_Thm -> Total | D_Check | D_Enum -> Checking) 
    | S_Match _ -> Backtracking
    | S_ST (output_var_tys, SrcNonrec (DTyCtr (ind,args)), _) -> 
      let output_vars = List.map fst output_var_tys in
      let rec is_output i = (function
        | DTyVar j -> List.mem j output_vars
        | DCtr (_, args) -> List.exists (is_output i) args
        | _ -> false) in
      let output_indices = filter_mapi (fun i arg -> if is_output i arg then Some i else None) args in
      (match final_density (ty_ctr_to_rocq_relation ind) output_indices false with
      | Checking -> Feedback.msg_notice (str ("Relation " ^ ty_ctr_to_string ind ^ " with ois: " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" output_indices ^ " is checking") ++ fnl ()); Checking
      | d -> d)
    | S_ST (_, SrcNonrec _, _) -> failwith "is_schedule_valid: Nonrecursive source should have DTyCtr at toplevel" 
  in
  let (steps, sort) = schedule in
  let ds = match sort with
    | TheoremSchedule _ -> D_Thm
    | ProducerSchedule (_,PS_E,_) -> D_Enum
    | ProducerSchedule (_,PS_G,_) -> D_Gen
    | CheckerSchedule -> D_Check in
  let step_densities = List.map (fun step -> (step, step_density step ds)) steps in
  (step_densities, sort) *)

let schedule_with_densities_to_string (s : schedule_with_density) =
  let (steps, sort) = s in
  Printf.sprintf "do %s \n=> %s\n" (String.concat " ;\n " (List.map (fun (step, density) -> schedule_step_to_string step ^ " " ^ density_to_string density) steps)) (schedule_sort_to_string sort)

let producer_sort_to_derive_sort (ps : producer_sort) : derive_sort =
  match ps with
  | PS_E -> D_Enum
  | PS_G -> D_Gen

let check_eq (u1,u2) = S_Check (SrcNonrec (DTyCtr (ty_ctr_of_string "Coq.Init.Logic.eq", [DHole; DTyVar u1; DTyVar u2])), true)

let rec arrows_to_products typ =
  match typ with
  | DArrow (t1, t2) -> 
    let name = make_up_name () in
    DProd ((name, t1), arrows_to_products t2)
  | DProd ((name, t1), t2) -> DProd ((name, t1), arrows_to_products t2)
  | _ -> typ

let sort_schedules_by_density_and_var_uses (schedules : (int * schedule_with_density) list) (ds : derive_sort) : (schedule_with_density * rule_density * int * int) list =
  
  match ds with
  | D_Gen | D_Thm ->
    (*Maximize worst density, minimize var_uses*)
    let compare_gen (_,d,uses,_) (_,d',uses',_) =
      match compare d d' with
      | 0 -> compare uses uses'
      | c -> - c 
    in

    let get_min = function
    | (_,x) :: _ -> x
    | [] -> Total
    in 

    List.sort compare_gen @@ List.map (fun (i, (schd_steps,schd_sort)) ->
      let min_density = get_min @@ List.sort (fun (_,d) (_,d') -> compare d d') schd_steps in
      let num_var_uses = get_num_var_uses (schd_steps,schd_sort) ds in 
      ((schd_steps,schd_sort), min_density, num_var_uses, i)) schedules

  (* | D_Thm -> failwith "ow" *)
  | D_Enum | D_Check ->    
    (*Minimize best density, minimize var_uses (for check maximize var_uses?)*)
    let compare_enum (_,d,uses,_) (_,d',uses',_) =
      match compare d d' with
      | 0 -> compare uses uses'
      | c -> c 
    in

    let get_max = function
    | (_,x) :: _ -> x
    | [] -> Checking
    in

    List.sort compare_enum @@ List.map (fun (i, (schd_steps,schd_sort)) ->
      let max_density = get_max @@ List.sort (fun (_,d) (_,d') -> - (compare d d')) schd_steps in
      let num_var_uses = get_num_var_uses (schd_steps,schd_sort) ds in
      ((schd_steps,schd_sort), max_density, num_var_uses, i)) schedules

let rec schedule_density neutral_prelude_steps schedule : schedule_with_density =
  let step_density (step : schedule_step) ds : rule_density =
    match step with
    | S_UC (v, SrcNonrec (DTyParam param), ps) ->
      Neutral (* If we have a type parameter we want to generate for, we can't know its density since it is abstracted, hence Neutral. *) 
    | S_UC (v,SrcNonrec ty,ps) ->
      (ignore (best_inductive_schedule_from_instance ty [] (producer_sort_to_derive_sort ps) false);
      Total) (* For enumerations during a checker should unconstrained be empty? *)
    | S_UC (_,SrcRec _,_) -> Total
    | S_Check (SrcNonrec ty,pol) ->
      (ignore (best_inductive_schedule_from_instance ty [] D_Check true);
      if pol then Checking else Partial)
    | S_Check (SrcRec _, pol) -> if pol then Checking else Partial
    | S_ST (_, SrcRec _, _) -> (match ds with D_Gen | D_Thm -> Total | D_Check | D_Enum -> Checking) 
    | S_ST (output_var_tys, SrcNonrec (DTyCtr (ind,args)), ps) -> 
      let output_vars = List.map fst output_var_tys in
      let rec is_output i = (function
        | DTyVar j -> List.mem j output_vars
        | DCtr (_, args) -> List.exists (is_output i) args
        | _ -> false) in
      let output_indices = filter_mapi (fun i arg -> if is_output i arg then Some i else None) args in
      snd (inductive_best_valid_schedule (ty_ctr_to_rocq_relation ind) output_indices (producer_sort_to_derive_sort ps) true)
    | S_ST (_, SrcNonrec _, _) -> failwith "is_schedule_valid: Nonrecursive source should have DTyCtr at toplevel" 
    | S_Match _ -> Backtracking
    | S_ST (_, SrcMutrec _, _)
    | S_UC (_,SrcMutrec _, _)
    | S_Check (SrcMutrec _, _) -> failwith "is_schedule_valid: Mutually recursive source should not be used at density calculation time, but inserted later."
    | S_ST (_, SrcDef _, _)
    | S_UC (_,SrcDef _, _)
    | S_Check (SrcDef _, _) -> failwith "is_schedule_valid: Defined source should not be used at density calculation time, but inserted later."
    | S_Let (_,_) -> Total
  in

  let (steps, sort) = schedule in

  let ds = match sort with
    | TheoremSchedule (concl,true) -> 
      ignore (best_inductive_schedule_from_instance concl [] D_Check true);
      D_Thm
    | TheoremSchedule (concl,false) -> 
      failwith "is_schedule_valid: TheoremSchedule should have true flag because that means it has not been replaced with a definition"
    | ProducerSchedule (_,PS_E,_) -> D_Enum
    | ProducerSchedule (_,PS_G,_) -> D_Gen
    | CheckerSchedule -> D_Check in

  let step_densities = List.map (fun step -> (step, match ds with D_Thm | D_Gen -> Total | D_Check | D_Enum -> Checking)) neutral_prelude_steps @ List.map (fun step -> (step, step_density step ds)) steps in
  (* Check for unifications and heuristics! *)

  

  (step_densities, sort)


(* let does_schedule_satisfy_heuristics ((steps, sort) : schedule) =
  let rec aux (ois : output_index list) (outputs : var list) (inputs : var list) =
    (* Need *)

   *)

(* let is_binding_selection_valid i ((bindings,unbound) : bindings_and_unbound) =
  let is_binding_valid (v, ty, opt) =
    match opt with
    | None -> Some (v,ty,opt, Partial)
    | Some (DTyCtr (ind,_), i) ->
      (match final_density (ty_ctr_to_dep_dt ind) [i] false with
      | Checking -> None
      | d -> Some (v, ty, opt, d))
    | _ -> failwith "is_binding_selection_valid: Binding relation should have DTyCtr at toplevel" in
  match traverse is_binding_valid bindings with
  | None -> None
  | Some bs -> Some (i, (bs, unbound)) *)

(* Create a map from types * outputs => inductive_schedules which can be reused and referenced. *)

(** There will always exist at least one partial schedule for producers, b/c you can just arb all variables and check all hyps.*)

and constructor_valid_schedules (ind_name : ty_ctr) (ctr : rocq_ctr) (result_vars : (var * rocq_constr) list) (output_vars : var list) (ds : derive_sort) (opt : bool) : (int * schedule_with_density) list =
  let (ctr_name, typ) = ctr in
  let typ = if opt then typ else arrows_to_products typ in
  let schedule_matches = NewUnifyQC.type_to_schedules typ (Some ind_name) (Some ctr_name) result_vars output_vars ds opt in
  let schedules = List.mapi (fun i ((steps, sort), ms, eqs) -> i, (List.map (fun (v,p) -> S_Match (v,p)) ms), ((List.map check_eq eqs @ steps), sort)) schedule_matches in
  let schedule_densities = List.map (fun (i,ms_steps,schd) -> i, schedule_density ms_steps schd) schedules in
  List.filter (fun (i,schd) -> are_schedule_steps_valid i schd) schedule_densities

and select_best_schedule (schedules : (int * schedule_with_density) list) (ds : derive_sort) : (int * schedule * rule_density) option =
  match sort_schedules_by_density_and_var_uses schedules ds with
  | [] -> None
  | ((schd_steps_density,schd_sort), density, num_var_uses, id) :: _ -> Some (id, (List.map fst schd_steps_density,schd_sort), density)

and constructor_best_valid_schedule (ind_name : ty_ctr) (ctr : rocq_ctr) (result_vars : (var * rocq_constr) list) (output_vars : var list) (ds : derive_sort) (opt : bool) : ty_ctr * (int * schedule * rule_density) option =
  fst ctr, select_best_schedule (constructor_valid_schedules ind_name ctr result_vars output_vars ds opt) ds

and inductive_best_valid_schedule (rel : rocq_relation) (output_idxs : int list) (ds : derive_sort) (opt : bool) : inductive_schedule * rule_density =
  let (ind_name, params, ctrs, result_typ) = rel in
  if RelationInstMap.mem (ind_name, output_idxs, ds) !density_inductive_memo then RelationInstMap.find (ind_name, output_idxs, ds) !density_inductive_memo
  else begin
  Error.msg_debug (str "Inductive name: " 
  ++ str (ty_ctr_to_string ind_name)
  ++ str "\n Parameters: "
  ++ str (String.concat ", " (List.map ty_param_to_string params)) 
  ++ str "\n Result Type: "
  ++ str (rocq_constr_to_string result_typ) 
  ++ str "\n Output indices: "
  ++ str (String.concat ", " (List.map string_of_int output_idxs)) 
  ++ str "\n\n");

  let rec get_result_vars = function
  | DProd ((v,t), b) ->
    let v = make_up_name_str ("v_" ^ var_to_string v) in
    (v,t) :: get_result_vars b
  | DArrow (t1, t2) ->
    let v = make_up_name_str "v" in
    (v,t1) :: get_result_vars t2
  | _ -> [] in

  let result_vars = List.map (fun p -> (p, DHole)) params @ get_result_vars result_typ in

  let rec remake_result vars result = 
  match vars, result with
  | [], _ -> result
  | (v,t) :: rest, DProd  (_, t') 
  | (v,t) :: rest, DArrow (_, t') -> DProd ((v,t), remake_result rest t')
  | _ -> failwith "remake_result failed" in

  let output_vars = List.map fst (List.filteri (fun i _ -> List.mem i output_idxs) result_vars) in

  let modestring = String.init (List.length result_vars) (fun i -> if List.mem i output_idxs then 'O' else 'I') in

  let typeclass_name = function
    | (D_Check, _) -> "DecOpt"
    | (D_Thm, _) -> failwith "Inductives cannot make theorems"
    | (D_Gen, false) -> "GenSized" 
    | (D_Gen, true) -> "GenSizedSuchThat" 
    | (D_Enum, false) -> "EnumSized"
    | (D_Enum, true) -> "EnumSizedSuchThat" in

  let schedule_name = Printf.sprintf "%s_%s_%s" (typeclass_name (ds, opt)) (ty_ctr_to_string ind_name) modestring in

  let init_density = match ds with
    | D_Check | D_Enum -> Checking
    | D_Gen | D_Thm -> if opt then Partial else Total in

  density_inductive_memo := RelationInstMap.add (ind_name, output_idxs, ds) ((schedule_name,[],[],[]), init_density) !density_inductive_memo;

  let constructor_schedules_with_density = List.filter_map (fun ctr -> 
    match constructor_best_valid_schedule ind_name ctr result_vars output_vars ds opt with
    | (ctr_name, None) -> failwith ("Should be at least one partial schedule for all constructors including this one: " ^ constructor_to_string ctr_name)
    | (ctr_name, Some (i, schd, density)) -> Some (schd,(ctr_name,density))) ctrs in

  let (constructor_schedules, densities) = List.split constructor_schedules_with_density in

  let is_recursive (steps,sort) = 
    List.exists (function | S_UC (_,SrcRec _,_) | S_ST (_,SrcRec _, _) | S_Check (SrcRec _,_) -> true | _ -> false) steps 
  in

  let (nonrecursive, recursive) = List.partition is_recursive constructor_schedules in

  let result_vars_mexps = filter_mapi (fun i (v,t) -> if List.mem i output_idxs then None else Some (v, NewGenericLib.product_free_rocq_type_to_mexp t)) result_vars in 

  let inductive_schedule : inductive_schedule =
    (schedule_name, result_vars_mexps, List.map (fun c -> (c, [])) recursive, List.map (fun c -> (c, [])) nonrecursive) 
  in

  let fold_left1 f acc l =
    match l with
    | [] -> acc
    | x :: xs -> List.fold_left f x xs in

  let sparsest densities =
    (* let min_dense a b =
      match a,b with
      | Total, _ -> Total
      | _, Total -> Total
      | Partial, _ -> Partial
      | _, Partial -> Partial
      | Backtracking, _ -> Backtracking
      | _, Backtracking -> Backtracking
      | Checking, Checking -> Checking in *)
    fold_left1 (fun acc d -> if d > acc then d else acc) Checking densities in

  let densest densities =
    (* let max_dense a b =
      match a,b with
      | Checking, _ -> Checking
      | _, Checking -> Checking
      | Backtracking, _ -> Backtracking
      | _, Backtracking -> Backtracking
      | Partial, _ -> Partial
      | _, Partial -> Partial
      | Total, Total -> Total in *)
    fold_left1 (fun acc d -> if d < acc then d else acc) Total densities in

  let best_density densities = 
    match ds with
    | D_Check | D_Enum -> densest densities
    | D_Gen | D_Thm -> sparsest densities in

  let worst_density densities = 
    match ds with
    | D_Check | D_Enum -> sparsest densities
    | D_Gen | D_Thm -> densest densities in

  let tree = cover_tuple_patterns (input_patterns_of_rocq_relation rel output_idxs) (rocq_relation_arity rel) (types_to_constructor_lookup (seek_all_rocq_relation ind_name)) in
  let covered_patterns = collect_leaves tree in
  (* if should_print then (Feedback.msg_notice (str ("Rule densities for: " ^ ty_ctr_to_string ind_name ^ " with output indices: " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ()); *)
  (* print_rule_densities densities); *)
  (* let filter_empty_constructors = List.map (fun (p, cs) -> p, List.filter (fun c -> match List.assoc c densities with | Checking -> false | Partial | Backtracking -> true) cs) covered_patterns in
  let any_uncovered = List.exists (fun (p,cs) -> cs = []) filter_empty_constructors in
  let all_has_partial = List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities = Partial) cs) filter_empty_constructors in
  let result = if any_uncovered then Checking else if all_has_partial then Partial else Backtracking in *)
  let filter_uncovered_patterns = List.filter (fun (p, cs) -> match cs with | [] -> false | _ -> true) covered_patterns in
  let best_density_in_patterns = List.map (fun (p, cs) -> worst_density (List.map (fun c -> List.assoc c densities) cs)) filter_uncovered_patterns in
  let overall_density = worst_density best_density_in_patterns in

  (Error.msg_debug (str "Rule pattern coverage tree:" ++ fnl ());
                        print_coverage_tree ind_name tree output_idxs; Error.msg_debug (fnl ());
                        Error.msg_debug (str "Set of patterns and densities of their covering rules:" ++ fnl ());
                        print_pattern_leaves ind_name tree output_idxs densities; 
                        Error.msg_debug (str ("Inductive relation " ^ ty_ctr_to_string ind_name ^ " with output indices:"
                                                  ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" output_idxs 
                                                  ^ " has overall density: " 
                                                  ^ (density_to_string overall_density)) ++ fnl ()));

  density_inductive_memo := RelationInstMap.add (ind_name, output_idxs, ds) (inductive_schedule, overall_density) !density_inductive_memo;
  Feedback.msg_notice (str (Printf.sprintf "%s: %s Done, Density: %s\n" (schedule_name) (String.concat ", " (List.map string_of_int output_idxs)) (density_to_string overall_density))); 
  inductive_schedule, overall_density
end

and best_inductive_schedule_from_instance (ind_instance : rocq_type) (output_vars : var list) (ds : derive_sort) (opt : bool) : inductive_schedule * rule_density =
  match ind_instance with
  | DTyCtr (ind_name, args) -> 
    let output_idxs = filter_mapi (fun i -> function | DTyVar v -> if List.mem v output_vars then Some i else None | _ -> None) args in
    (* Feedback.msg_debug (str (ty_ctr_to_string ind_name ^ " with output indices: " ^ String.concat "," (List.map string_of_int output_idxs)) ++ fnl ()); *)
    inductive_best_valid_schedule (ty_ctr_to_rocq_relation ind_name) output_idxs ds opt
  | DNot (DTyCtr (ind_name, args)) when ds = D_Check ->
    inductive_best_valid_schedule (ty_ctr_to_rocq_relation ind_name) [] ds opt
  | _ -> failwith "best_inductive_schedule_from_instance: not a DTyCtr"

let best_theorem_schedule (thm : rocq_type) : schedule =
  let schedule_matches = NewUnifyQC.type_to_schedules thm None None [] [] D_Thm true in
  let schedules = List.mapi (fun i ((steps, sort), ms, eqs) -> i,List.map (fun (v,p) -> S_Match (v,p)) ms, ((List.map check_eq eqs @ steps), sort)) schedule_matches in
  let schedule_densities = List.map (fun (i,ms_steps,schd) -> i, schedule_density ms_steps schd) schedules in
  let valid_schedules = List.filter (fun (i,schd) -> are_schedule_steps_valid i schd) schedule_densities in
  match select_best_schedule valid_schedules D_Thm with
  | None -> failwith "best_theorem_schedule: No valid schedules found"
  | Some (i, schedule, _) -> schedule

let collect_inductive_dependents (instance : rocq_constr * int list * derive_sort * bool) : (rocq_constr * int list * derive_sort * bool) list =
  let (ind_instance, output_idxs, ds, opt) = instance in
  match ind_instance with
  | DTyCtr (ind_name,_) -> 
    let (inductive_schd, density) = RelationInstMap.find (ind_name, output_idxs, ds) !density_inductive_memo in
    inductive_schedule_dependents inductive_schd
  | DTyParam param -> []
    (* failwith "collect_inductive_dependents: Need to handle instances of parameter type variables, like A in list A" *)
  | _ -> failwith "collect_inductive_dependents: not a DTyCtr or DTyVar"

let lookup_and_remove_inductive_schedule (instance : rocq_constr * int list * derive_sort * bool) (to_remove : bool) : (inductive_schedule * derive_sort * bool) option =
  let (ind_instance, output_idxs, ds, opt) = instance in
  match ind_instance with
  | DTyCtr (ind_name,_)  | DNot (DTyCtr (ind_name, _)) ->
    (try (let (inductive_schd, density) = RelationInstMap.find (ind_name, output_idxs, ds) !density_inductive_memo in
    if to_remove then density_inductive_memo := RelationInstMap.remove (ind_name, output_idxs, ds) !density_inductive_memo;
    Some (inductive_schd, ds, opt)) with Not_found -> None)
  | DTyVar v -> failwith "lookup_and_remove_inductive_schedule: Need to handle instances of parameter type variables, like A in list A"
  | _ -> failwith ("lookup_and_remove_inductive_schedule: not a DTyCtr or DTyVar: " ^ rocq_constr_to_string ind_instance)

let update_source step src =
  match step with
  | S_UC (v,_,ps) -> S_UC (v, src, ps)
  | S_Check (_,pol) -> S_Check (src, pol)
  | S_ST (vs,_,ps) -> S_ST (vs, src, ps)
  | S_Match (v,pat) -> S_Match (v, pat)
  | S_Let (v,c) -> S_Let (v,c)

let nonrec_to_mutrec_call name ois ty opt : source =
  match ty with
  | DTyCtr (ind, args) -> 
    let input_args = filter_mapi (fun i arg -> if List.mem i ois then None else Some arg) args in
    SrcDef (var_of_string name, input_args)
  | _ -> failwith "nonrec_to_mutrec_call: not a DTyCtr"

let nonrecursive_type step =
  match step with
  | S_UC (_,SrcNonrec ty,_)
  | S_ST (_,SrcNonrec ty,_) 
  | S_Check (SrcNonrec ty,_) -> ty
  | S_Match _ -> failwith "nonrecursive_type: step must not be a match"
  | S_Let _ -> failwith "nonrecursive_type: step must not be a let"
  | _ -> failwith "nonrecursive_type: step must have nonrecursive source"

let insert_mutrec_call name ois step opt =
  update_source step (nonrec_to_mutrec_call name ois (nonrecursive_type step) opt)

let insert_mutrec_calls ((schedule,matches) : schedule * (var * pat) list) : schedule * (var * pat) list =
  let (schedule_steps_deps,schd_sort_dep) = schedule_with_dependents schedule in
  let zero = DCtr (constructor_of_string "Coq.Init.Datatypes.O", []) in
  let succ n = DCtr (constructor_of_string "Coq.Init.Datatypes.S", [n]) in 
  let three = succ (succ (succ zero)) in
  let mul n m = DCtr (constructor_of_string "Coq.Init.Nat.mul", [n; m]) in (*TODO: Add Constants to the language so I don't have to apply functions as if they are constructors.*)
  let updated_steps = List.map (fun (step,depopt) -> 
                                    (match (depopt >>= fun dep -> lookup_and_remove_inductive_schedule dep false) with
                                    | None -> step
                                    | Some ((ind_schd_name,_,_,_),ds,opt) -> 
                                      let Some (_,ois,_,_) = depopt in insert_mutrec_call ind_schd_name ois step opt)) 
                        schedule_steps_deps in 
          
  let updated_sort = match schd_sort_dep with
    | (TheoremSchedule (t,true), Some (ctr, ois, ds, opt)) ->
      Error.msg_debug (str ("Inserting mutrec calls for theorem: " ^ rocq_constr_to_string ctr) ++ fnl ()); 
      (match lookup_and_remove_inductive_schedule (ctr, ois, ds, opt) false with
      | None -> TheoremSchedule (t,true)
      | Some ((schd_name,_,_,_), _, _) ->
      (match t with
      | DTyCtr (_, args) -> 
        let input_args = filter_mapi (fun i arg -> if List.mem i ois then None else Some arg) args in
        let fuel_arg = mul three (DTyVar (var_of_string "size")) in
        let new_conclusion = DApp (DTyVar (var_of_string schd_name), fuel_arg :: input_args) in
        TheoremSchedule (new_conclusion, false)
      | DNot (DTyCtr (_, args)) ->
        let input_args = filter_mapi (fun i arg -> if List.mem i ois then None else Some arg) args in
        let fuel_arg = mul three (DTyVar (var_of_string "size")) in
        let new_conclusion = DNot (DApp (DTyVar (var_of_string schd_name), fuel_arg :: input_args)) in
        TheoremSchedule (new_conclusion, false)
      | _ -> failwith "insert_mutrec_calls: TheoremSchedule must have DTyCtr at toplevel"))
    | (schd_sort,_) -> schd_sort in

  (updated_steps, updated_sort), matches

let insert_mutrec_calls_inductive_schedule (is : inductive_schedule) : inductive_schedule =
  let (name, result_vars, nonrecursive_hyps, recursive_hyps) = is in
  Error.msg_debug (str ("Inserting mutrec calls for inductive schedule: " ^ name) ++ fnl ());
  let updated_nonrecursive_hyps = List.map insert_mutrec_calls nonrecursive_hyps in
  let updated_recursive_hyps = List.map insert_mutrec_calls recursive_hyps in
  (name, result_vars, updated_nonrecursive_hyps, updated_recursive_hyps)

module InductiveSchedSet = Set.Make(struct type t = inductive_schedule * derive_sort * bool let compare = compare end)

module InductiveSchedMap = Map.Make(struct type t = inductive_schedule * derive_sort * bool 
  let compare ((ind_name, _,_,_), ds1, opt1) ((ind_name, _,_,_), ds2, opt2) =
    match compare ind_name ind_name with
    | 0 -> (match compare ds1 ds2 with
            | 0 -> compare opt1 opt2
            | r -> r)
    | r -> r end)

let dec_eq_sched_phony = ("DecOpt_eq_III", [], [(([],CheckerSchedule),[])], [(([],CheckerSchedule),[])])
   
let init_density_inductive_memo = RelationInstMap.add (ty_ctr_of_string "Coq.Init.Logic.eq", [], D_Check) (dec_eq_sched_phony, Checking) RelationInstMap.empty

let inductive_set_init = InductiveSchedSet.singleton (dec_eq_sched_phony, D_Check, false)

let inductive_set = ref inductive_set_init

module StringMap = Map.Make(String)

(* let inductive_dependency_map : (string list) StringMap.t ref = ref StringMap.empty *)

let concat_pair_map (f : 'a -> ('b list * 'c list)) (l : 'a list) : ('b list * 'c list) =
  List.fold_left (fun (bs,cs) a -> let (b,c) = f a in (bs @ b, cs @ c)) ([],[]) l

(* let rec collect_all_used_inductives ((ind_schd, ds, opt) : inductive_schedule * derive_sort * bool) : ((inductive_schedule * derive_sort * bool) list) * ((inductive_schedule * derive_sort * bool) list) =
  if InductiveSchedSet.mem (ind_schd, ds, opt) !inductive_set then 
    (Feedback.msg_debug (str ("Already collected inductive schedule: " ^ (match ind_schd with (name,_,_,_) -> name)) ++ fnl ());
    ([],[]))
  else begin
  inductive_set := InductiveSchedSet.add (ind_schd, ds, opt) !inductive_set;
  let (schedule_name, result_vars, nonrecursive_hyps, recursive_hyps) = ind_schd in
  Feedback.msg_notice (str ("Collecting inductive schedule: " ^ schedule_name) ++ fnl ());
  let fill_nonrecursive_dependents = (schedule_name, result_vars, (List.map insert_mutrec_calls nonrecursive_hyps), (List.map insert_mutrec_calls recursive_hyps)) in
  let dependents = List.filter_map (fun dep -> lookup_and_remove_inductive_schedule dep false) (inductive_schedule_dependents ind_schd) in
  let dependents_names = List.map (fun dep -> let ((name,_,_,_),_,_) = dep in name) dependents in
  let deduplicate_dependents = List.sort_uniq compare dependents_names in
  inductive_dependency_map := StringMap.add schedule_name deduplicate_dependents !inductive_dependency_map;
  let (unconstrained_deps, constrained_deps) = concat_pair_map collect_all_used_inductives dependents in
  Feedback.msg_notice (str ("Collected inductive schedule: " ^ schedule_name) ++ fnl ());
  if opt then unconstrained_deps, constrained_deps @ [fill_nonrecursive_dependents, ds, opt]
  else unconstrained_deps @ [fill_nonrecursive_dependents, ds, opt], constrained_deps
  end *)

let parse_ind_schd_name (ind_schd_name : string) : ty_ctr * int list * derive_sort * bool =
  if ind_schd_name = "theorem" then ty_ctr_of_string "theorem", [], D_Thm, true
  else begin

  let parse_class_name (class_name : string) : derive_sort * bool = 
    match class_name with
    | "DecOpt" -> D_Check, true
    | "GenSized" -> D_Gen, false
    | "GenSizedSuchThat" -> D_Gen, true
    | "EnumSized" -> D_Enum, false
    | "EnumSizedSuchThat" -> D_Enum, true
    | _ -> failwith "parse_ind_schd_name: invalid class_name" 
  in

  let parse_mode (mode : string) : int list =
    filter_mapi (fun i c -> if c = 'O' then Some i else if c = 'I' then None else failwith ("Incorrect character in mode: " ^ mode)) (List.of_seq @@ String.to_seq mode) 
  in

  let parts = String.split_on_char '_' ind_schd_name in
  if List.length parts < 3 then failwith ("parse_ind_schd_name: invalid format" ^ ind_schd_name);

  let grab_first_middle_and_last xs = 
    match xs with
    | first :: xs' ->
      let rec aux acc = function
        | [last] -> (List.rev acc, last)
        | x :: xs'' -> aux (x :: acc) xs''
        | _ -> failwith "grab_first_middle_and_last: not enough elements" in
      let (middle, last) = aux [] xs' in
      first, middle, last
    | _ -> failwith "grab_first_middle_and_last: not enough elements" in   

  let class_name, ind_name_segments, mode = grab_first_middle_and_last parts in

  let ind_name = ty_ctr_of_string (String.concat "_" ind_name_segments) in

  let ds, opt = parse_class_name class_name in

  ind_name, parse_mode mode, ds, opt
  end

let construct_ind_schd_name ((ind_name, argc, ois, ds, opt) : ty_ctr * int * int list * derive_sort * bool) : string =
  let class_name = match ds with
    | D_Check -> "DecOpt"
    | D_Gen -> if opt then "GenSizedSuchThat" else "GenSized"
    | D_Enum -> if opt then "EnumSizedSuchThat" else "EnumSized"
    | D_Thm -> "Theorem" in
  let mode = String.init argc (fun i -> if List.mem i ois then 'O' else 'I') in
  Printf.sprintf "%s_%s_%s" class_name (ty_ctr_to_string ind_name) mode

let collect_all_used_inductive_schd_names ind_schd_name : string list * (((inductive_schedule * derive_sort * bool) * string list) StringMap.t ref)  = 
  let inductive_dependency_map : ((inductive_schedule * derive_sort * bool) * string list) StringMap.t ref = ref StringMap.empty in
  let rec collect_all_used_inductive_schd_names' (ind_schd_name : string) : string list =
    Error.msg_debug (str ("Collecting inductive schedule: " ^ ind_schd_name) ++ fnl ());
    let parse_dependent (rocq, output_idxs, ds, opt) =
      match rocq with
      | DTyCtr (ind_name, args) -> ind_name, List.length args, output_idxs, ds, opt
      | DNot (DTyCtr (ind_name, args)) -> ind_name, List.length args, output_idxs, ds, opt
      | DTyParam v -> 
        failwith "collect_all_used_inductive_schd_names: Need to handle instances of parameter type variables, like A in list A"
      | _ -> failwith "collect_all_used_inductive_schd_names: not a DTyCtr" in

    match StringMap.find_opt ind_schd_name !inductive_dependency_map with
    | Some _ -> []
    | None -> begin
      Error.msg_debug (str ("Collecting inductive schedule: " ^ ind_schd_name) ++ fnl ());
      let (ind_name, ois, ds, opt) = parse_ind_schd_name ind_schd_name in
      (match lookup_and_remove_inductive_schedule (DTyCtr (ind_name,[]), ois, ds, opt) false with
      | None -> Error.msg_debug (str ("collect_all_used_inductive_schd_names: Could not find inductive schedule in density_inductive_memo: " ^ ind_schd_name)); []
      | Some (ind_schd, ds, opt) ->
        let dependents = List.map parse_dependent @@ inductive_schedule_dependents ind_schd in
        let deduplicate_dependents = List.sort_uniq compare dependents in

        let dependents_names = List.map construct_ind_schd_name deduplicate_dependents in

        Error.msg_debug (str ("Dependent's names: " ^ String.concat ", " dependents_names) ++ fnl ());

        let replace_nonrecursives = insert_mutrec_calls_inductive_schedule ind_schd in

        inductive_dependency_map := StringMap.add ind_schd_name ((replace_nonrecursives, ds, opt), dependents_names) !inductive_dependency_map;

        ind_schd_name :: dependents_names @ List.concat_map collect_all_used_inductive_schd_names' dependents_names)
    end in

  (List.sort_uniq compare @@ collect_all_used_inductive_schd_names' ind_schd_name), inductive_dependency_map
(* 
let collect_all_used_inductives_theorem (thm_schd : schedule) : ((inductive_schedule * derive_sort * bool) list) * ((inductive_schedule * derive_sort * bool) list) = 
  let (thm_instantiated,_) = insert_mutrec_calls (thm_schd,[]) in
  let dependents = List.filter_map (fun dep -> lookup_and_remove_inductive_schedule dep false) (schedule_dependents thm_schd) in
  let (unconstrained_deps, constrained_deps) = concat_pair_map collect_all_used_inductives dependents in
  let theorem_ind_schd = (("theorem", [], [thm_instantiated,[]],[]), D_Thm, true) in
  inductive_dependency_map := StringMap.add "theorem" dependents !inductive_dependency_map;
  unconstrained_deps, constrained_deps @ [theorem_ind_schd] *)
(* 
let collect_all_used_inductives_schd_names_theorem (thm_schd : schedule) : string list * (((inductive_schedule * derive_sort * bool) * string list) StringMap.t ref) =
  let parse_dependent (rocq, output_idxs, ds, opt) =
    match rocq with
    | DTyCtr (ind_name, _) -> ind_name, output_idxs, ds, opt
    | DTyVar v -> failwith "collect_all_used_inductives: Need to handle instances of parameter type variables, like A in list A"
    | _ -> failwith "collect_all_used_inductives: not a DTyCtr" in
  let (thm_instantiated,_) = insert_mutrec_calls (thm_schd,[]) in
  let dependents = List.map parse_dependent @@ schedule_dependents thm_schd in

  let deduplicate_dependents = List.sort_uniq compare dependents in

  let dependents_names = List.map construct_ind_schd_name deduplicate_dependents in

  let theorem_ind_schd = (("theorem", [], [thm_instantiated,[]],[]), D_Thm, true) in

  let  *)






module StringSet = Set.Make(String)

(* let topological_sort_schedules_by_name (schedules : (inductive_schedule * derive_sort * bool) list) : (inductive_schedule * derive_sort * bool) list =
  let top_sort (schedules : (inductive_schedule * derive_sort * bool) list) (sorted : (inductive_schedule * derive_sort * bool) list ref) : (inductive_schedule * derive_sort * bool) list =
    let seen_scheds : StringSet.t ref = ref StringSet.empty in

    let rec dfs (schedule : inductive_schedule * derive_sort * bool) : unit =
      let ((schedule_name, _, _, _),_,_) = schedule in
      if not (StringSet.mem schedule_name !seen_scheds) then
        begin
          seen_scheds := StringSet.add schedule_name !seen_scheds;
          let dependents = StringMap.find schedule_name !inductive_dependency_map in
          List.iter dfs dependents;
          sorted := schedule :: !sorted
        end in

    List.iter dfs schedules;
    !sorted in
  
  top_sort schedules (ref []) *)

  (* let schedules_to_graph (schedules : (inductive_schedule * derive_sort * bool) list) : (int * int list) list =
    List.mapi (fun i dep -> 
      let dependents = InductiveSchedMap.find dep !inductive_dependency_map in
      let dep_indices = List.map (fun dep' -> List.find_index (fun dep'' -> dep'' = dep') schedules) dependents in
      i, dep_indices) schedules in
  
  let graph = schedules_to_graph schedules in *)

let rec take_while (p : 'a -> bool) (l : 'a list) : ('a list) * ('a list) =
  match l with
  | a :: l' when p a -> 
    let (start,rest) = take_while p l' in
    (a :: start, rest)
  | _ -> ([], l)

let tarjan_schedules_by_name (schedules : string list) inductive_dependency_map
    : (inductive_schedule * derive_sort * bool) list list =
  let index = ref 0 in
  let stack = ref [] in
  let components = ref [] in
  let dep_count = List.length schedules in
  let in_stack = Array.make dep_count false in
  let vertex_indices = ref (StringMap.add "DecOpt_Coq.Init.Logic.eq_III" (~-0) 
                            (StringMap.singleton "DecOpt_eq_III" ~-0)) in
  let vertex_lowlinks = ref StringMap.empty in

  let rec strong_connect (v_name : string) =
    (* Assign discovery index and lowlink for v *)
    if StringMap.mem v_name !vertex_indices then () else begin 
    Error.msg_debug (str "Strong connecting " ++ str v_name ++ fnl ());
    vertex_indices := StringMap.add v_name !index !vertex_indices;
    vertex_lowlinks := StringMap.add v_name !index !vertex_lowlinks;
    in_stack.(!index) <- true;
    (* Feedback.msg_notice (str ("Pushing " ^ v_name) ++ fnl ()); *)
    let (v, dependent_names) = try StringMap.find v_name !inductive_dependency_map with Not_found -> failwith ("strong_connect: Could not find " ^ v_name) in
    stack := v :: !stack;
    index := !index + 1;


    (* Process each dependent of v *)
    Error.msg_debug (str ("Processing " ^ (let ((vn,_,_,_),_,_) = v in vn) ^ " with dependents: " ^ String.concat ", " dependent_names) ++ fnl ());
    List.iter (fun w_name ->
      if not (StringMap.mem w_name !vertex_indices) then (
        strong_connect w_name;
        let low_v = StringMap.find v_name !vertex_lowlinks in
        let low_w = StringMap.find w_name !vertex_lowlinks in
        vertex_lowlinks := StringMap.add v_name (min low_v low_w) !vertex_lowlinks
      )
      else if in_stack.(StringMap.find w_name !vertex_indices) then (
        let low_v = StringMap.find v_name !vertex_lowlinks in
        let idx_w = StringMap.find w_name !vertex_indices in
        vertex_lowlinks := StringMap.add v_name (min low_v idx_w) !vertex_lowlinks
      )
    ) dependent_names;

    (* If v is a root node, pop the stack to form an SCC *)
    if StringMap.find v_name !vertex_lowlinks = StringMap.find v_name !vertex_indices then (
      let rec pop_until acc =
        match !stack with
        | [] -> failwith "strong_connect: stack should not be empty"
        | w :: rest ->
            let w_name = let ((name,_,_,_),_,_) = w in name in
            Error.msg_debug (str ("Popping " ^ w_name) ++ fnl ());
            stack := rest;
            (* Feedback.msg_notice (str ("Popping " ^ w_name) ++ fnl ()); *)
            in_stack.(StringMap.find w_name !vertex_indices) <- false;
            (* Feedback.msg_notice (str ("Adding " ^ w_name ^ " to component") ++ fnl ()); *)
            let acc' = w :: acc in
            if w_name = v_name then acc'
            else pop_until acc'
      in
      let component = pop_until [] in
      Error.msg_debug (str ("Adding component: " ^ String.concat ", " (List.map (fun ((name,_,_,_),_,_) -> name) component)) ++ fnl ());
      components := component :: !components
    )
    end
  in

  List.iter strong_connect schedules;
  let component_sizes = List.map List.length !components in
  msg_debug (str "Component sizes: " ++ str (String.concat ", " (List.map string_of_int component_sizes)) ++ fnl ());
  List.rev !components

let valid_schedules =
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        density_memo := RelationInstMap.empty;
        let schedules = NewUnifyQC.type_to_schedules dt None None [] [] D_Thm false in
        let schedules' = List.map (fun ((steps, sort), ms, eqs) -> (List.map (fun (v,p) -> S_Match (v,p)) ms, (List.map check_eq eqs @ steps, sort))) schedules in
        Feedback.msg_notice (str "Printing all bindings" ++ fnl ());


        let schedules_w_densities = List.mapi (fun i (ms_steps, schd) -> i, schedule_density ms_steps schd) schedules' in
        let sorted = sort_schedules_by_density_and_var_uses schedules_w_densities D_Thm in


        List.iter (fun ((steps_ds, sort), density, num_var_uses, id) ->
          Feedback.msg_notice (str (string_of_int id ^ ":\n" ) ++ fnl ());
          Feedback.msg_notice (str ("# var uses: " ^ string_of_int num_var_uses ^ "density:" ^ density_to_string density ^ "\n") ++
                              str (schedule_with_densities_to_string (steps_ds, sort) ^ "\n") ++                                           
                              str "\nconstrexpr: \n" ++ 
                              NewUnifyQC.match_schedule_as_pp_constr_expr (List.map fst steps_ds, sort) [] [] D_Thm
                                                          ++ str "\n==============================================\n")) sorted;
        Tacticals.tclIDTAC
      end 
    | None -> failwith "Failed to Parse type"
  end

let theorem_dependencies = 
  Proofview.Goal.enter begin fun gl ->
    
    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in

    match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
        let open NewGenericLib in
        let rec printlist : (var * (int * int list list) list) list -> unit = function
          | [] -> ()
          | (var, rels) :: rest ->
            let path_to_string (is : int list) = "[" ^ String.concat ", " (List.map string_of_int is) ^ "]" in
            let paths_to_string (iss : int list list) = "{" ^ String.concat "; " (List.map path_to_string iss) ^ "}" in
            let tuple_to_string ((i : int), (j : int list list)) = "(" ^ string_of_int i ^ ", " ^ paths_to_string j ^ ")" in
            msg_debug (str (var_to_string var) ++ str " : " ++ str (String.concat ", " (List.map (fun (i, j) -> (tuple_to_string (i, j))) rels)) ++ fnl ()); 
            printlist rest in
        
        printlist (NewGenericLib.rocq_constr_var_relation_uses' dt);          
        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end

  let schedules =
    Proofview.Goal.enter begin fun gl ->
    
      (* Convert goal to a constr_expr *)
      let c = Proofview.Goal.concl gl in
      let e = Proofview.Goal.env gl in
      let evd = Evd.from_env e in
  
      match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
      | Some dt ->
        begin
          density_memo := RelationInstMap.empty;
          msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
          let scheds = (NewUnifyQC.type_to_schedules dt None None [] [] D_Thm false) in

          List.iteri (fun i (sch,ms,eqs) -> Feedback.msg_notice (str (string_of_int i) 
                                                          ++ str ":\n" 
                                                          ++ str (NewUnifyQC.match_schedule_to_string sch ms eqs) 
                                                          ++ str "\nconstrexpr: \n"
                                                          ++ (NewUnifyQC.match_schedule_as_pp_constr_expr sch ms eqs D_Thm)
                                                          ++ str "\n\n===================\n" 
                                                          ++ fnl ())) scheds;
          
          Tacticals.tclIDTAC
        end
      | None -> failwith "Failed to Parse type"
    end

module VarSet = Set.Make(struct type t = var let compare = compare end)
  
let defined_set = ref VarSet.empty

let define c name env evd =
  if VarSet.mem name !defined_set then
    Feedback.msg_notice (str (var_to_string name ^ " is already defined") ++ fnl ())
  else if name = var_of_string "theorem" then begin
    let fresh_thm_name = fresh_name "theorem" in
    let (c_constr, univ_info) = (Constrintern.interp_constr env evd c) in
    let univ_entry = UState.univ_entry ~poly:false univ_info in
    let constr = (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr) in

    let cinfo = Declare.CInfo.make ~name:fresh_thm_name ~typ:None () in
    let info = Declare.Info.make ~poly:false () in
    ignore (Declare.declare_definition ~info ~cinfo ~opaque:false ~body:c_constr evd)
  end else
    begin
    defined_set := VarSet.add name !defined_set;
  (* let fn = fresh_name ind_schd_name in *)
  (* TODO: Maxime - which of the new internal flags should be used here? The names aren't as clear :) *)
    let (c_constr, univ_info) = (Constrintern.interp_constr env evd c) in
    let univ_entry = UState.univ_entry ~poly:false univ_info in
    let constr = (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr) in

    let cinfo = Declare.CInfo.make ~name:name ~typ:None () in
    let info = Declare.Info.make ~poly:false () in
    ignore (Declare.declare_definition ~info ~cinfo ~opaque:false ~body:c_constr evd)
  end 

let define_all schedule_pieces =
  List.iter (function
  | [] -> failwith "Empty piece"
  | [(name, constr)] -> 
    let e' = Global.env () in
    let evd' = Evd.from_env e' in
    Feedback.msg_notice (str ("Defining " ^ var_to_string name) ++ fnl ());
    Feedback.msg_notice (str ("Defining " ^ constr_expr_to_string constr) ++ fnl ());
    ignore (define constr name e' evd')
  | pieces -> 
    let e' = Global.env () in
    let evd' = Evd.from_env e' in
    List.iter (fun (name, constr) -> 
      Feedback.msg_notice (str ("Defining " ^ var_to_string name) ++ fnl ());
      Feedback.msg_notice (str ("Defining " ^ constr_expr_to_string constr) ++ fnl ());
      ignore (define constr name e' evd')) pieces
        ) schedule_pieces

let quickchick_it =
  Proofview.Goal.enter_one begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    
    match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
        let open NewGenericLib in 
        density_inductive_memo := init_density_inductive_memo;
        inductive_set := inductive_set_init;
        rocq_relation_memo := TyCtrMap.empty;
        (* inductive_dependency_map := StringMap.empty; *)
        (* msg_debug (str "Validating that all arguments to inductives are fully generalised" ++ fnl ()); *)
        (* if not (fully_generalised dt) then (msg_debug (str "Not fully generalised" ++ fnl ()); Tacticals.tclIDTAC) else begin *)
        Error.msg_debug (str "Checking for generators" ++ fnl ());
        let e' = Global.env () in

        let theorem_schedule = best_theorem_schedule dt in
        Feedback.msg_notice (str "Theorem Schedule:\n" ++ str (schedule_to_string theorem_schedule) ++ fnl ());

        (* Register theorem as a phony inductive schedule *)
        let phony_theorem_ind_schd = ("theorem", [], [theorem_schedule,[]],[]) in
        density_inductive_memo := RelationInstMap.add (ty_ctr_of_string "theorem", [], D_Thm) (phony_theorem_ind_schd, Checking) !density_inductive_memo;

        density_inductive_memo := RelationInstMap.remove (ty_ctr_of_string "eq", [], D_Check) !density_inductive_memo;
        (* let (unconstrained_inductives, mut_used_inductives) = collect_all_used_inductives_theorem theorem_schedule in *)
        let dependents, inductive_dependency_map = collect_all_used_inductive_schd_names "theorem" in
        Error.msg_debug (str "Dependents: " ++ str (String.concat ", " dependents) ++ fnl ());
        let components = tarjan_schedules_by_name dependents inductive_dependency_map in
        (* let sorted_unconstrained = topological_sort_schedules_by_name unconstrained_inductives in *)
        (* Capture dependencies
        let dependency_chain = get_inductive_dependencies inductive_schedule in
        let (ischd_name, _,_,_) = inductive_schedule
        let mutual_fixpoint = mutfix ischd_name (flatten dependency_chain) *)
        (* List.iter (fun (ind, ds, opt) -> Feedback.msg_notice (str "Unconstrained Inductive Schedule:\n" ++ str (inductive_schedule_to_string ind) ++ fnl ())) sorted_unconstrained; *)
        (* List.iter (fun (ind, ds, opt) -> Feedback.msg_notice (str "Used Inductive Schedule:\n" ++ str (inductive_schedule_to_string ind) ++ fnl ())) mut_used_inductives; *)
  
        let ind_schd_name = "theorem" in
  
        (* let mutrec_constr_expr = inductive_schedule_with_dependencies_to_constr_expr sorted_unconstrained mut_used_inductives ind_schd_name in *)
        (* let schedules_constr = inductive_schedules_to_constr_expr components ind_schd_name in *)
        Error.msg_debug (str ("Components: " ^ string_of_int (List.length components)) ++ fnl ());
        let schedules_pieces = inductive_schedules_to_def_constr_exprs components ind_schd_name in
  
        (* print mutrec_constr_expr*)
        (* msg_debug (str "Generator: " ++ fnl ()); *)
        (* msg_debug (int (List.length components) ++ str " components" ++ fnl ()); *)
        (* msg_debug (str (constr_expr_to_string schedules_constr) ++ fnl ()); *)

        Feedback.msg_notice (str "Pieces: " ++ fnl ());
        List.iter (List.iter (fun (name, constr) -> msg_debug (str (var_to_string name ^ ": ") ++ str (constr_expr_to_string constr) ++ fnl ()))) schedules_pieces;



        (* let is_defined s : bool =
          begin
            begin
              try match Nametab.locate_extended_all (Libnames.qualid_of_ident s) with
                  | [] -> false
                  | _ -> true
              with Not_found -> false (* failwith ("locate constant: " ^ (Id.to_string c))*)
            (* end
          end
        in *)

        List.iter (function
          | [] -> failwith "Empty piece"
          | [(name, constr)] -> 
            let e' = Global.env () in
            let evd' = Evd.from_env e' in
            ignore (define constr name e' evd')
          | pieces -> 
            let e' = Global.env () in
            let evd' = Evd.from_env e' in
            List.iter (fun (name, constr) -> 
              if is_defined name then
                Feedback.msg_notice (str (var_to_string name ^ " is already defined") ++ fnl ())
              else
              ignore (define constr name e' evd')) pieces) schedules_pieces; *)

        define_all schedules_pieces;

            (* let (names, constrs) = List.split pieces in ignore (mut_define names constrs e' evd')) schedules_pieces; *)

        Feedback.msg_notice (int (List.length schedules_pieces) ++ str " Pieces defined" ++ fnl ());


        defined_set := VarSet.empty;  

        (* let env = Global.env () in
        let evd = Evd.from_env env in *)
        (* ignore (declare_constant (var_of_string ind_schd_name) ) *)

        (* let constr_expr = inductive_schedule_to_constr_expr inductive_schedule ds opt in *)
        (* Feedback.msg_notice (str "Inductive Schedule ConstrExpr:\n" ++ str (NewGenericLib.constr_expr_to_string schedules_constr) ++ fnl ()); *)
        Feedback.msg_notice (str "We shouldn't have a constant");
        (* ignore (define schedules_constr e evd); *)

        

        (* msg_debug (str "After constrained generator" ++ fnl ());*)
        let updated_env = Global.env () in
        let updated_evd = Evd.from_env updated_env in
        msg_debug (str "Running QuickCheck" ++ fnl ());
        let to_run = fst (Constrintern.interp_constr updated_env updated_evd (c_show (c_quickCheck (c_sized c_theorem)))) in
        let updated_env' = Global.env () in
        let updated_evd' = Evd.from_env updated_env' in
        #if COQ_VERSION >= (8, 20, 0)
          (* FRAGILE probably won't be allowed in the future? *)
          let opaque_access = Library.indirect_accessor[@@warning "-3"] in
          QuickChick.define_and_run ~opaque_access to_run updated_env' updated_evd';
  #else
          QuickChick.define_and_run to_run updated_env' updated_evd';
  #endif
        (* let _ = (QuickChick.define_and_run  to_run updated_env' updated_evd') in *)
        Tacticals.tclIDTAC
        (* end  *)
      end
    | None -> failwith "Failed to Parse type"
  end


 
}
TACTIC EXTEND quickchick
  | ["quickchick"] -> { quickchick_it }
END

TACTIC EXTEND schedules 
  | ["schedules"] -> { schedules }
END

TACTIC EXTEND theorem_dependencies
  | ["theorem_dependencies"] -> { theorem_dependencies }
END

TACTIC EXTEND valid_schedules
  | ["valid_schedules"] -> { valid_schedules }
END

VERNAC COMMAND EXTEND Print CLASSIFIED AS SIDEFF
 | ["Print" "Typeclasses" "for" ident(ind)] ->
    { let ind' = Libnames.qualid_of_ident ind in 
      ignore (NewGenericLib.find_typeclass_bindings ind') }
END

(*type rocq_relation
  = ty_ctr        (* The name of the relation (e.g. IsSorted) *)
  * ty_param list (* The list of type parameters (e.g. "t" in IsSorted) *)
  * rocq_ctr list (* A list of constructors. Each constructor is a pair (name, type) *)
  * rocq_constr   (* The type of the overall relation (e.g. "list t -> Prop") *)*)

VERNAC COMMAND EXTEND DeriveSchedules CLASSIFIED AS SIDEFF
   | ["Derive" "Schedules" constr(ind) int_list(ois) "consnum" int(ctr_idx) "derive" string(ds)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) -> 
      let open NewGenericLib in
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in

      (* Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params)) 
                        ++ str "\n Result Type: "
                        ++ str (rocq_constr_to_string result_typ) 
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois)) 
                        ++ str ("\n Derive Sort: " ^ ds) 
                        ++ str "\n\n"); *)
      let ds_string = ds in 
      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Thm" -> D_Thm
      | "Enum" -> D_Enum
      | _ -> failwith ("Invalid derive sort " ^ ds)) in


      let rec get_result_vars = function
      | DProd ((v,t), b) ->
        let v = make_up_name_str ("v_" ^ var_to_string v) in
        (v,t) :: get_result_vars b
      | DArrow (t1, t2) ->
        let v = make_up_name_str "v" in
        (v,t1) :: get_result_vars t2
      | _ -> [] in

      let result_vars = List.map (fun p -> (p, DHole)) params @ get_result_vars result_typ in

      let rec remake_result vars result = 
        match vars, result with
        | [], _ -> result
        | (v,t) :: rest, DProd  (_, t') 
        | (v,t) :: rest, DArrow (_, t') -> DProd ((v,t), remake_result rest t')
        | _ -> failwith "remake_result failed" in

      let (ctr, constructor) = List.nth constructors ctr_idx in

      let output_vars = List.map fst (List.filteri (fun i _ -> List.mem i ois) result_vars) in

      let scheds = NewUnifyQC.type_to_schedules constructor (Some ind_name) (Some ctr) result_vars output_vars ds true in
      
      let rec take n l =
        if n <= 0 then [] else
        match l with
        | [] -> []
        | x :: xs -> x :: take (n - 1) xs in

      let rec drop n l =
        if n <= 0 then l else
        match l with
        | [] -> []
        | x :: xs -> drop (n - 1) xs in

      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name) 
                        ++ str "\n Constructor Name: " 
                        ++ str (ty_ctr_to_string ctr)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params))
                        ++ str "\n Constructor Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string constructor)
                        ++ str "\n Result Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string (remake_result (drop (List.length params) result_vars) result_typ))
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois)) 
                        ++ str ("\n Derive Sort: " ^ ds_string) 
                        ++ str "\n\n");

      List.iteri (fun i (sch,ms,eqs) -> Feedback.msg_notice (str (string_of_int i) 
                                                          ++ str ":\n" 
                                                          ++ str (NewUnifyQC.match_schedule_to_string sch ms eqs) 
                                                          ++ str "\nconstrexpr: \n"
                                                          ++ (NewUnifyQC.match_schedule_as_pp_constr_expr sch ms eqs ds)
                                                          ++ str "\n\n===================\n" 
                                                          ++ fnl ())) (take 300 scheds) 
    | None -> failwith "Failed to parse inductive type" 
    }
END

VERNAC COMMAND EXTEND DeriveValidSchedules CLASSIFIED AS SIDEFF
   | ["Derive" "Valid" "Schedules" constr(ind) int_list(ois) "consnum" int(ctr_idx) "derive" string(ds)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) -> 
      let open NewGenericLib in
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in
      density_inductive_memo := init_density_inductive_memo;
      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params)) 
                        ++ str "\n Result Type: "
                        ++ str (rocq_constr_to_string result_typ) 
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois))
                        ++ str ("\n Derive Sort: " ^ ds) 
                        ++ str "\n\n");

      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Thm" -> D_Thm
      | "Enum" -> D_Enum
      | _ -> failwith ("Invalid derive sort " ^ ds)) in

      let rec get_result_vars = function
      | DProd ((v,t), b) ->
        let v = make_up_name_str ("v_" ^ var_to_string v) in
        (v,t) :: get_result_vars b
      | DArrow (t1, t2) ->
        let v = make_up_name_str "v" in
        (v,t1) :: get_result_vars t2
      | _ -> [] in

      let result_vars = List.map (fun v -> (v,DHole)) params @ get_result_vars result_typ in

      let rec remake_result vars result = 
        match vars, result with
        | [], _ -> result
        | (v,t) :: rest, DProd  (_, t') 
        | (v,t) :: rest, DArrow (_, t') -> DProd ((v,t), remake_result rest t')
        | _ -> failwith ("remake_result failed on: " ^ rocq_constr_to_string result) in

      let (ctr, constructor) = List.nth constructors ctr_idx in

      let output_vars = List.map fst (List.filteri (fun i _ -> List.mem i ois) result_vars) in

      let scheds = NewUnifyQC.type_to_schedules constructor (Some ind_name) (Some ctr) result_vars output_vars ds true in

      let rec take n l =
        if n <= 0 then [] else
        match l with
        | [] -> []
        | x :: xs -> x :: take (n - 1) xs in

      let rec drop n l =
        if n <= 0 then l else
        match l with
        | [] -> []
        | x :: xs -> drop (n - 1) xs in

      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name) 
                        ++ str "\n Constructor Name: " 
                        ++ str (ty_ctr_to_string ctr)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params))
                        ++ str "\n Constructor Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string constructor)
                        ++ str "\n Result Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string (remake_result (drop (List.length params) result_vars) result_typ))
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois)) 
                        ++ str "\n\n");

      density_memo := RelationInstMap.empty;
      let schedules = take 300 scheds in
      let schedules' = List.map (fun ((steps, sort), ms, eqs) -> (List.map (fun (v,p) -> S_Match (v,p)) ms, (List.map check_eq eqs @ steps, sort))) schedules in
      Feedback.msg_notice (str "Printing all bindings" ++ fnl ());
      let schedules_w_densities = List.mapi (fun i (ms_steps, schd) -> i, schedule_density ms_steps schd) schedules' in
      let sorted = sort_schedules_by_density_and_var_uses schedules_w_densities ds in

      List.iter (fun ((steps_ds, sort), density, num_var_uses, id) ->

        Feedback.msg_notice (str (string_of_int id ^ ":\n" ) ++ fnl ());
        Feedback.msg_notice (str ("# var uses: " ^ string_of_int num_var_uses ^ "density:" ^ density_to_string density ^ "\n") ++
                            str (schedule_with_densities_to_string (steps_ds, sort) ^ "\n") ++                                           
                            str "\nconstrexpr: \n" ++ 
                            NewUnifyQC.match_schedule_as_pp_constr_expr (List.map fst steps_ds, sort) [] [] ds
                                                        ++ str "\n==============================================\n")) sorted

    | None -> failwith "Failed to parse inductive type" 
    }
END

      

VERNAC COMMAND EXTEND DeriveUsedInds CLASSIFIED AS SIDEFF
   | ["Derive" "Used" "Inds" constr(ind)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) ->
        let (ind_name, params, constructors, result_typ) = List.nth rs idx in
        (match get_inductive_name ind_name with
        | Some i -> print_type_names (List.map (fun (n,_,_,_) -> n) (seek_rocq_relations i))
        | None -> failwith "Failed to get inductive name")
    | None -> failwith "Failed to parse inductive type"  
    }
END

VERNAC COMMAND EXTEND DeriveDensity CLASSIFIED AS SIDEFF
   | ["Derive" "Density" constr(ind) int_list(ois) "derive" string(ds)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) ->
      (* density_memo := RelationInstMap.empty;
      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Thm" -> D_Thm
      | "Enum" -> D_Enum) in
      ignore (final_density (List.nth rs idx) ois true ds) *)
      density_inductive_memo := init_density_inductive_memo;
      inductive_set := inductive_set_init;
      rocq_relation_memo := TyCtrMap.empty;
      (* inductive_dependency_map := StringMap.empty; *)
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in
      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Enum" -> D_Enum
      | _ -> failwith "Can only derive inductive schedules for Check, Gen, or Enum") in
      let (inductive_schedule, density) = inductive_best_valid_schedule (ind_name, params, constructors, result_typ) ois ds true in
      (* Feedback.msg_notice (str "Inductive Schedule:\n" ++ str (inductive_schedule_to_string inductive_schedule) ++ fnl ()); *)
      Feedback.msg_notice (str "Density: " ++ str (density_to_string density) ++ fnl ())

    | None -> failwith "Failed to parse inductive type" 
    }
END

VERNAC COMMAND EXTEND DeriveInductiveSchedule CLASSIFIED AS SIDEFF
   | ["Derive" "Inductive" "Schedule" constr(ind) int_list(ois) "derive" string(ds) "opt" string(opt)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) ->
      density_inductive_memo := init_density_inductive_memo;
      inductive_set := inductive_set_init;
      rocq_relation_memo := TyCtrMap.empty;
      (* inductive_dependency_map := StringMap.empty; *)
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in
      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Enum" -> D_Enum
      | _ -> failwith "Can only derive inductive schedules for Check, Gen, or Enum") in
      let opt = (match opt with
      | "true" -> true
      | "false" -> false
      | _ -> failwith "Opt must be true or false") in
      msg_debug (str "LOOOK HERE Deriving inductive schedule for " ++ str (ty_ctr_to_string ind_name) ++ fnl ());
      let (inductive_schedule, density) = inductive_best_valid_schedule (ind_name, params, constructors, result_typ) ois ds opt in
      Feedback.msg_notice (str "Inductive Schedule:\n" ++ str (inductive_schedule_to_string inductive_schedule) ++ fnl ());
      msg_debug (str "LOOOK HERE Density: " ++ str (density_to_string density) ++ fnl ());
      density_inductive_memo := RelationInstMap.remove (ty_ctr_of_string "eq", [], D_Check) !density_inductive_memo;

      let ind_schd_name = match inductive_schedule with (n,_,_,_) -> n in
      let dependents, inductive_dependency_map = collect_all_used_inductive_schd_names ind_schd_name in

      let components = tarjan_schedules_by_name dependents inductive_dependency_map in

      let schedules_pieces = inductive_schedules_to_def_constr_exprs components ind_schd_name in

      (* let define c name env evd =
        let (c_constr, univ_info) = (Constrintern.interp_constr env evd c) in
        let univ_entry = UState.univ_entry ~poly:false univ_info in
        let constr = (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr) in

        let cinfo = Declare.CInfo.make ~name:name ~typ:None () in
        let info = Declare.Info.make ~poly:false () in
        Declare.declare_definition ~info ~cinfo ~opaque:false ~body:c_constr evd 
      in

      let mut_define (names : var list) cs env evd =
        let uctx = UState.from_env env in
        let (c_constrs, typs) = List.split (List.map (fun c -> 
          let c_econstr = fst (Constrintern.interp_constr env evd c) in
          let constr = (EConstr.to_constr ~abort_on_undefined_evars:false evd c_econstr) in
          let typ = Retyping.get_type_of_constr env ~uctx constr in
          (constr, typ)
          ) cs) in

        let info = Declare.Info.make ~poly:false () in
        let cinfo = List.map2 (fun n ty -> Declare.CInfo.make ~name:n ~typ:ty ()) names typs in

        let bodies = List.split (List.map (fun c -> (c, Sorts.Relevant)) c_constrs) in

        let possible_guard = {Pretyping.possibly_cofix=false;Pretyping.possible_fix_indices = []} in

        Declare.declare_mutual_definitions ~info ~cinfo ~opaque:false ~uctx ~bodies ~possible_guard ()

      in

      let is_defined s : bool =
        begin
          begin
            try match Nametab.locate_extended_all (Libnames.qualid_of_ident s) with
                | [] -> false
                | _ -> Feedback.msg_debug (str "HEY!"); true 
            with Not_found -> false 
          end
        end
      in

      List.iter (function
        | [] -> failwith "Empty piece"
        | [(name, constr)] -> 
          let e' = Global.env () in
          let evd' = Evd.from_env e' in
          ignore (define constr name e' evd')
        | pieces -> 
          let e' = Global.env () in
          let evd' = Evd.from_env e' in
          List.iter (fun (name, constr) -> 
            if is_defined name then
              Feedback.msg_notice (str (var_to_string name ^ " is already defined") ++ fnl ())
            else
            ignore (define constr name e' evd')) pieces) schedules_pieces; *)

      define_all schedules_pieces;
          (* let (names, constrs) = List.split pieces in ignore (mut_define names constrs e' evd')) schedules_pieces; *)

      Feedback.msg_notice (int (List.length schedules_pieces) ++ str " Pieces defined" ++ fnl ())




      (* Capture dependencies
      let dependency_chain = get_inductive_dependencies inductive_schedule in
      let (ischd_name, _,_,_) = inductive_schedule
      let mutual_fixpoint = mutfix ischd_name (flatten dependency_chain) *)
      (* List.iter (fun (ind, ds, opt) -> Feedback.msg_notice (str "Unconstrained Inductive Schedule:\n" ++ str (inductive_schedule_to_string ind) ++ fnl ())) sorted_unconstrained;
      List.iter (fun (ind, ds, opt) -> Feedback.msg_notice (str "Used Inductive Schedule:\n" ++ str (inductive_schedule_to_string ind) ++ fnl ())) mut_used_inductives; *)

      (* let mutrec_constr_expr = inductive_schedule_with_dependencies_to_constr_expr sorted_unconstrained mut_used_inductives ind_schd_name in

      let define c env evd =
        let fn = fresh_name ind_schd_name in
        (* TODO: Maxime - which of the new internal flags should be used here? The names aren't as clear :) *)
        let (c_constr, univ_info) = (Constrintern.interp_constr env evd c) in
        let univ_entry = UState.univ_entry ~poly:false univ_info in
        let constr = (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr) in

        let cinfo = Declare.CInfo.make ~name:fn ~typ:None () in
        let info = Declare.Info.make ~poly:false () in
        Declare.declare_definition ~info ~cinfo ~opaque:false ~body:c_constr evd

         (* Declare.declare_definition ~kind:Decls.(IsDefinition Definition) fn (constr,univ_entry) *)


        (*val declare_definition : info:Info.t -> cinfo:EConstr.t option CInfo.t -> opaque:bool -> body:EConstr.t -> ?using:Vernacexpr.section_subset_expr -> Evd.evar_map -> Names.GlobRef.t
Declares a non-interactive constant; body and types will be normalized w.r.t. the passed evar_map sigma. Universes should be handled properly, including minimization and restriction. Note that sigma is checked for unresolved evars, thus you should be careful not to submit open terms

val declare_mutual_definitions : info:Info.t -> cinfo:Constr.t CInfo.t list -> opaque:bool -> uctx:UState.t -> bodies:(Constr.t list * Sorts.relevance list) -> possible_guard:Pretyping.possible_guard -> ?using:Vernacexpr.section_subset_expr -> unit -> Names.GlobRef.t list
Declaration of interactive constan*)

        (* let _ : Names.Constant.t = Declare.declare_constant ~name:fn ~kind:Decls.(IsDefinition Definition)
            (DefinitionEntry (Declare.definition_entry (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr))) in
        fn *)
      in
      (*TODO: MAKE SURE THESE ARE CORRECT ENV + EVD*)
      let env = Global.env () in
      let evd = Evd.from_env env in
      (* ignore (declare_constant (var_of_string ind_schd_name) ) *)

      (* let constr_expr = inductive_schedule_to_constr_expr inductive_schedule ds opt in *)
      Feedback.msg_notice (str "Inductive Schedule ConstrExpr:\n" ++ str (NewGenericLib.constr_expr_to_string mutrec_constr_expr) ++ fnl ());
      Feedback.msg_notice (str "We shouldn't have a constant");
      ignore (define mutrec_constr_expr env evd);
      Feedback.msg_notice (str "We really should have a constant"); *)
    | None -> failwith "Failed to parse inductive type " 
    }
END

TACTIC EXTEND merge_sound_core
  | ["merge_sound_core"] -> { merge_sound }
END

TACTIC EXTEND remember_induct
  | ["remember_induct" ident(h)] -> { remember_induct h }
END
