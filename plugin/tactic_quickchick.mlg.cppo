{
(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

  open Ltac_plugin
  open Error
  open Pp
  open Stdarg
  open GenericLib

}

DECLARE PLUGIN "coq-quickchick.plugin"

{
let merge_sound =
  let rec get_hyps (s : Evd.evar_map) (c : EConstr.constr) =
    if EConstr.isProd s c then
      let (x,t1,t2) = EConstr.destProd s c in
      (x,t1) :: get_hyps s t2
    else []
  in 
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let s = Proofview.Goal.sigma gl in
    let to_intro = get_hyps s c in
    let rec calc_ids acc opts =
      match opts with
      | [] -> begin match acc with
              | to_ind::rest -> (to_ind, List.rev acc)
              | _ -> failwith "No product/merge_sound"
              end
      | (nb,_) :: nbs ->
         begin match Context.binder_name nb with
         | Names.Name id -> calc_ids (id :: acc) nbs
         | Names.Anonymous -> calc_ids (Names.Id.of_string "H" :: acc) nbs
         end in
    match calc_ids [] to_intro with
    | (_to_induct, opts) ->
       Tactics.intros_using_then opts (fun ids ->
           Tacticals.tclTHENLIST
             [ Tacticals.onLastHyp Tactics.simplest_elim
             ; Tactics.intros 
         ])
  end;;

let remember_induct h =
  Proofview.Goal.enter begin fun gl ->
    let s = Proofview.Goal.sigma gl in
    let env = Proofview.Goal.env gl in
    let cn = EConstr.mkVar h in
    Tacticals.tclTYPEOFTHEN cn (fun evm ct -> 
        msg_debug (str "Here: " ++ Printer.pr_constr_env env s (EConstr.to_constr s ct) ++ fnl());
        let to_remember = 
          if EConstr.isApp s ct then begin
              let (ctr, cs) = EConstr.destApp s ct in
              let to_remember = ref [] in
              Array.iter (fun cx ->
                  if EConstr.isApp s cx then
                    to_remember := cx :: !to_remember
                  else if EConstr.isConstruct s cx then
                    to_remember := cx :: !to_remember
                  else msg_debug (str "All good" ++ fnl ())) cs;
              !to_remember
            end
          else failwith "Not App" in
        let eqpat = CAst.make @@ Namegen.IntroAnonymous in 
        let cl =
          { Locus.onhyps = None
          ; Locus.concl_occs = Locus.AllOccurrences } in 
        let rec do_remembers (pats : EConstr.constr list) =
          match pats with
          | [] ->
#if COQ_VERSION >= (8, 19, 0)
            Induction.induction false None cn None None
#else
            Tactics.induction false None cn None None
#endif
          | p :: ps ->
             Tacticals.tclTHEN
#if COQ_VERSION >= (8, 18, 0)             
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (Some s, p) cl)
#else
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (s, p) cl)
#endif                 
                   (do_remembers ps) in
        msg_debug (int (List.length to_remember) ++ fnl ());
        do_remembers to_remember
      )
    end

let print_type_names (inds : ty_ctr list) : unit =
  List.iter (fun ind -> msg_debug (str (ty_ctr_to_string ind) ++ fnl ())) inds

let remove_duplicates l =
  let rec remove_duplicates' l acc =
    match l with
    | [] -> acc
    | x :: xs -> if List.mem x acc then remove_duplicates' xs acc else remove_duplicates' xs (x :: acc) in
  remove_duplicates' l []
    
let is_inductive' (ty_name : ty_ctr) : bool =
  is_inductive (injectCtr (ty_ctr_to_string ty_name))

let rec extract_names_dep_type (dt : dep_type) : ty_ctr list =
  match dt with
  | DProd ((_, DTyCtr (c,_)), ty2) -> 
    if is_inductive' c then
      c :: extract_names_dep_type ty2
    else
      failwith "Rule hypotheses and conclusions must be inductive 1."
  | DProd ((_, DTyVar _), ty2) -> extract_names_dep_type ty2
  | DProd ((_, DTyParam _), ty2) -> extract_names_dep_type ty2
  | DArrow (DTyCtr (c,_), ty2) -> 
    if is_inductive' c then
      c :: extract_names_dep_type ty2
    else
      failwith "Rule hypotheses and conclusions must be inductive 2."
  | DArrow (_, ty2) -> extract_names_dep_type ty2
  | DTyCtr (_, _) -> []
  | _ -> failwith ("Rule hypotheses and conclusions must be inductive 3. " ^ dep_type_to_string dt)


let overall_type_inductive_names ((ind_name, params, rules, overall_type) : dep_dt) : ty_ctr list =
  extract_names_dep_type overall_type

let constructors_used_inductive_names ((ind_name, params, rules, overall_type) : dep_dt) : ty_ctr list =
  remove_duplicates (List.concat_map (fun (cons, typ) -> extract_names_dep_type typ) rules)

let ty_ctr_to_dep_dt (tycon : ty_ctr) =
  match qualid_to_dep_dt (tyCtrToQualid tycon) with
  | None -> failwith ("Inductive not found: " ^ ty_ctr_to_string tycon)
  | Some dt -> dt
  
let seek_ind_types_from_overall_type root : ty_ctr list =
  let rec seek_ind_types ind_name visited : ty_ctr list =
    if List.mem ind_name visited then
      visited 
    else
      let dep_dt = ty_ctr_to_dep_dt ind_name in
      let used_inds = constructors_used_inductive_names dep_dt in
      List.fold_left (fun visited' ind_name' -> seek_ind_types ind_name' visited') (ind_name :: visited) used_inds
    in
  let dep_dt = ty_ctr_to_dep_dt root in
  let used_inds = overall_type_inductive_names dep_dt in
  
  List.fold_left (fun visited' ind_name' -> seek_ind_types ind_name' visited') [root] used_inds

let seek_all_dep_dt root_ind_name : dep_dt list =
  List.map (fun name -> ty_ctr_to_dep_dt name) (seek_ind_types_from_overall_type root_ind_name)

type constraint_type = FunConstraint | ConConstraint | FunConConstraint

type constrained_arg =
  | Constrained of ty_param list * constraint_type
  | Unconstrained of ty_param

type ind = ty_ctr * dep_type list
  
type constrained_ind =  ty_ctr * constrained_arg list 

let constrain_check_ind ((ind_ctr, ind_args) : ind) : constrained_ind =
  let rec collect_vars (ct : dep_type) : ty_param list =
    match ct with
    | DTyParam p -> [p]
    | DTyVar p -> [p |> var_to_string |> inject_ty_param]
    | DTyCtr (c, args) -> List.concat_map collect_vars args
    | DCtr (c, args) -> List.concat_map collect_vars args
    | DApp (f, args) -> collect_vars f @ List.concat_map collect_vars args
    | _ -> failwith "Inductive arguments must be constructors or params." in

  let rec contains_constructor = function
    | DTyCtr (_, _) | DCtr (_, _) -> true
    | DApp (f, args) -> contains_constructor f || List.exists contains_constructor args
    | _ -> false in

  let rec contains_application = function
    | DTyCtr (_, args) -> List.exists contains_application args
    | DCtr (_, args) -> List.exists contains_application args
    | DApp (_, _) -> true
    | _ -> false in

  let check_constraints (ct : dep_type) : constrained_arg =
    match ct with
    | DTyParam p -> Unconstrained p
    | DTyVar p -> Unconstrained (p |> var_to_string |> inject_ty_param) 
    | _ ->
      let contains_constructor = contains_constructor ct in
      let contains_application = contains_application ct in
      if contains_constructor && contains_application then
        Constrained (collect_vars ct, FunConConstraint)
      else if contains_constructor then
        Constrained (collect_vars ct, ConConstraint)
      else if contains_application then
        Constrained (collect_vars ct, FunConstraint)
      else
        failwith ("Inductive arguments must be constructors or params. This is not: " ^ dep_type_to_string ct) in
  (ind_ctr, List.map check_constraints ind_args)

type arity = int

type output_index = int

type rule = ty_ctr * constructor * arity * constrained_ind list * constrained_ind

let rec dep_type_arity = function
  | DProd ((_, _), t2) -> 1 + dep_type_arity t2
  | DArrow (_, y) -> 1 + dep_type_arity y
  | _ -> 0

let dep_dt_arity ((ind_name, params, rules, overall_type) : dep_dt) : int =
  match rules with
  | [] -> dep_type_arity overall_type
  | r :: xs -> 
    (match dep_result_type (snd r) with
    | DTyCtr (ind, args) -> List.length args
    | _ -> failwith "Rule hypotheses and conclusions must be inductive.")

let types_to_constructor_lookup (types : dep_dt list) : (constructor * (constructor * arity) list) list =
  let dep_dt_collect_constructors ((ind_name, params, rules, overall_type) : dep_dt) : (constructor * arity) list =
    List.map (fun (name, typ) -> (name, dep_type_arity typ)) rules in
  let constructor_to_constructors_map (a : ('a * 'b) list) : ('a * ('a * 'b) list) list =
    List.map (fun (x,_) -> (x, a)) a in
  List.concat_map (fun ind_rules -> constructor_to_constructors_map (dep_dt_collect_constructors ind_rules)) types

type constructor_map = (constructor * (constructor * arity) list) list

let eq_basename c1 c2 = Libnames.qualid_basename (constructor_to_qualid c1) = Libnames.qualid_basename (constructor_to_qualid c2)
let eq_tyctr_basename c1 c2 = Libnames.qualid_basename (tyCtrToQualid c1) = Libnames.qualid_basename (tyCtrToQualid c2)

let find_type (c : constructor) (types : constructor_map) : (constructor * arity) list =
  let rec assoc_opt_eq c l eq = match l with
    | [] -> None
    | (a, b) :: l -> if eq a c then Some b else assoc_opt_eq c l eq in 
  match assoc_opt_eq c types eq_basename with
  | None -> failwith ("Constructor not found: " ^ constructor_to_string c ^ " map: " ^ List.fold_left (fun acc (c, _) -> acc ^ ", " ^ constructor_to_string c) "" types)
  | Some cs ->
    msg_debug (str (List.fold_right (fun (c, a) acc -> constructor_to_string c ^ " " ^ string_of_int a ^ ", " ^ acc) cs "") ++ fnl ());
      cs 

type pattern =
| PCtr of constructor * pattern list
| PWild

let rec string_of_pattern = 
  function
  | PCtr (c, []) -> constructor_to_string c
  | PCtr (c, p :: ps) -> 
    let cstr = constructor_to_string c in
    (if cstr = "Tuple_" then "" else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
  | PWild -> "_"

let tuple_name = injectCtr "Tuple_"

let rec map_maybe f = function
  | [] -> []
  | x :: xs -> 
    (match f x with
    | None -> map_maybe f xs
    | Some y -> y :: map_maybe f xs)

(*Gets patterns from conclusion of constructor*)
let pattern_of_dep_ctr (ctr : dep_ctr) : constructor * pattern =
  let rec pattern_args = function
    | DCtr (c, args) -> Some (PCtr (c, map_maybe pattern_args args))
    | DApp (DTyVar f, args) -> Some PWild
    | DTyVar _ -> Some PWild
    | DTyParam _ -> Some PWild
    | DTyCtr (_,_) -> None (*Type argument*)
    | a -> failwith ("Argument to " ^ constructor_to_string (fst ctr) ^ " must be constructors or function applications or variables. Found: " ^ dep_type_to_string a) in
  let rec pattern_of_dep_type = function
    | DProd ((_, _), t2) -> pattern_of_dep_type t2
    | DArrow (_, y) -> pattern_of_dep_type y
    | DTyCtr (ind, args) -> PCtr (tuple_name, map_maybe pattern_args args)
    | a -> failwith ("Rule hypotheses and conclusions must be inductive: " ^ dep_type_to_string a) in
  let (name, ctr_typ) = ctr in
  msg_debug (str (dep_type_to_string ctr_typ) ++ fnl ());
  (name, pattern_of_dep_type ctr_typ)

let input_pattern_of_dep_ctr (ctr : dep_ctr) (ois : output_index list) : constructor * pattern =
  let (cons, PCtr (_,patterns)) = pattern_of_dep_ctr ctr in
  let wildcard_indices ois patterns = List.mapi (fun i p -> if List.mem i ois then PWild else p) patterns in
  (cons, PCtr (tuple_name, wildcard_indices ois patterns))

let input_patterns_of_dep_dt ((ind_name, params, rules, overall_type) : dep_dt) (ois : output_index list) : (constructor * pattern) list =
  List.map (fun ctr -> input_pattern_of_dep_ctr ctr ois) rules

(*Type of search trees*)
type pattern_coverage_tree =
  | PatternLeaf of pattern * constructor list 
    (*the pattern describes the least granular space needed to describe coverage at this point, and the list of rules which provide coverage to it, if any.*)
  | PatternNode of pattern * constructor list * int list * (constructor * pattern_coverage_tree) list (*The int list represents the path to the current wildcard thats being split*)

let print_decomposed_pattern (dec : (constructor * int * int list) list) : unit =
  msg_debug (str "Printing Decomposed Pattern" ++ fnl ());
  let string_of_dec (c, n, path) = constructor_to_string c ^ " " ^ string_of_int n ^ " :" ^ List.fold_left (fun acc i -> acc ^ ", " ^ string_of_int i) "" path in 
  List.iter (fun d -> msg_debug (str (string_of_dec d) ++ fnl ())) dec;
  msg_debug (str "Finished Decomposed Pattern" ++ fnl ())

let enumerate_list = List.mapi (fun i p -> p,i)

let rec decompose_pattern_path (p : pattern) (path : int list): (constructor * int * int list) list =
  match p with
  | PCtr (c, ps) -> 
      (c, List.length ps, path) :: List.concat_map (fun (p, i) -> decompose_pattern_path p (path @ [i])) (enumerate_list ps)
  | PWild -> []

let decompose_pattern (p : pattern) : (constructor * int * int list) list =
  let dec = decompose_pattern_path p [] in print_decomposed_pattern dec; msg_debug (fnl ()); dec

let rec apply_at (f : 'a -> 'a) (i : int) (l : 'a list) : 'a list =
  match l, i with
  | [], _ -> []
  | x :: xs, 0 -> f x :: xs 
  | x :: xs, i -> x :: apply_at f (i - 1) xs

let rec apply_lookup eq (f : 'a -> 'a) (i : 'i) (l : ('i * 'a) list) : ('i * 'a) list =
  match l with
  | [] -> []
  | (i', x) :: xs -> if eq i i' then (i', f x) :: xs else (i', x) :: apply_lookup eq f i xs

let rec insert_at_path (p : pattern) (path : int list) (c : constructor) wilds : pattern =
  match path with
  | [] -> PCtr (c, wilds)
  | i :: is -> 
      match p with
      | PCtr (c', ps) -> PCtr (c', apply_at (fun p' -> insert_at_path p' is c wilds) i ps)
      | PWild -> failwith "Path is too long"

let rec make_wilds n =
  if n > 0 then PWild :: make_wilds (n - 1)
  else [] 

let rec label_tree label ptree : pattern_coverage_tree =
  match ptree with
  | PatternLeaf (p, rules) -> PatternLeaf (p, label :: rules)
  | PatternNode (p, rules, path, branches) -> PatternNode (p, label :: rules, path, List.map (fun (c, p') -> (c, label_tree label p')) branches) 

let rec pattern_at_path (path : int list) (p : pattern) : pattern =
  match path with
  | [] -> p
  | i :: is ->
      match p with
      | PCtr (c, ps) -> pattern_at_path is (List.nth ps i)
      | PWild -> PWild  

let rec cover_single_pattern_layer (con : constructor)
    (path : int list) (pat_so_far : pattern) (p : pattern_coverage_tree) 
    (types : constructor_map) : pattern_coverage_tree =
  match p with
  | PatternLeaf (pat, rules)-> 
      let constructors = find_type con types in
      let new_pattern c arity = insert_at_path pat path c (make_wilds arity) in
      let new_pattern_leaves = List.map (fun (c, arity) -> c, PatternLeaf (new_pattern c arity, rules)) constructors in
      PatternNode (pat, rules, path, new_pattern_leaves)
  | PatternNode (pat, rules, path', branches)->
      if path = path' then 
        PatternNode (pat, rules, path', branches)
      else
        begin match pattern_at_path path' pat_so_far with
        | PWild -> 
            PatternNode (pat, rules, path', 
                         List.map (fun (c, p') -> (c, cover_single_pattern_layer con path pat_so_far p' types)) branches
                        )
        | PCtr (c, _) -> 
            PatternNode (pat, rules, path', 
                         apply_lookup eq_basename (fun p' -> cover_single_pattern_layer con path pat_so_far p' types) c branches
                        )
        end

let rec subpattern (sub : pattern) (pat : pattern) : bool =
  msg_debug (str ("sub: " ^ string_of_pattern sub ^ " | sup: " ^ string_of_pattern pat) ++ fnl ());
  match sub, pat with
  | _, PWild -> true
  | PWild, PCtr (c, ps) -> false
  | PCtr (subc, subps), PCtr (c, ps) -> 
    if eq_basename subc c then
      try (List.for_all2 (fun sub sup -> subpattern sub sup) subps ps) with Invalid_argument _ -> failwith "Patterns with same constructor have different argument count: subpattern"
    else false

let rec compatible_pattern (sub : pattern) (pat : pattern) : bool =
  match sub, pat with
  | _, PWild -> true
  | PWild, PCtr (c, ps) -> true
  | PCtr (subc, subps), PCtr (c, ps) ->
    if eq_basename subc c then
      try (List.for_all2 (fun sub sup -> compatible_pattern sub sup) subps ps) with Invalid_argument _ -> failwith "Patterns with same constructor have different argument count: compatible_pattern"
    else false

let rec label_subpatterns (rule_name : constructor) (pat : pattern) (pt : pattern_coverage_tree) : pattern_coverage_tree =
  match pt with
  | PatternLeaf (p, rules) -> if subpattern p pat then PatternLeaf (p, rule_name :: rules) else pt
  | PatternNode (p, rules, path, branches) ->
    msg_debug (str (constructor_to_string rule_name) ++ fnl ());
    if subpattern p pat then label_tree rule_name pt else
    if compatible_pattern p pat then
      PatternNode (p, rules, path, List.map (fun (c, p') -> (c, label_subpatterns rule_name pat p')) branches)
    else pt 

let rec cover_decomposed_pattern (pat_so_far : pattern) (dec : (constructor * int * int list) list) (p : pattern_coverage_tree) (types : constructor_map) : pattern_coverage_tree =
  match dec with
  | [] -> p
  | (c, n, path) :: rest ->
      let new_p = cover_single_pattern_layer c path pat_so_far p types in 
      let pat_so_far' = insert_at_path pat_so_far path c (make_wilds n) in
      cover_decomposed_pattern pat_so_far' rest new_p types

let pattern_tree_root : pattern_coverage_tree = PatternLeaf (PWild, [])

let cover_pattern' (rule_name : constructor) (p : pattern) (types : constructor_map) (ptree : pattern_coverage_tree) : pattern_coverage_tree =
  let dec = decompose_pattern p in
  label_subpatterns rule_name p (cover_decomposed_pattern PWild dec ptree types)

let cover_patterns (ps : (constructor * pattern) list) (types : constructor_map) root : pattern_coverage_tree =
  List.fold_left (fun ptree (c, p) -> cover_pattern' c p types ptree) root ps

let tuple_types arity = (tuple_name,[tuple_name,arity])

let cover_tuple_patterns ps arity types = cover_patterns ps (tuple_types arity :: types) pattern_tree_root

let rec map_patterns (f : pattern -> pattern) (tree : pattern_coverage_tree) : pattern_coverage_tree =
  let f' = function
    | PWild -> PWild
    | a -> f a in
  match tree with
  | PatternLeaf (p, cs) -> PatternLeaf (f' p, cs)
  | PatternNode (p, cs, path, branches) -> PatternNode (f' p, cs, path, List.map (fun (c, subtree) -> (c, map_patterns f' subtree)) branches) 

let print_coverage_tree (ind : ty_ctr) (tree : pattern_coverage_tree) (ois : output_index list) = 
  let replace_at_indices is x l = List.mapi (fun i y -> if List.mem i is then x else y) l in
  let insert_output_in_leaf (PCtr (c, ps)) = PCtr (c, replace_at_indices ois (PCtr (injectCtr "OUT",[])) ps) in
  let tree' = map_patterns insert_output_in_leaf tree in
  let rec string_of_pattern = 
    function
    | PCtr (c, []) -> constructor_to_string c
    | PCtr (c, p :: ps) -> 
      let cstr = constructor_to_string c in
      (if cstr = "Tuple_" then ty_ctr_to_string ind else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
    | PWild -> "_" in
  let string_of_constructors = function
    | [] -> "[]"
    | c :: cs -> "[" ^ constructor_to_string c ^ List.fold_left (fun acc c -> acc ^ "; " ^ constructor_to_string c) "" cs ^ "]" in
  let string_of_pattern_leaf (p, cs) = string_of_pattern p ^ " : " ^ string_of_constructors cs in
  let rec print_tree indent = function
    | PatternLeaf (p, cs) -> Feedback.msg_notice (str (String.make indent ' ' ^ string_of_pattern_leaf (p, cs)) ++ fnl ())
    | PatternNode (p, cs, path, branches) -> 
      Feedback.msg_notice (str (String.make indent ' ' ^ string_of_pattern p ^ " : " ^ string_of_constructors cs ) ++ fnl ());
      List.iter (fun (c, subtree) -> print_tree (indent + 2) subtree) branches
    in
  print_tree 0 tree'


(*Take in an inductive name and a dep_ctr (a dependent constructor), and collect the hypotheses and conclusions*)
let rule_of_dep_ctr ind_name (ctr : dep_ctr) : rule =
  let (name, ctr_typ) = ctr in
  let rec hyp_conc = function
    | DProd ((_, _), t2) -> 
      let (hyps, conc, arity) = hyp_conc t2 in
      (hyps, conc, arity + 1)
    | DArrow (DTyCtr (ind, args), y) -> 
      let (hyps, conc, arity) = hyp_conc y in
      ((ind,args) :: hyps, conc, arity)
    | DArrow (DNot (DTyCtr (ind,args)),y) when eq_tyctr_basename ind (gInjectTyCtr "eq") ->  (* a <> b as a hypothesis affects the density little, 
                                                                                                     assuming a and b are independently generated.
                                                                                                     need to check for that later, for now, we just
                                                                                                     drop any <> hypothesis regardless of its args.*)
      let (hyps, conc, arity) = hyp_conc y in
      (hyps, conc, arity)
    | DTyCtr ((ind,args)) -> ([], (ind,args), 0)
    | _ -> failwith "Rule hypotheses and conclusions must be inductive." in 
  let (hyps, conc, arity) = hyp_conc ctr_typ in
  (ind_name, name, arity, List.map constrain_check_ind hyps, constrain_check_ind conc)

let dep_dt_rules ((ind_name, params, rules, overall_type) : dep_dt) : rule list =
  List.map (rule_of_dep_ctr ind_name) rules

type rule_density = 
  | Empty
  | Backtracking
  | Partial

let rec collect_leaves (tree : pattern_coverage_tree) : (pattern * constructor list) list =
  match tree with
  | PatternLeaf (p, cs) -> [(p,cs)]
  | PatternNode (_, _, _, branches) ->
      List.concat_map (fun (_, subtree) -> collect_leaves subtree) branches

let print_pattern_leaves (ind : ty_ctr) (tree : pattern_coverage_tree) (ois : output_index list) (densities : (constructor * rule_density) list) : unit =
  let rec string_of_pattern = 
    function
    | PCtr (c, []) -> constructor_to_string c
    | PCtr (c, p :: ps) -> 
      let cstr = constructor_to_string c in
      (if cstr = "Tuple_" then ty_ctr_to_string ind else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
    | PWild -> "_" in
  let density_to_string = function
    | Empty -> "Empty"
    | Backtracking -> "Backtracking"
    | Partial -> "Partial" in
  let string_of_constructors = function
    | [] -> "[]"
    | (c,d) :: cs -> "[" ^ constructor_to_string c ^ ": " ^ density_to_string d ^ List.fold_left (fun acc (c,d) -> acc ^ "; " ^ constructor_to_string c ^ ": " ^ density_to_string d) "" cs ^ "]" in
  let string_of_pattern_leaf (p, cs) = string_of_pattern p ^ " : " ^ string_of_constructors cs in
  let replace_at_indices is x l = List.mapi (fun i y -> if List.mem i is then x else y) l in
  let insert_output_in_leaf (PCtr (c, ps), cs) = (PCtr (c, replace_at_indices ois (PCtr (injectCtr "OUT",[])) ps), cs) in
  let annotate_densities (p, cs) = (p, List.map (fun c -> (c, List.assoc c densities)) cs) in
  List.iter (fun (p, cs) -> Feedback.msg_notice (str (string_of_pattern_leaf (annotate_densities (insert_output_in_leaf (p, cs)))) ++ fnl ())) (collect_leaves tree)

let print_rule_densities (rs : (constructor * rule_density) list) : unit =
  let string_of_density = function
    | Empty -> "Empty"
    | Backtracking -> "Backtracking"
    | Partial -> "Partial" in
  List.iter (fun (c,d) -> Feedback.msg_notice (str (  constructor_to_string c ^ ": " ^ string_of_density d) ++ fnl ())) rs

let rec has_duplicates (lst : 'a list) : bool =
  match lst with
  | [] -> false
  | x :: xs -> List.mem x xs || has_duplicates xs

let remove_duplicates l =
  let rec remove_duplicates' l acc =
    match l with
    | [] -> acc
    | x :: xs -> if List.mem x acc then remove_duplicates' xs acc else remove_duplicates' xs (x :: acc) in
  remove_duplicates' l []

let not_pairwise_disjoint (xss : 'a list list) : bool =
  let sets = List.map remove_duplicates xss in
  has_duplicates (List.concat sets) 

let split_indices xs idxs =
  let rec go xs idxs i =
    match xs with
    | [] -> ([], [])
    | x :: xs -> 
      if List.mem i idxs then 
        let (inidx, outidx) = go xs idxs (i + 1) in
        (x :: inidx, outidx)
      else 
        let (ys, zs) = go xs idxs (i + 1) in
        (ys, x :: zs) 
    in
  go xs idxs 0

let density_to_string = function
  | Empty -> "Empty"
  | Backtracking -> "Backtracking"
  | Partial -> "Partial"

(*Three heuristics detecting difficult to generate rules*)
let rec is_output_constrained_in_hypothesis ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let output_index_hyps = List.concat_map (fun (ind, args) -> fst (split_indices args ois)) recursive_hyps in
  if List.exists (fun arg -> match arg with
    | Constrained _ -> true
    | Unconstrained _ -> false) output_index_hyps
    then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": output constrained in hypothesis") ++ fnl ()); true) else false

and is_output_hyps_require_unification ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let collect_vars = function
    | Constrained (args,_) -> args
    | Unconstrained arg -> [arg] in
  let output_index_hyps : ty_param list list = List.map (fun (ind,args) -> List.concat_map collect_vars (fst (split_indices args ois))) recursive_hyps in
  if not_pairwise_disjoint output_index_hyps then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": output hyps require unification") ++ fnl ()); true) else false

and is_input_conclusion_require_unification ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let conclusion_args = snd conc in
  let (_,input_conc_args) = split_indices conclusion_args ois in
  let collect_vars = function
    | Constrained (args,_) -> args
    | Unconstrained arg -> [arg] in
  let all_input_conc_vars = List.concat_map collect_vars input_conc_args in
  if has_duplicates all_input_conc_vars then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": input conc requires unification") ++ fnl ()); true) else false

and are_functions_constraining_conclusion_inputs_or_hyp_outputs ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let conclusion_args = snd conc in
  let (_,input_conc_args) = split_indices conclusion_args ois in
  let fun_constrained = function
    | Constrained (args, FunConstraint) | Constrained (args, FunConConstraint) -> true
    | _ -> false in
  if List.exists fun_constrained input_conc_args then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": functions constrain conclusion inputs") ++ fnl ()); true) else
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let output_index_hyps : constrained_arg list list = List.map (fun (ind, args) -> fst (split_indices args ois)) recursive_hyps in
  if List.exists (fun args -> List.exists fun_constrained args) output_index_hyps then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": functions constrain hypothesis outputs") ++ fnl ()); true) else false

and nonrecursive_disjoint_strictly_output_vars ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : (ty_ctr * (output_index * ty_param) list) list =
  let (conclusion_output_args,conclusion_input_args) = split_indices (snd conc) ois in
  let args_to_vars arg_list = List.concat_map (function Constrained (args,_) -> args | Unconstrained arg -> [arg]) arg_list in
  let conclusion_output_vars = args_to_vars conclusion_output_args in
  let conclusion_input_vars = args_to_vars conclusion_input_args in
  let (nonrecursive_hyps, recursive_hyps) = List.partition (fun (ind, args) -> ind <> ind_name) hyps in
  let recursive_output_vars = List.concat_map (fun (ind, args) -> args_to_vars (fst (split_indices args ois))) recursive_hyps in
  let nonrecursive_output_vars = List.map (fun (ind, args) -> 
    let numbered_args = List.mapi (fun i arg -> (i, arg)) args in
    let unconstrained_vars = List.concat_map (function (n,Unconstrained arg) -> [(n,arg)] | _ -> []) numbered_args in
    let unconstrained_output_vars = List.filter (fun (_,v) -> List.mem v conclusion_output_vars) unconstrained_vars in
    let unconstrained_output_noninput_vars = List.filter (fun (_,v) -> not (List.mem v conclusion_input_vars)) unconstrained_output_vars in
    let unconstrained_disjoint_output_noninput_vars = List.filter (fun (_,v) -> not (List.mem v recursive_output_vars)) unconstrained_output_noninput_vars in
    ind,unconstrained_disjoint_output_noninput_vars) nonrecursive_hyps in
  nonrecursive_output_vars
  
and filter_nonrecursive_empty_densities (nonrecurse : (ty_ctr * (output_index * ty_param) list)) =
  let (ind, output_vars) = nonrecurse in
  let dep_dt = ty_ctr_to_dep_dt ind in
  let filtered_ovars = List.filter_map (fun (oi,l) ->
    let density = final_density dep_dt [oi] false in
    match density with
    | Empty -> None
    | Backtracking | Partial -> Some (oi,l, density)) output_vars in
  ind,filtered_ovars

and nonrecursive_binding (nonrecursives : (ty_ctr * (output_index * ty_param * rule_density) list) list) : ((ty_ctr * output_index * ty_param * rule_density) list) option =
  match nonrecursives with
  | [] -> Some []
  | (ind, []) :: rest -> None
  | (ind, (oi, v,Partial) :: ovars) :: rest ->
    let updated_rest = List.map (fun (ind, ovars) -> (ind, List.filter (fun (_,v',_) -> v' <> v) ovars)) rest in
    (match nonrecursive_binding updated_rest with
    | None -> nonrecursive_binding ((ind, ovars) :: rest)
    | Some bindings -> Some ((ind, oi, v, Partial) :: bindings))
  | (ind, (oi, v,Backtracking) :: ovars) :: rest -> 
    let updated_rest = List.map (fun (ind, ovars) -> (ind, List.filter (fun (_,v',_) -> v' <> v) ovars)) rest in
    (match nonrecursive_binding ((ind,ovars) :: rest) with
     | Some ((ind',oi',v',Partial) :: bindings) -> Some ((ind', oi', v', Partial) :: bindings)
     | _ -> (match nonrecursive_binding updated_rest with | None -> None | Some bindings -> Some ((ind, oi, v, Backtracking) :: bindings)) 
    )
    
and is_nonrecursive_checked_or_overlapping_or_empty ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let nonrecursive_output_vars = nonrecursive_disjoint_strictly_output_vars (ind_name, ctr_name, arity, hyps, conc) ois in
  let filtered_nonrecursive_output_vars = List.map filter_nonrecursive_empty_densities nonrecursive_output_vars in
  match nonrecursive_binding filtered_nonrecursive_output_vars with
  | None -> (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": >= 1 nonrecursive bindings must be checked") ++ fnl ()) ; true)
  | Some [] -> false
  | Some (b :: bindings) -> 
    let bindings = b :: bindings in
    Feedback.msg_notice (str "Printing nonrecursive bindings for: " ++ str (constructor_to_string ctr_name) ++ fnl ()); 
    List.iter (fun (ind, oi, v, density) -> Feedback.msg_notice (str (ty_ctr_to_string ind ^ " argument #: " ^ string_of_int oi ^ "; var name: " ^ ty_param_to_string v ^ "; density: " ^ density_to_string density) ++ fnl ())) bindings;
    false (*In the future these bindings should be output and prederived.*)

and analyze_rule (r : rule) (ois : output_index list) : rule_density =
  msg_debug (str (List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());
  if is_output_hyps_require_unification r ois 
    || is_input_conclusion_require_unification r ois
    || are_functions_constraining_conclusion_inputs_or_hyp_outputs r ois
    || is_nonrecursive_checked_or_overlapping_or_empty r ois 
  then 
    Empty 
  else if is_output_constrained_in_hypothesis r ois then
    Backtracking
  else 
    Partial

and analyze_rules (rs : rule list) ois : (constructor * rule_density) list =
  List.map (fun (ind, cons, arity, hyps, conc) -> (cons, analyze_rule (ind, cons, arity, hyps, conc) ois)) rs

and final_density (dt : dep_dt) ois (should_print : bool): rule_density =
  let (ind_name, _, _, _) = dt in
  let tree = cover_tuple_patterns (input_patterns_of_dep_dt dt ois) (dep_dt_arity dt) (types_to_constructor_lookup (seek_all_dep_dt ind_name)) in
  let covered_patterns = collect_leaves tree in
  let densities = analyze_rules (dep_dt_rules dt) ois in
  if should_print then (Feedback.msg_notice (str ("Rule densities for: " ^ ty_ctr_to_string ind_name ^ " with output indices: " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());
  print_rule_densities densities);
  let filter_empty_constructors = List.map (fun (p, cs) -> p, List.filter (fun c -> match List.assoc c densities with | Empty -> false | Partial | Backtracking -> true) cs) covered_patterns in
  let any_uncovered = List.exists (fun (p,cs) -> cs = []) filter_empty_constructors in
  let all_has_partial = List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities = Partial) cs) filter_empty_constructors in
  let result = if any_uncovered then Empty else if all_has_partial then Partial else Backtracking in
  if should_print then (Feedback.msg_notice (str "Rule pattern coverage tree:" ++ fnl ());
                        print_coverage_tree ind_name tree ois; Feedback.msg_notice (fnl ());
                        Feedback.msg_notice (str "Set of patterns and densities of their covering rules:" ++ fnl ());
                        print_pattern_leaves ind_name tree ois densities; 
                        Feedback.msg_notice (str ("Inductive relation " ^ ty_ctr_to_string ind_name ^ " with output indices:"
                                                  ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois 
                                                  ^ " has overall density: " 
                                                  ^ (density_to_string result)) ++ fnl ()));
  result

(* let analyze_inductive_rules ind ois =
  match (coerce_reference_to_dep_dt ind) with
  | None -> failwith "Inductive not found"
  | Some dep_dt -> 
    let (name, _, _, _) = dep_dt in
    Feedback.msg_notice (str (ty_ctr_to_string name ^ " " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());

    print_rule_densities (analyze_rules (dep_dt_rules dep_dt) ois) *)



let decOpt_fuel = 7

(* variable v, type of v, if None then 
                             unbound 
                          else 
                             (bound inductive, index of binding argument)*)
type binding = var * dep_type * (dep_type * int) option

type bindings_and_unbound = binding list * dep_type list 
type relation_variables = (int * var list) list
type var_uses_in_relations = (var * (int * int) list) list
type dep_type_var_map_views = relation_variables * var_uses_in_relations

(* 1. list of bindings
   2. list of unbound inductives  *)

let list_pair_with_rest l =
  let rec aux before current =
    match current with
    | [] -> []
    | now :: after -> (before @ after, now) :: aux (now :: before) after in
  aux [] l

let safe_assoc i l = try List.assoc i l with _ -> []

let rec assoc_remove_all_in_set k_set l =
  match l with
  | [] -> []
  | (k, v) :: rest -> if List.mem k k_set then assoc_remove_all_in_set k_set rest else (k, v) :: assoc_remove_all_in_set k_set rest

let list_bind (l : 'a list) (f : 'a -> 'b list) : 'b list =
  List.concat (List.map f l)

let print_all_bindings' (bindings : (int * bindings_and_unbound) list) : unit =
  if bindings = [] then Feedback.msg_notice (str "No bindings found" ++ fnl ())
  else
    let string_of_option f = function
      | None -> "Gen"
      | Some x -> "GenST: " ^ f x in
    List.iter (fun (idx, (b, i)) ->
        Feedback.msg_notice (str "Bindings: " ++ str (string_of_int idx) ++ fnl ());
      List.iter (fun (v, t, opt) ->
          Feedback.msg_notice (str "(" ++ str (var_to_string v) ++ str " : " ++ str (dep_type_to_string t) ++ str ") => " ++ str (string_of_option (fun (r, i) -> dep_type_to_string r ^ ", output index: " ^ string_of_int (i - 1)) opt) ++ fnl ())
      ) b;
      List.iter (fun i -> Feedback.msg_notice (str (dep_type_to_string i) ++ fnl ())) i
    ) bindings  

let print_all_bindings_density bindings : unit =
  if bindings = [] then Feedback.msg_notice (str "No bindings found" ++ fnl ())
  else
    let string_of_option f = function
      | None -> "Gen"
      | Some x -> "GenST: " ^ f x in
    List.iter (fun (idx, (b, i)) ->
        Feedback.msg_notice (str "Bindings: " ++ str (string_of_int idx) ++ fnl ());
      List.iter (fun (v, t, opt, d) ->
          Feedback.msg_notice (str "(" ++ str (var_to_string v) ++ str " : " ++ str (dep_type_to_string t) ++ str ") => " ++ str (string_of_option (fun (r, i) -> dep_type_to_string r ^ ", output index: " ^ string_of_int (i - 1)) opt) ++ str ("; Density: " ^ density_to_string d) ++ fnl ())
      ) b;
      List.iter (fun i -> Feedback.msg_notice (str (dep_type_to_string i) ++ fnl ())) i
    ) bindings  

let rec binding_options' ((ind_vars, var_uses) : dep_type_var_map_views) (typed_vars : (var * dep_type) list) : var_uses_in_relations list =
  if typed_vars = [] then [var_uses] else begin
  let var_to_bind_options = list_pair_with_rest typed_vars in
  let bind_variable_to_relation var ty idx_var_idx_opt : dep_type_var_map_views * (var * dep_type) list =
    match idx_var_idx_opt with
    | None -> 
        let ind_vars' = List.map (fun (i, vs) -> (i, List.filter (fun v -> v <> var) vs)) ind_vars in
        let var_uses' = (var, []) :: List.remove_assoc var var_uses in
        let typed_vars' = List.remove_assoc var typed_vars in
        ((ind_vars', var_uses'), typed_vars')
    | Some (idx, var_idx) -> 
        let ind_uses : var list = safe_assoc idx ind_vars in
        let ind_uses' = List.filter (fun v -> v <> var) ind_uses in
        let var_uses' = (var, [(idx, var_idx)]) :: (List.map (fun v -> (v,[])) ind_uses') @ (assoc_remove_all_in_set ind_uses var_uses) in
        let typed_vars' = assoc_remove_all_in_set ind_uses typed_vars in
        let ind_vars' = List.map (fun (i, vs) -> (i, List.filter (fun v -> not (List.mem v ind_uses)) vs)) ind_vars in
            ((ind_vars', var_uses'), typed_vars') in
  let bind_variable_to_relations var ty : (dep_type_var_map_views * (var * dep_type) list) list =
    let uses = None :: List.map (fun x -> Some x) (safe_assoc var var_uses) in
    List.map (fun idx_var_idx_opt -> bind_variable_to_relation var ty idx_var_idx_opt) uses in
  list_bind (list_bind var_to_bind_options (fun (_,(var, ty)) -> bind_variable_to_relations var ty)) ((fun (dtvm_views, typed_vars) -> binding_options' dtvm_views typed_vars))
  end
        
(*TODO: Filter the var_uses so that only the variables listed in the type are included. One way to do this is to simply ignore any variable which is found in no relations,
  but this excludes the case where you have forall x, P y z, where x is quantified but not used. Maybe that's alright, but that is bad if x is from the empty type.*)  
let binding_options ((ind_vars, var_uses) : dep_type_var_map_views) (typed_vars : (var * dep_type) list) theorem_relations 
  : bindings_and_unbound list =
  let options = binding_options' (ind_vars, var_uses) typed_vars in
  List.map (fun var_uses' ->
    let var_uses_typed = List.map (fun (v, uses) -> (v, List.assoc v typed_vars, List.map (fun (idx, var_idx) -> (List.assoc idx theorem_relations,var_idx)) uses)) var_uses' in
    let var_uses_typed_list_to_option = List.map (fun (v, ty, uses) -> (v, ty, match uses with [] -> None | [x] -> Some x | _ -> failwith "binding_options: multiple uses")) var_uses_typed in
    let used_theorems = List.fold_right (fun (_, _, opt) acc -> match opt with None -> acc | Some (r, _) -> r :: acc) var_uses_typed_list_to_option [] in
    let unused_theorems = List.map snd (List.filter (fun (_,thm) -> not (List.mem thm used_theorems)) theorem_relations) in
    (var_uses_typed_list_to_option, unused_theorems)
  ) options 

(*Sort bindings so all vars that are associated with a None option come before Some associated vars, and for None associated vars the vars are sorted in alphabetical order*)
let sort_bindings (bindings : ((var * dep_type * (dep_type * int) option) list) * dep_type list) : ((var * dep_type * (dep_type * int) option) list) * dep_type list =
  let (vars, theorems) = bindings in
  let (none_bindings, some_bindings) = List.partition (fun (_,_,opt) -> opt = None) vars in
  let sorted_none_bindings = List.sort (fun (v1,_,_) (v2,_,_) -> compare v1 v2) none_bindings in
  (some_bindings @ sorted_none_bindings, theorems)

let makeAllBindings (theorem : dep_type) : bindings_and_unbound list =
  let type_vars = dep_type_quantified theorem in
  let variable_uses = dep_type_var_relation_uses theorem in
  let ind_vars = dep_type_relation_variables theorem in
  let theorem_relations = dep_type_relations theorem in
  remove_duplicates (List.map sort_bindings (binding_options (ind_vars, variable_uses) type_vars theorem_relations))


let print_all_bindings (theorem : dep_type) : unit =
  let bindings_and_unbound = makeAllBindings theorem in
  Feedback.msg_notice (str "Printing all bindings" ++ fnl ());
  print_all_bindings' (List.mapi (fun i x -> i,x) bindings_and_unbound)

let print_bindings_tactic =
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        print_all_bindings dt;
        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end

let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs -> 
    match f x with
    | None -> None
    | Some y -> 
      match traverse f xs with
      | None -> None
      | Some ys -> Some (y :: ys)

let is_binding_selection_valid i ((bindings,unbound) : bindings_and_unbound) =
  let is_binding_valid (v, ty, opt) =
    match opt with
    | None -> Some (v,ty,opt, Partial)
    | Some (DTyCtr (ind,_), i) ->
      (match final_density (ty_ctr_to_dep_dt ind) [i - 1] false with
      | Empty -> None
      | d -> Some (v, ty, opt, d))
    | _ -> failwith "is_binding_selection_valid: Binding relation should have DTyCtr at toplevel" in
  match traverse is_binding_valid bindings with
  | None -> None
  | Some bs -> Some (i, (bs, unbound))

let valid_bindings =
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        let bindings_and_unbound = makeAllBindings dt in
        let valid_bindings_and_unbound = List.filter_map (fun (i, bu) -> is_binding_selection_valid i bu) (List.mapi (fun i bu -> i, bu) bindings_and_unbound) in
        Feedback.msg_notice (str "Printing all bindings" ++ fnl ());
        print_all_bindings_density valid_bindings_and_unbound;
        Tacticals.tclIDTAC
      end 
    | None -> failwith "Failed to Parse type"
  end

let rec freshen_names_in_prop (dt : dep_type) : dep_type =
  match dt with
  | DTyCtr (c, dts) -> DTyCtr (c, List.map freshen_names_in_prop dts)
  | DCtr (c, dts) -> DCtr (c, List.map freshen_names_in_prop dts)
  | DTyVar x -> DTyVar (fresh_name (var_to_string x))
  | DApp (f, args) -> DApp (freshen_names_in_prop f, List.map freshen_names_in_prop args)
  | _ -> failwith ("FRESHEN FAILED WITH: " ^ dep_type_to_string dt)

let make_bool_sig (idx : int) (dt : dep_type) : bool list =
  let len = List.length (dep_type_one_relation_variables dt) in
  List.init len (fun i -> i = (idx - 1))

(* Given a dep_type, if it is an inductive, extract its name and call find_typeclass_bindings *)
let find_typeclass_bindings_dep_type env (typ_class : string) (dt : dep_type) : (bool list) list =
  match dt with
  | DTyCtr (c, dts) -> find_typeclass_bindings ~env_opt:(Some env) typ_class c(*constructor_to_string c |> injectCtr |> ctr_to_ty_ctr*)
  | _ -> []

let find_arbitrary_st env (x_dt : dep_type) (dt : dep_type) (idx : int) : coq_expr option =
  match find_typeclass_bindings_dep_type env "GenSizedSuchThat" dt with
  | [] -> msg_debug (str "No such binding" ++ fnl ()); None
  | bindings ->
      (*This breaks because if idx is 1 in C (D a b) c, then the bool_sig will be for c => C a' c, because bool_sig only cares about first layer.*)
      let bool_sig = make_bool_sig idx dt in
      msg_debug (str "BOOLSIG: [" ++ str (List.map string_of_bool bool_sig |> String.concat ", ") ++ str "]" ++ fnl ());
      let freshen_names = freshen_names_in_prop dt in
      let names_list = dep_type_one_relation_variables freshen_names in
      let output_var_name = try List.nth names_list (idx - 1) with _ -> CErrors.user_err (str (dep_type_to_string (freshen_names)) ++ str "\n" ++ str "dep_typ_vars freshname1" ++ str "nth failed: " ++ int (idx - 1) ++ fnl ())
    in
      if List.mem bool_sig bindings then Some (g_arbitraryST (gFunWithArgs [gArg ~assumName:(gVar output_var_name) ()] (fun [v] -> gType' [] freshen_names)))
      else None

let derive_arbitrary_st x_dt dt idx =
  let freshen_names = freshen_names_in_prop dt in
  let names_list = dep_type_one_relation_variables freshen_names in
  let output_var_name = try List.nth names_list (idx - 1) with _ -> CErrors.user_err (str "dep_typ_vars freshname2" ++ str "nth failed: " ++ int (idx - 1) ++ fnl ())
  in
  let ind = gFunWithArgs [gArg ~assumName:(gVar output_var_name) ()] (fun [v] -> gType' [] freshen_names) in
  msg_debug (str "INDUCTIVE: " ++ pp_coq_expr ind ++ fnl ());
  let id = (DepDriver.dep_dispatch (unsafe_coq_expr_to_constr_expr ind) DepDriver.GenSizedSuchThat) in
  msg_debug (Names.Id.print id ++ fnl ());
  g_arbitraryST ind

let find_arbitrary env (dt : dep_type) : coq_expr option =
  match find_typeclass_bindings_dep_type env "Arbitrary" dt with
  | [] -> None
  | _ -> Some g_arbitrary

let derive_arbitrary dt = g_arbitrary

let derive_or_find_arbitrary env (x_dt : dep_type) : coq_expr =
  match find_arbitrary env x_dt with
  | Some c -> c
  | None -> derive_arbitrary x_dt
  
let derive_or_find_arbitrary_st env (x_dt : dep_type) (dt : dep_type) (idx : int) : coq_expr =
  match find_arbitrary_st env x_dt dt idx with
  | Some c -> c
  | None -> derive_arbitrary_st x_dt dt idx

let derive_or_find_generators env (x, x_dt, opt_dt) : var * coq_expr * bool =
  match opt_dt with
  | None -> (x, derive_or_find_arbitrary env x_dt, false)
  | Some (dt, idx) -> (x, derive_or_find_arbitrary_st env x_dt dt idx, true)

let bindForAlls (generators : (var * coq_expr * bool) list) (concl : coq_expr) : coq_expr =
  List.fold_right (fun (x,g,hasInductive) acc -> 
    (*If hasInductive, then I want to generate a pattern match on the variable x as an option, and if it is Some x, then return the acc, else return g_checker gTT*)
    msg_debug (str "GENERATOR: " ++ str (var_to_string x) ++ str " : " ++ pp_coq_expr g ++ fnl ());
    let collect_sizes = g_collect (gPair (gStr (var_to_string x ^ "-size"), (g_size (gVar x)))) in
    let body = if hasInductive then 
      construct_match (gVar x) ~catch_all:(Some (g_checker gTT)) [(MatchCtr (injectCtr "Coq.Init.Datatypes.Some", [MatchParameter (inject_ty_param "_"); MatchU x]), collect_sizes acc)]
                else collect_sizes acc 
        in 
    g_forAll g (gFunWithArgs [gArg ~assumName:(gVar x) ()] (fun [_] -> body))) (List.rev generators) concl

let check_remaining_inductives (inductives : dep_type list) (concl : coq_expr) : coq_expr =
  let decide prop = decOptToBool (g_decOpt prop (gInt decOpt_fuel)) in
  List.fold_right (fun ind acc -> gIf (decide (gType' [] ind)) acc (g_checker gTT)) inductives concl    
    
  (*Given an association, and the original dep_type, for each variable take... remember to emit variabl deptype pairs at the end of the list*)
let construct_constrained_generator' name env (bindings : binding list) (checked_inductives : dep_type list) (concl : dep_type) : coq_expr =
  (*Turn bound_generators into a fold, so older derives are visible by newer ones.*)
  let bound_generators : (var * coq_expr * bool) list = List.map (fun binding -> let env = Global.env () in derive_or_find_generators env binding) bindings in
  msg_debug (str "Constructed generators" ++ fnl ());
  let decide prop = decOptToBool (g_decOpt prop (gInt decOpt_fuel)) in
  (* let show_vars = g_show (gTuple (List.map (fun (v,_,_) -> g_show (gVar v)) bound_generators)) in *)
  (* let var_sizes = gList (List.map (fun (v,_,_) -> gPair (gStr (var_to_string v ^ "-size"), g_inr (g_Z_of_nat (g_size (gVar v))))) bound_generators) in *)
  (* let var_sizes = gTuple (List.map (fun (v,_,_) -> gPair (gStr (var_to_string v ^ "-size"), (g_size (gVar v)))) bound_generators) in *)
  (* let var_sizes = List.map (fun (v,_,_) -> gPair (gStr (var_to_string v ^ "-size"), (g_size (gVar v)))) bound_generators in *)
  (* let collect_sizes concl = List.fold_right (fun size_pair acc -> g_collect size_pair acc) var_sizes concl in *)
  let checked_concl = g_checker ( (decide ((gType' [] concl)))) in
  (* let tyche_checked_concl = g_tyche_with_features (gStr name) show_vars var_sizes check_concl in *)
  let a = bindForAlls bound_generators (check_remaining_inductives checked_inductives checked_concl) in
  msg_debug (str "Constructed constrained generator" ++ fnl ());
  a

let construct_constrained_generator_idx env (theorem : dep_type) (idx : int) : coq_expr =
  let all_bindings = (makeAllBindings theorem) in
  let (_,concl) = dep_type_hyps_and_concl theorem in
  match List.nth_opt all_bindings idx with
  | None -> failwith "Index out of bounds"
  | Some (bindings, checked_inductives) -> construct_constrained_generator' "test" env bindings checked_inductives concl

let rec fully_generalised (dt : dep_type) : bool =
  match dt with
  | DProd ((_,_),body) -> fully_generalised body
  | DArrow (x,y) -> fully_generalised x && fully_generalised y
  | DCtr (_,_) -> false
  | DTyCtr (_, ds) -> List.for_all fully_generalised ds
  | DApp (_, _) -> false
  | _ -> true

(*Create a version of derive_and_quickchick that takes an index and chooses the generator indexed by that number.*)
let derive_and_quickchick_index i =
  Proofview.Goal.enter_one begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    
    match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
        let open GenericLib in 
        msg_debug (str "Validating that all arguments to inductives are fully generalised" ++ fnl ());
        if not (fully_generalised dt) then (msg_debug (str "Not fully generalised" ++ fnl ()); Tacticals.tclIDTAC) else begin
        msg_debug (str "Checking for generators" ++ fnl ());
        let e' = Global.env () in
        let constrained_gen = construct_constrained_generator_idx e' dt i in
        debug_coq_expr constrained_gen;
        msg_debug (str "After constrained generator" ++ fnl ());
        let updated_env = Global.env () in
        let updated_evd = Evd.from_env updated_env in
        msg_debug (str "Running QuickCheck" ++ fnl ());
        let to_run = GenericLib.interp_open_coq_expr updated_env updated_evd (g_show (g_quickCheck constrained_gen)) in
        let updated_env' = Global.env () in
        let updated_evd' = Evd.from_env updated_env' in
        QuickChick.define_and_run to_run updated_env' updated_evd';
        Tacticals.tclIDTAC
        end 
      end
    | None -> failwith "Failed to Parse type"
  end

let derive_index idx =
  Proofview.Goal.enter_one begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
        msg_debug (str "Validating that all arguments to inductives are fully generalised" ++ fnl ());
        if not (fully_generalised dt) then (msg_debug (str "Not fully generalised" ++ fnl ()); Tacticals.tclIDTAC) else begin
        debug_coq_expr (construct_constrained_generator_idx e dt idx);
        msg_debug (str "After constrained generator: " ++ str (string_of_int idx) ++ fnl ());
        Tacticals.tclIDTAC
        end
      end
    | None -> failwith "Failed to Parse type"
  end

let quickchick_goal =
  Proofview.Goal.enter begin fun gl ->

    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
(*
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif
 *)  
  match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
        let open GenericLib in 
        let decide prop = decOptToBool (g_decOpt prop (gInt decOpt_fuel)) in
        let rec mkProperty = function
          | DProd ((var, _),body) -> 
              g_forAll g_arbitrary (gFun [var_to_string var] (fun [_] ->
                mkProperty body
                )) 
          | DArrow (x,y) -> GenericLib.debug_coq_expr (gType' [] x); gIf (decide (gType' [] x)) (mkProperty y) (g_checker gTT)
          | p -> g_checker (decide (gType' [] p)) 
              in     
        GenericLib.debug_coq_expr (mkProperty dt);
        (*run the generator called checker using QuickCheck.*)
        let to_run = GenericLib.interp_open_coq_expr e evd (g_show (g_quickCheck (mkProperty dt))) in
#if COQ_VERSION >= (8, 20, 0)
        (* FRAGILE probably won't be allowed in the future? *)
        let opaque_access = Library.indirect_accessor[@@warning "-3"] in
        QuickChick.define_and_run ~opaque_access to_run e evd;
#else
        QuickChick.define_and_run to_run e evd;
#endif

        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end
(*Create dependency graph, anything that lacks a dependency, print becuase we need it to *)
(*    
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in

    Printf.printf "So far so good\n"; flush stdout;
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif

    (* Construct : show (quickCheck (_ : ct)) *)
    let  qct = CAst.make @@ Constrexpr.CApp (QuickChick.quickCheck, [ct, None]) in
    let sqct = CAst.make @@ Constrexpr.CApp (QuickChick.show, [(qct,None)]) in

    Printf.printf "So far so good2\n"; flush stdout;

    (* From here on I've tried a couple of things. 
       Calling run_test directly with qct. Fails.
       Internalize here before calling define and run, fails.

       It always seems to fail in the 'interp' phase, with an 
       unknown existential variable error. So I'm probably doing something
       stupid with the evar maps *)
    let evd, to_run = Constrintern.interp_open_constr e evd sqct in

    Printf.printf "So far so good 2.5\n"; flush stdout;
    
    QuickChick.define_and_run to_run e evd;

    Printf.printf "So far so good3\n"; flush stdout;

    (* TODO: This whole block doesn't look very monadic... *)
    Tacticals.tclIDTAC
  end

    (*
    (* Admit a constant with that type *)
    let tmpid = QuickChick.fresh_name "temporary_constant" in
    let _interp_st = Vernacentries.interp (CAst.make @@ Vernacexpr.VernacExpr ([],
      (* TODO: NoDischarge or DoDischarge? *)
      Vernacexpr.VernacAssumption ((NoDischarge, Decl_kinds.Conjectural),
                        NoInline,
                        [
                          (false,
                           (
                             [CAst.make tmpid, None]
                           ,
                             ct
                           )
                          )
                        ]
                       ))) in

    let s = QuickChick.runTest @@ CAst.make @@
      Constrexpr.CApp (QuickChick.quickCheck, [CAst.make @@ CRef (Libnames.qualid_of_ident tmpid,None), None]) in
    (* I need to create an existential of type Checkable ct, and then
       call QuickChick.quickChick on that in the ast, before running
       QuickChick.runTest on the constr_expr. *)

    
    (*

       HACK (there *has* to be a better way): 
         (\x : Checkable ct -> x) _ *)

    let base = Names.Id.of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in

    let binder_list = [CLocalAssum ([CAst.make @@ Names.Name xid], Default Explicit, ct)]  in
    let f_body = CAst.make @@ CRef (CAst.make @@ Libnames.Ident xid,None) in
    let f = mkCLambdaN binder_list f_body in
    let hack_value = mkAppC (f , [ CAst.make @@ CEVarHole (None, Misctypes.IntroAnonymous, None) ] ) in
     *)
(*

    (* Refactor - needs to see internals... *)
    let base = Names.id_of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in


    let f_body = mkAppC (QuickChick.show, [mkAppC (QuickChick.quickCheck, [mkAppC (QuickChick.mk_ref "checker", [ CRef (Ident ((Loc.dummy_loc, xid)),None) ])])]) in
    let f = mkCLambdaN Loc.dummy_loc bind_list f_body in

    let env = Global.env () in
    let evd = Evd.from_env env in
    let (cf,evd) = Constrintern.interp_constr env evd f in

    let actual_term = Constr.mkApp (cf, Array.of_list [c]) in
 *)



(*
    let concl = Proofview.Goal.concl gl in
    let sigma = Tacmach.project gl in
    let hyps = named_context_val (Proofview.Goal.env gl) in
    let store = Proofview.Goal.extra gl in
    let env = Proofview.Goal.env gl in
    let () = if check && mem_named_context_val id hyps then
      errorlabstrm "Tactics.introduction"
        (str "Variable " ++ pr_id id ++ str " is already declared.")
    in
    match kind_of_term (whd_evar sigma concl) with
    | Prod (_, t, b) -> unsafe_intro env store (LocalAssum (id, t)) b
    | LetIn (_, c, t, b) -> unsafe_intro env store (LocalDef (id, c, t)) b
    | _ -> raise (RefinerError IntroNeedsProduct)
  end
 *)

*)

let theorem_dependencies = 
  Proofview.Goal.enter begin fun gl ->
    
    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in

    match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
        let open GenericLib in
        let rec printlist : (var * (int * int) list) list -> unit = function
          | [] -> ()
          | (var, rels) :: rest ->
            let tuple_to_string (i,j) = "(" ^ string_of_int i ^ ", " ^ string_of_int j ^ ")" in
            msg_debug (str (var_to_string var) ++ str " : " ++ str (String.concat ", " (List.map (fun i -> (tuple_to_string i)) rels)) ++ fnl ());
            printlist rest
        in
        printlist (dep_type_var_relation_uses dt);          
        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end

let print_typeclass_bindings d c =
  let open GenericLib in
  let string_of_bool' = function
    | true -> "true"
    | false -> "false" in
  let the_type = c |> Names.Id.to_string |> injectCtr |> ctr_to_ty_ctr in
  let the_typeclass = Names.Id.to_string d in
  let bindings = find_typeclass_bindings the_typeclass the_type in
  let show_bindings = List.map (List.map string_of_bool') bindings 
                    |> List.map (String.concat "; ") 
                    |> List.map (fun s -> "[" ^ s ^ "]")
                    |> (String.concat ", ") in
  let bracket_bindings = "{" ^ show_bindings ^ "}" in
  msg_debug (str bracket_bindings ++ fnl ());
  Tacticals.tclIDTAC

}
TACTIC EXTEND quickchick
  | ["quickchick"] -> { quickchick_goal }
END

TACTIC EXTEND print_all_bindings 
  | ["print_all_bindings"] -> { print_bindings_tactic }
END

TACTIC EXTEND valid_bindings
  | ["valid_bindings"] -> { valid_bindings }
END

TACTIC EXTEND typeclass_bindings
  | ["typeclass_bindings" ident(d) ident(c)] -> { print_typeclass_bindings d c }
END

TACTIC EXTEND derive_and_quickchick_index
  | ["derive_and_quickchick_index" int(i)] -> { derive_and_quickchick_index i }
END

TACTIC EXTEND derive_index
  | ["derive_index" int(i)] -> { derive_index i }
END

TACTIC EXTEND theorem_dependencies
  | ["theorem_dependencies"] -> { theorem_dependencies }
END

TACTIC EXTEND merge_sound_core
  | ["merge_sound_core"] -> { merge_sound }
END

TACTIC EXTEND remember_induct
  | ["remember_induct" ident(h)] -> { remember_induct h }
END

VERNAC COMMAND EXTEND DeriveUsedInds CLASSIFIED AS SIDEFF
   | ["Derive" "Used" "Inds" constr(ind)] ->
    { match coerce_reference_to_dep_dt ind with
      | Some (ind_name,_,_,_) ->
        print_type_names (seek_ind_types_from_overall_type ind_name) 
      | None -> failwith "Failed to parse inductive type"  
    }
END

VERNAC COMMAND EXTEND DeriveDensity CLASSIFIED AS SIDEFF
   | ["Derive" "Density" constr(ind) int_list(ois)] ->
    { match coerce_reference_to_dep_dt ind with
    | Some dt -> ignore (final_density dt ois true)
    | None -> failwith "Failed to parse inductive type" 
    }
END