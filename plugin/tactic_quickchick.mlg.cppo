{
(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

  open Ltac_plugin
  open Error
  open Pp
  open Stdarg
  (* open Declare *)

}

DECLARE PLUGIN "coq-quickchick.plugin"

{
let merge_sound =
  let rec get_hyps (s : Evd.evar_map) (c : EConstr.constr) =
    if EConstr.isProd s c then
      let (x,t1,t2) = EConstr.destProd s c in
      (x,t1) :: get_hyps s t2
    else []
  in 
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let s = Proofview.Goal.sigma gl in
    let to_intro = get_hyps s c in
    let rec calc_ids acc opts =
      match opts with
      | [] -> begin match acc with
              | to_ind::rest -> (to_ind, List.rev acc)
              | _ -> failwith "No product/merge_sound"
              end
      | (nb,_) :: nbs ->
         begin match Context.binder_name nb with
         | Names.Name id -> calc_ids (id :: acc) nbs
         | Names.Anonymous -> calc_ids (Names.Id.of_string "H" :: acc) nbs
         end in
    match calc_ids [] to_intro with
    | (_to_induct, opts) ->
       Tactics.intros_using_then opts (fun ids ->
           Tacticals.tclTHENLIST
             [ Tacticals.onLastHyp Tactics.simplest_elim
             ; Tactics.intros 
         ])
  end;;

let remember_induct h =
  Proofview.Goal.enter begin fun gl ->
    let s = Proofview.Goal.sigma gl in
    let env = Proofview.Goal.env gl in
    let cn = EConstr.mkVar h in
    Tacticals.tclTYPEOFTHEN cn (fun evm ct -> 
        msg_debug (str "Here: " ++ Printer.pr_constr_env env s (EConstr.to_constr s ct) ++ fnl());
        let to_remember = 
          if EConstr.isApp s ct then begin
              let (ctr, cs) = EConstr.destApp s ct in
              let to_remember = ref [] in
              Array.iter (fun cx ->
                  if EConstr.isApp s cx then
                    to_remember := cx :: !to_remember
                  else if EConstr.isConstruct s cx then
                    to_remember := cx :: !to_remember
                  else msg_debug (str "All good" ++ fnl ())) cs;
              !to_remember
            end
          else failwith "Not App" in
        let eqpat = CAst.make @@ Namegen.IntroAnonymous in 
        let cl =
          { Locus.onhyps = None
          ; Locus.concl_occs = Locus.AllOccurrences } in 
        let rec do_remembers (pats : EConstr.constr list) =
          match pats with
          | [] ->
#if COQ_VERSION >= (8, 19, 0)
            Induction.induction false None cn None None
#else
            Tactics.induction false None cn None None
#endif
          | p :: ps ->
             Tacticals.tclTHEN
#if COQ_VERSION >= (8, 18, 0)             
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (Some s, p) cl)
#else
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (s, p) cl)
#endif                 
                   (do_remembers ps) in
        msg_debug (int (List.length to_remember) ++ fnl ());
        do_remembers to_remember
      )
    end 

let quickchick_goal = Tacticals.tclIDTAC;;
 (* Proofview.Goal.enter begin fun gl ->

    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
(*
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif
 *)  
  match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
        let open NewGenericLib in 
        let decide prop = decOptToBool (g_decOpt prop (gInt 1000)) in
        let rec mkProperty = function
          | DProd ((var, _),body) -> 
              g_forAll g_arbitrary (gFun [var_to_string var] (fun [_] ->
                mkProperty body
                )) 
          | DArrow (x,y) -> NewGenericLib.debug_coq_expr (gType' [] x); gIf (decide (gType' [] x)) (mkProperty y) (g_checker gTT)
          | p -> g_checker (decide (gType' [] p)) 
              in
          
     (*     | DArrow (DTyCtr (tyctr, args), y) -> gIf (decide )
          | DTyParam typaram -> gTyParam typaram
          | DTyCtr (tyctr, args) -> gApp (gTyCtr tyctr) (List.map mkProperty args)
          | DCtr (ctr, args) -> gApp (gCtr ctr) (List.map mkProperty args)
          | DTyVar var -> gVar var
          | DApp (f, args) -> gApp (mkProperty f) (List.map mkProperty args)
          | DNot p -> *)
(*Use decOpt, for every arrow, assume instacne exists and match on it *)
            
        NewGenericLib.debug_coq_expr (mkProperty dt);
        (*run the generator called checker using QuickCheck.*)
        (*failwith "OUch!";*)
        let to_run = NewGenericLib.interp_open_coq_expr e evd (g_show (g_quickCheck (mkProperty dt))) in
        (*failwith "Oucher!";*)
#if COQ_VERSION >= (8, 20, 0)
        (* FRAGILE probably won't be allowed in the future? *)
        let opaque_access = Library.indirect_accessor[@@warning "-3"] in
        QuickChick.define_and_run ~opaque_access to_run e evd;
#else
        QuickChick.define_and_run to_run e evd;
#endif

        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end*)
(*Create dependency graph, anything that lacks a dependency, print becuase we need it to *)
(*    
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in

    Printf.printf "So far so good\n"; flush stdout;
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif

    (* Construct : show (quickCheck (_ : ct)) *)
    let  qct = CAst.make @@ Constrexpr.CApp (QuickChick.quickCheck, [ct, None]) in
    let sqct = CAst.make @@ Constrexpr.CApp (QuickChick.show, [(qct,None)]) in

    Printf.printf "So far so good2\n"; flush stdout;

    (* From here on I've tried a couple of things. 
       Calling run_test directly with qct. Fails.
       Internalize here before calling define and run, fails.

       It always seems to fail in the 'interp' phase, with an 
       unknown existential variable error. So I'm probably doing something
       stupid with the evar maps *)
    let evd, to_run = Constrintern.interp_open_constr e evd sqct in

    Printf.printf "So far so good 2.5\n"; flush stdout;
    
    QuickChick.define_and_run to_run e evd;

    Printf.printf "So far so good3\n"; flush stdout;

    (* TODO: This whole block doesn't look very monadic... *)
    Tacticals.tclIDTAC
  end

    (*
    (* Admit a constant with that type *)
    let tmpid = QuickChick.fresh_name "temporary_constant" in
    let _interp_st = Vernacentries.interp (CAst.make @@ Vernacexpr.VernacExpr ([],
      (* TODO: NoDischarge or DoDischarge? *)
      Vernacexpr.VernacAssumption ((NoDischarge, Decl_kinds.Conjectural),
                        NoInline,
                        [
                          (false,
                           (
                             [CAst.make tmpid, None]
                           ,
                             ct
                           )
                          )
                        ]
                       ))) in

    let s = QuickChick.runTest @@ CAst.make @@
      Constrexpr.CApp (QuickChick.quickCheck, [CAst.make @@ CRef (Libnames.qualid_of_ident tmpid,None), None]) in
    (* I need to create an existential of type Checkable ct, and then
       call QuickChick.quickChick on that in the ast, before running
       QuickChick.runTest on the constr_expr. *)

    
    (*

       HACK (there *has* to be a better way): 
         (\x : Checkable ct -> x) _ *)

    let base = Names.Id.of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in

    let binder_list = [CLocalAssum ([CAst.make @@ Names.Name xid], Default Explicit, ct)]  in
    let f_body = CAst.make @@ CRef (CAst.make @@ Libnames.Ident xid,None) in
    let f = mkCLambdaN binder_list f_body in
    let hack_value = mkAppC (f , [ CAst.make @@ CEVarHole (None, Misctypes.IntroAnonymous, None) ] ) in
     *)
(*

    (* Refactor - needs to see internals... *)
    let base = Names.id_of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in


    let f_body = mkAppC (QuickChick.show, [mkAppC (QuickChick.quickCheck, [mkAppC (QuickChick.mk_ref "checker", [ CRef (Ident ((Loc.dummy_loc, xid)),None) ])])]) in
    let f = mkCLambdaN Loc.dummy_loc bind_list f_body in

    let env = Global.env () in
    let evd = Evd.from_env env in
    let (cf,evd) = Constrintern.interp_constr env evd f in

    let actual_term = Constr.mkApp (cf, Array.of_list [c]) in
 *)



(*
    let concl = Proofview.Goal.concl gl in
    let sigma = Tacmach.project gl in
    let hyps = named_context_val (Proofview.Goal.env gl) in
    let store = Proofview.Goal.extra gl in
    let env = Proofview.Goal.env gl in
    let () = if check && mem_named_context_val id hyps then
      errorlabstrm "Tactics.introduction"
        (str "Variable " ++ pr_id id ++ str " is already declared.")
    in
    match kind_of_term (whd_evar sigma concl) with
    | Prod (_, t, b) -> unsafe_intro env store (LocalAssum (id, t)) b
    | LetIn (_, c, t, b) -> unsafe_intro env store (LocalDef (id, c, t)) b
    | _ -> raise (RefinerError IntroNeedsProduct)
  end
 *)

*)

open NewGenericLib

let is_inductive' (ty_name : ty_ctr) : bool =
  let locate_result = Nametab.locate_all (ty_name) in
  List.exists (function
               | Names.GlobRef.IndRef _ -> true
               | _ -> false) locate_result

let get_inductive_name name : Names.inductive option =
  let locate_result = Nametab.locate_all (name) in
  List.find_map (function
  | Names.GlobRef.IndRef ind -> Some ind
  | Names.GlobRef.ConstructRef constructor -> Some (Names.inductive_of_constructor constructor)
  | _ -> None) locate_result
  
let rec extract_inductives_from_type (typ : rocq_constr) : Names.inductive list =
  match typ with
  | DTyCtr (c, args) | DCtr (c, args)->
    (match get_inductive_name c with
    | Some ind -> ind :: List.concat_map extract_inductives_from_type args
    | None -> msg_debug (str ("Inductive not found: " ^ ty_ctr_to_string c)); [])
  | DApp (f, args) -> extract_inductives_from_type f @ List.concat_map extract_inductives_from_type args
  | _ -> []

let rec extract_inductives_rocq_constr (dt : rocq_constr) : Names.inductive list =
  match dt with
  | DProd ((_, t), dt) -> extract_inductives_from_type t @ extract_inductives_rocq_constr dt
  | DArrow (t, dt) -> extract_inductives_from_type t @ extract_inductives_rocq_constr dt
  | DTyCtr _ -> extract_inductives_from_type dt
  | _ -> failwith "Rule hypotheses and conclusions must be inductive."

let rec extract_names_rocq_constr (dt : rocq_constr) : ty_ctr list =
  match dt with
  | DProd ((_, DTyCtr (c,_)), ty2) -> 
    if is_inductive' c then
      c :: extract_names_rocq_constr ty2
    else
      failwith ("Rule hypotheses and conclusions must be inductive 1. Found: " ^ ty_ctr_to_string c ^ " " ^ rocq_constr_to_string dt)
  | DProd ((_, DTyVar _), ty2) -> extract_names_rocq_constr ty2
  | DProd ((_, DTyParam _), ty2) -> extract_names_rocq_constr ty2
  | DArrow (DTyCtr (c,_), ty2) -> 
    if is_inductive' c then
      c :: extract_names_rocq_constr ty2
    else
      failwith ("Rule hypotheses and conclusions must be inductive 2. Found: " ^ ty_ctr_to_string c ^ " " ^ rocq_constr_to_string dt)
  | DArrow (_, ty2) -> extract_names_rocq_constr ty2
  | DTyCtr (_, _) -> []
  | _ -> failwith ("Rule hypotheses and conclusions must be inductive 3. " ^ rocq_constr_to_string dt)

let overall_type_inductive_names ((ind_name, params, rules, overall_type) : rocq_relation) : ty_ctr list =
  extract_names_rocq_constr overall_type

let constructors_used_inductive_names ((ind_name, params, rules, overall_type) : rocq_relation) : ty_ctr list =
  remove_duplicates (List.concat_map (fun (cons, typ) -> extract_names_rocq_constr typ) rules)

let rocq_relation_used_inductives' ((ind_name, params, rules, overall_type) : rocq_relation) : Names.Indset.t =
  Names.Indset.of_list (extract_inductives_rocq_constr overall_type @ List.concat_map (fun (_,typ) -> extract_inductives_rocq_constr typ) rules)

let inductive_to_rocq_relation ((mind,ix) : Names.inductive) : rocq_relation =
  (* Lookup the mutual inductive body in the _global_ environment. *)
  let mib = Environ.lookup_mind mind (Global.env ()) in
  (* Parse each `one_inductive_body` into a rocq relation. All should succeed. *)
  let rs = sequenceM oib_to_rocq_relation (Array.to_list mib.Declarations.mind_packets) in
  match rs with
  | None -> failwith ("Inductive not found: " ^ Names.MutInd.to_string mind)
  | Some rs -> List.nth rs ix

let inductives_used_in_inductive (ind : Names.inductive) : Names.Indset.t =
  let rocq_relation = inductive_to_rocq_relation ind in
  Names.Indset.add ind (rocq_relation_used_inductives' rocq_relation)

let ty_ctr_to_rocq_relation (tycon : ty_ctr) =
  match ty_ctr_to_rocq_relations tycon with
  | None -> failwith ("Inductive not found: " ^ ty_ctr_to_string tycon)
  | Some (idx, rels) -> try (List.nth rels idx) with _ -> failwith ("Inductive not found (nth failed in ty_ctr_to_rocq_relation): " ^ ty_ctr_to_string tycon)
  
let seek_ind_types_from_overall_type root : ty_ctr list =
  let rec seek_ind_types ind_name visited : ty_ctr list =
    if List.mem ind_name visited then
      visited 
    else
      let rocq_relation = ty_ctr_to_rocq_relation ind_name in
      let used_inds = constructors_used_inductive_names rocq_relation in
      List.fold_left (fun visited' ind_name' -> seek_ind_types ind_name' visited') (ind_name :: visited) used_inds
    in
  let rocq_relation = ty_ctr_to_rocq_relation root in
  let used_inds = overall_type_inductive_names rocq_relation in
  
  List.fold_left (fun visited' ind_name' -> seek_ind_types ind_name' visited') [root] used_inds

let seek_rocq_relations root : rocq_relation list =
  let rec seek_ind_types ind_name visited : rocq_relation Names.Indmap.t =
    if Names.Indmap.mem ind_name visited then
      visited 
    else
      let rocq_relation = inductive_to_rocq_relation ind_name in
      let used_inds = rocq_relation_used_inductives' rocq_relation in
      Names.Indset.fold (fun ind_name' visited'  -> seek_ind_types ind_name' visited') used_inds (Names.Indmap.add ind_name rocq_relation visited)
    in
  let map = seek_ind_types root Names.Indmap.empty in
  List.map snd (Names.Indmap.bindings map)

let print_type_names (inds : ty_ctr list) : unit =
  List.iter (fun ind -> msg_debug (str (ty_ctr_to_string ind) ++ fnl ())) inds

let seek_all_rocq_relation root_ind_name : rocq_relation list =
  List.map (fun name -> ty_ctr_to_rocq_relation name) (seek_ind_types_from_overall_type root_ind_name)

type constraint_type = FunConstraint | ConConstraint | FunConConstraint

type constrained_arg =
  | Constrained of var list * constraint_type
  | Unconstrained of var

type ind = ty_ctr * rocq_constr list
  
type constrained_ind =  ty_ctr * constrained_arg list 

let constrain_check_ind ((ind_ctr, ind_args) : ind) : constrained_ind =
  let rec collect_vars (ct : rocq_constr) : var list =
    match ct with
    | DTyParam p -> [p]
    | DTyVar p -> [p]
    | DTyCtr (c, args) -> List.concat_map collect_vars args
    | DCtr (c, args) -> List.concat_map collect_vars args
    | DApp (f, args) -> collect_vars f @ List.concat_map collect_vars args
    | _ -> failwith "Inductive arguments must be constructors or params." in

  let rec contains_constructor = function
    | DTyCtr (_, _) | DCtr (_, _) -> true
    | DApp (f, args) -> contains_constructor f || List.exists contains_constructor args
    | _ -> false in

  let rec contains_application = function
    | DTyCtr (_, args) -> List.exists contains_application args
    | DCtr (_, args) -> List.exists contains_application args
    | DApp (_, _) -> true
    | _ -> false in

  let check_constraints (ct : rocq_constr) : constrained_arg =
    match ct with
    | DTyParam p | DTyVar p -> Unconstrained p 
    | _ ->
      let contains_constructor = contains_constructor ct in
      let contains_application = contains_application ct in
      if contains_constructor && contains_application then
        Constrained (collect_vars ct, FunConConstraint)
      else if contains_constructor then
        Constrained (collect_vars ct, ConConstraint)
      else if contains_application then
        Constrained (collect_vars ct, FunConstraint)
      else
        failwith ("Inductive arguments must be constructors or params. This is not: " ^ rocq_constr_to_string ct) in
  (ind_ctr, List.map check_constraints ind_args)

type arity = int

type output_index = int

type rule = ty_ctr * constructor * arity * constrained_ind list * constrained_ind

let rec rocq_constr_arity = function
  | DProd ((_, _), t2) -> 1 + rocq_constr_arity t2
  | DArrow (_, y) -> 1 + rocq_constr_arity y
  | _ -> 0

let rocq_relation_arity ((ind_name, params, rules, overall_type) : rocq_relation) : int =
  match rules with
  | [] -> rocq_constr_arity overall_type
  | (cname, ctype) :: xs -> 
    (match type_info ctype with
    | (_,_,DTyCtr (ind, args)) -> List.length args
    | _ -> failwith "Rule hypotheses and conclusions must be inductive.")

let types_to_constructor_lookup (types : rocq_relation list) : (constructor * (constructor * arity) list) list =
  let rocq_relation_collect_constructors ((ind_name, params, rules, overall_type) : rocq_relation) : (constructor * arity) list =
    List.map (fun (name, typ) -> (name, rocq_constr_arity typ)) rules in
  let constructor_to_constructors_map (a : ('a * 'b) list) : ('a * ('a * 'b) list) list =
    List.map (fun (x,_) -> (x, a)) a in
  List.concat_map (fun ind_rules -> constructor_to_constructors_map (rocq_relation_collect_constructors ind_rules)) types

type constructor_map = (constructor * (constructor * arity) list) list

let eq_basename c1 c2 = Libnames.qualid_basename c1 = Libnames.qualid_basename c2
let eq_tyctr_basename c1 c2 = ty_ctr_basename c1 = ty_ctr_basename c2

let find_type (c : constructor) (types : constructor_map) : (constructor * arity) list =
  let rec assoc_opt_eq c l eq = match l with
    | [] -> None
    | (a, b) :: l -> if eq a c then Some b else assoc_opt_eq c l eq in 
  match assoc_opt_eq c types eq_basename with
  | None -> failwith ("Constructor not found: " ^ constructor_to_string c ^ " map: " ^ List.fold_left (fun acc (c, _) -> acc ^ ", " ^ constructor_to_string c) "" types)
  | Some cs ->
    msg_debug (str (List.fold_right (fun (c, a) acc -> constructor_to_string c ^ " " ^ string_of_int a ^ ", " ^ acc) cs "") ++ fnl ());
      cs 

type pattern =
| PCtr of constructor * pattern list
| PWild

let rec string_of_pattern = 
  function
  | PCtr (c, []) -> constructor_to_string c
  | PCtr (c, p :: ps) -> 
    let cstr = constructor_to_string c in
    (if cstr = "Tuple_" then "" else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
  | PWild -> "_"

let tuple_name = ty_ctr_of_string "Tuple_"

let rec map_maybe f = function
  | [] -> []
  | x :: xs -> 
    (match f x with
    | None -> map_maybe f xs
    | Some y -> y :: map_maybe f xs)

(*Gets patterns from conclusion of constructor*)
let pattern_of_rocq_ctr (ctr : rocq_ctr) : constructor * pattern =
  let rec pattern_args = function
    | DCtr (c, args) -> Some (PCtr (c, map_maybe pattern_args args))
    | DApp (DTyVar f, args) -> Some PWild
    | DTyVar _ -> Some PWild
    | DTyParam _ -> Some PWild
    | DTyCtr (_,_) -> None (*Type argument*)
    | a -> failwith ("Argument to " ^ constructor_to_string (fst ctr) ^ " must be constructors or function applications or variables. Found: " ^ rocq_constr_to_string a) in
  let rec pattern_of_rocq_constr = function
    | DProd ((_, _), t2) -> pattern_of_rocq_constr t2
    | DArrow (_, y) -> pattern_of_rocq_constr y
    | DTyCtr (ind, args) -> PCtr (tuple_name, map_maybe pattern_args args)
    | a -> failwith ("Rule hypotheses and conclusions must be inductive: " ^ rocq_constr_to_string a) in
  let (name, ctr_typ) = ctr in
  msg_debug (str (rocq_constr_to_string ctr_typ) ++ fnl ());
  (name, pattern_of_rocq_constr ctr_typ)

let input_pattern_of_rocq_ctr (ctr : rocq_ctr) (ois : output_index list) : constructor * pattern =
  let (cons, PCtr (_,patterns)) = pattern_of_rocq_ctr ctr in
  let wildcard_indices ois patterns = List.mapi (fun i p -> if List.mem i ois then PWild else p) patterns in
  (cons, PCtr (tuple_name, wildcard_indices ois patterns))

let input_patterns_of_rocq_relation ((ind_name, params, rules, overall_type) : rocq_relation) (ois : output_index list) : (constructor * pattern) list =
  List.map (fun ctr -> input_pattern_of_rocq_ctr ctr ois) rules

(*Type of search trees*)
type pattern_coverage_tree =
  | PatternLeaf of pattern * constructor list 
    (*the pattern describes the least granular space needed to describe coverage at this point, and the list of rules which provide coverage to it, if any.*)
  | PatternNode of pattern * constructor list * int list * (constructor * pattern_coverage_tree) list (*The int list represents the path to the current wildcard thats being split*)

let print_decomposed_pattern (dec : (constructor * int * int list) list) : unit =
  msg_debug (str "Printing Decomposed Pattern" ++ fnl ());
  let string_of_dec (c, n, path) = constructor_to_string c ^ " " ^ string_of_int n ^ " :" ^ List.fold_left (fun acc i -> acc ^ ", " ^ string_of_int i) "" path in 
  List.iter (fun d -> msg_debug (str (string_of_dec d) ++ fnl ())) dec;
  msg_debug (str "Finished Decomposed Pattern" ++ fnl ())

let enumerate_list = List.mapi (fun i p -> p,i)

let rec decompose_pattern_path (p : pattern) (path : int list): (constructor * int * int list) list =
  match p with
  | PCtr (c, ps) -> 
      (c, List.length ps, path) :: List.concat_map (fun (p, i) -> decompose_pattern_path p (path @ [i])) (enumerate_list ps)
  | PWild -> []

let decompose_pattern (p : pattern) : (constructor * int * int list) list =
  let dec = decompose_pattern_path p [] in print_decomposed_pattern dec; msg_debug (fnl ()); dec

let rec apply_at (f : 'a -> 'a) (i : int) (l : 'a list) : 'a list =
  match l, i with
  | [], _ -> []
  | x :: xs, 0 -> f x :: xs 
  | x :: xs, i -> x :: apply_at f (i - 1) xs

let rec apply_lookup eq (f : 'a -> 'a) (i : 'i) (l : ('i * 'a) list) : ('i * 'a) list =
  match l with
  | [] -> []
  | (i', x) :: xs -> if eq i i' then (i', f x) :: xs else (i', x) :: apply_lookup eq f i xs

let rec insert_at_path (p : pattern) (path : int list) (c : constructor) wilds : pattern =
  match path with
  | [] -> PCtr (c, wilds)
  | i :: is -> 
      match p with
      | PCtr (c', ps) -> PCtr (c', apply_at (fun p' -> insert_at_path p' is c wilds) i ps)
      | PWild -> failwith "Path is too long"

let rec make_wilds n =
  if n > 0 then PWild :: make_wilds (n - 1)
  else [] 

let rec label_tree label ptree : pattern_coverage_tree =
  match ptree with
  | PatternLeaf (p, rules) -> PatternLeaf (p, label :: rules)
  | PatternNode (p, rules, path, branches) -> PatternNode (p, label :: rules, path, List.map (fun (c, p') -> (c, label_tree label p')) branches) 

let rec pattern_at_path (path : int list) (p : pattern) : pattern =
  match path with
  | [] -> p
  | i :: is ->
      match p with
      | PCtr (c, ps) -> pattern_at_path is (List.nth ps i)
      | PWild -> PWild  

let rec cover_single_pattern_layer (con : constructor)
    (path : int list) (pat_so_far : pattern) (p : pattern_coverage_tree) 
    (types : constructor_map) : pattern_coverage_tree =
  match p with
  | PatternLeaf (pat, rules)-> 
      let constructors = find_type con types in
      let new_pattern c arity = insert_at_path pat path c (make_wilds arity) in
      let new_pattern_leaves = List.map (fun (c, arity) -> c, PatternLeaf (new_pattern c arity, rules)) constructors in
      PatternNode (pat, rules, path, new_pattern_leaves)
  | PatternNode (pat, rules, path', branches)->
      if path = path' then 
        PatternNode (pat, rules, path', branches)
      else
        begin match pattern_at_path path' pat_so_far with
        | PWild -> 
            PatternNode (pat, rules, path', 
                         List.map (fun (c, p') -> (c, cover_single_pattern_layer con path pat_so_far p' types)) branches
                        )
        | PCtr (c, _) -> 
            PatternNode (pat, rules, path', 
                         apply_lookup eq_basename (fun p' -> cover_single_pattern_layer con path pat_so_far p' types) c branches
                        )
        end

let rec subpattern (sub : pattern) (pat : pattern) : bool =
  msg_debug (str ("sub: " ^ string_of_pattern sub ^ " | sup: " ^ string_of_pattern pat) ++ fnl ());
  match sub, pat with
  | _, PWild -> true
  | PWild, PCtr (c, ps) -> false
  | PCtr (subc, subps), PCtr (c, ps) -> 
    if eq_basename subc c then
      try (List.for_all2 (fun sub sup -> subpattern sub sup) subps ps) with Invalid_argument _ -> failwith "Patterns with same constructor have different argument count: subpattern"
    else false

let rec compatible_pattern (sub : pattern) (pat : pattern) : bool =
  match sub, pat with
  | _, PWild -> true
  | PWild, PCtr (c, ps) -> true
  | PCtr (subc, subps), PCtr (c, ps) ->
    if eq_basename subc c then
      try (List.for_all2 (fun sub sup -> compatible_pattern sub sup) subps ps) with Invalid_argument _ -> failwith "Patterns with same constructor have different argument count: compatible_pattern"
    else false

let rec label_subpatterns (rule_name : constructor) (pat : pattern) (pt : pattern_coverage_tree) : pattern_coverage_tree =
  match pt with
  | PatternLeaf (p, rules) -> if subpattern p pat then PatternLeaf (p, rule_name :: rules) else pt
  | PatternNode (p, rules, path, branches) ->
    msg_debug (str (constructor_to_string rule_name) ++ fnl ());
    if subpattern p pat then label_tree rule_name pt else
    if compatible_pattern p pat then
      PatternNode (p, rules, path, List.map (fun (c, p') -> (c, label_subpatterns rule_name pat p')) branches)
    else pt 

let rec cover_decomposed_pattern (pat_so_far : pattern) (dec : (constructor * int * int list) list) (p : pattern_coverage_tree) (types : constructor_map) : pattern_coverage_tree =
  match dec with
  | [] -> p
  | (c, n, path) :: rest ->
      let new_p = cover_single_pattern_layer c path pat_so_far p types in 
      let pat_so_far' = insert_at_path pat_so_far path c (make_wilds n) in
      cover_decomposed_pattern pat_so_far' rest new_p types

let pattern_tree_root : pattern_coverage_tree = PatternLeaf (PWild, [])

let cover_pattern' (rule_name : constructor) (p : pattern) (types : constructor_map) (ptree : pattern_coverage_tree) : pattern_coverage_tree =
  let dec = decompose_pattern p in
  label_subpatterns rule_name p (cover_decomposed_pattern PWild dec ptree types)

let cover_patterns (ps : (constructor * pattern) list) (types : constructor_map) root : pattern_coverage_tree =
  List.fold_left (fun ptree (c, p) -> cover_pattern' c p types ptree) root ps

let tuple_types arity = (tuple_name,[tuple_name,arity])

let cover_tuple_patterns ps arity types = cover_patterns ps (tuple_types arity :: types) pattern_tree_root

let rec map_patterns (f : pattern -> pattern) (tree : pattern_coverage_tree) : pattern_coverage_tree =
  let f' = function
    | PWild -> PWild
    | a -> f a in
  match tree with
  | PatternLeaf (p, cs) -> PatternLeaf (f' p, cs)
  | PatternNode (p, cs, path, branches) -> PatternNode (f' p, cs, path, List.map (fun (c, subtree) -> (c, map_patterns f' subtree)) branches) 

let print_coverage_tree (ind : ty_ctr) (tree : pattern_coverage_tree) (ois : output_index list) = 
  let replace_at_indices is x l = List.mapi (fun i y -> if List.mem i is then x else y) l in
  let insert_output_in_leaf (PCtr (c, ps)) = PCtr (c, replace_at_indices ois (PCtr (constructor_of_string "OUT",[])) ps) in
  let tree' = map_patterns insert_output_in_leaf tree in
  let rec string_of_pattern = 
    function
    | PCtr (c, []) -> constructor_to_string c
    | PCtr (c, p :: ps) -> 
      let cstr = constructor_to_string c in
      (if cstr = "Tuple_" then ty_ctr_to_string ind else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
    | PWild -> "_" in
  let string_of_constructors = function
    | [] -> "[]"
    | c :: cs -> "[" ^ constructor_to_string c ^ List.fold_left (fun acc c -> acc ^ "; " ^ constructor_to_string c) "" cs ^ "]" in
  let string_of_pattern_leaf (p, cs) = string_of_pattern p ^ " : " ^ string_of_constructors cs in
  let rec print_tree indent = function
    | PatternLeaf (p, cs) -> Feedback.msg_notice (str (String.make indent ' ' ^ string_of_pattern_leaf (p, cs)) ++ fnl ())
    | PatternNode (p, cs, path, branches) -> 
      Feedback.msg_notice (str (String.make indent ' ' ^ string_of_pattern p ^ " : " ^ string_of_constructors cs ) ++ fnl ());
      List.iter (fun (c, subtree) -> print_tree (indent + 2) subtree) branches
    in
  print_tree 0 tree'


(*Take in an inductive name and a rocq_ctr (a dependent constructor), and collect the hypotheses and conclusions*)
let rule_of_rocq_ctr ind_name (ctr : rocq_ctr) : rule =
  let (name, ctr_typ) = ctr in
  let rec hyp_conc = function
    | DProd ((_, _), t2) -> 
      let (hyps, conc, arity) = hyp_conc t2 in
      (hyps, conc, arity + 1)
    | DArrow (DTyCtr (ind, args), y) -> 
      let (hyps, conc, arity) = hyp_conc y in
      ((ind,args) :: hyps, conc, arity)
    | DArrow (DNot (DTyCtr (ind,args)),y) when eq_tyctr_basename ind (ty_ctr_of_string "Coq.Init.Logic.eq") ->  (* a <> b as a hypothesis affects the density little, 
                                                                                                     assuming a and b are independently generated.
                                                                                                     need to check for that later, for now, we just
                                                                                                     drop any <> hypothesis regardless of its args.*)
      let (hyps, conc, arity) = hyp_conc y in
      (hyps, conc, arity)
    | DTyCtr ((ind,args)) -> ([], (ind,args), 0)
    | _ -> failwith "Rule hypotheses and conclusions must be inductive." in 
  let (hyps, conc, arity) = hyp_conc ctr_typ in
  (ind_name, name, arity, List.map constrain_check_ind hyps, constrain_check_ind conc)

let rocq_relation_rules ((ind_name, params, rules, overall_type) : rocq_relation) : rule list =
  List.map (rule_of_rocq_ctr ind_name) rules

type rule_density = 
  | Checking
  | Backtracking
  | Partial
  | Total

let rec collect_leaves (tree : pattern_coverage_tree) : (pattern * constructor list) list =
  match tree with
  | PatternLeaf (p, cs) -> [(p,cs)]
  | PatternNode (_, _, _, branches) ->
      List.concat_map (fun (_, subtree) -> collect_leaves subtree) branches

let print_pattern_leaves (ind : ty_ctr) (tree : pattern_coverage_tree) (ois : output_index list) (densities : (constructor * rule_density) list) : unit =
  let rec string_of_pattern = 
    function
    | PCtr (c, []) -> constructor_to_string c
    | PCtr (c, p :: ps) -> 
      let cstr = constructor_to_string c in
      (if cstr = "Tuple_" then ty_ctr_to_string ind else cstr) ^ "(" ^ string_of_pattern p ^ List.fold_left (fun acc p -> acc ^ ", " ^ string_of_pattern p) "" ps ^ ")"
    | PWild -> "_" in
  let density_to_string = function
    | Checking -> "Checking"
    | Backtracking -> "Backtracking"
    | Partial -> "Partial" in
  let string_of_constructors = function
    | [] -> "[]"
    | (c,d) :: cs -> "[" ^ constructor_to_string c ^ ": " ^ density_to_string d ^ List.fold_left (fun acc (c,d) -> acc ^ "; " ^ constructor_to_string c ^ ": " ^ density_to_string d) "" cs ^ "]" in
  let string_of_pattern_leaf (p, cs) = string_of_pattern p ^ " : " ^ string_of_constructors cs in
  let replace_at_indices is x l = List.mapi (fun i y -> if List.mem i is then x else y) l in
  let insert_output_in_leaf (PCtr (c, ps), cs) = (PCtr (c, replace_at_indices ois (PCtr (constructor_of_string "OUT",[])) ps), cs) in
  let annotate_densities (p, cs) = (p, List.map (fun c -> (c, List.assoc c densities)) cs) in
  List.iter (fun (p, cs) -> Feedback.msg_notice (str (string_of_pattern_leaf (annotate_densities (insert_output_in_leaf (p, cs)))) ++ fnl ())) (collect_leaves tree)

let print_rule_densities (rs : (constructor * rule_density) list) : unit =
  let string_of_density = function
    | Checking -> "Checking"
    | Backtracking -> "Backtracking"
    | Partial -> "Partial" in
  List.iter (fun (c,d) -> Feedback.msg_notice (str (  constructor_to_string c ^ ": " ^ string_of_density d) ++ fnl ())) rs

let rec has_duplicates (lst : 'a list) : bool =
  match lst with
  | [] -> false
  | x :: xs -> List.mem x xs || has_duplicates xs

let remove_duplicates l =
  let rec remove_duplicates' l acc =
    match l with
    | [] -> acc
    | x :: xs -> if List.mem x acc then remove_duplicates' xs acc else remove_duplicates' xs (x :: acc) in
  remove_duplicates' l []

let print_duplicates lst  : string =
  Feedback.msg_notice (str (String.concat ", " (List.map var_to_string lst)) ++ fnl ());
  let rec print_duplicates' lst acc =
    match lst with
    | [] -> acc
    | x :: xs -> if List.mem x xs then print_duplicates' xs (acc ^ ", " ^ var_to_string x) else print_duplicates' xs acc in
  print_duplicates' lst ""

let not_pairwise_disjoint (xss : 'a list list) : bool =
  let sets = List.map remove_duplicates xss in
  if 
  has_duplicates (List.concat sets) 
  then
    (Feedback.msg_notice (str "Not pairwise disjoint: " ++ str (print_duplicates (List.concat sets)) ++ fnl ()); true)
  else false

let split_indices xs idxs =
  let rec go xs idxs i =
    match xs with
    | [] -> ([], [])
    | x :: xs -> 
      if List.mem i idxs then 
        let (inidx, outidx) = go xs idxs (i + 1) in
        (x :: inidx, outidx)
      else 
        let (ys, zs) = go xs idxs (i + 1) in
        (ys, x :: zs) 
    in
  go xs idxs 0

let density_to_string = function
  | Checking -> "Checking"
  | Backtracking -> "Backtracking"
  | Partial -> "Partial"
  | Total -> "Total"

let subsets (xs : 'a list) : 'a list list =
  let rec subsets' xs acc =
    match xs with
    | [] -> acc
    | x :: xs -> subsets' xs (List.map (fun ys -> x :: ys) acc @ acc) in
  subsets' xs [[]]

let has_intersection (xs : 'a list) (ys : 'a list) : bool =
  List.exists (fun x -> List.mem x ys) xs

module RelationInstOrd = struct
  type t = ty_ctr * output_index list * derive_sort
  let compare (ty, args, ds) (ty', args', ds') =
    match (get_inductive_name ty, get_inductive_name ty') with
    | (Some ty, Some ty') -> (match compare ty ty' with
                              | 0 -> (match compare args args' with
                                      | 0 -> compare ds ds'
                                      | c -> c)
                              | c -> c)
    | _ -> failwith ("RelationInstOrd: Inductive name not found in " ^ ty_ctr_to_string ty ^ " or " ^ ty_ctr_to_string ty')
end

module RelationInstMap = Map.Make(RelationInstOrd)

let density_memo : rule_density RelationInstMap.t ref = ref RelationInstMap.empty

let density_inductive_memo : (inductive_schedule * rule_density) RelationInstMap.t ref = ref RelationInstMap.empty

(*Three heuristics detecting difficult to generate rules*)
let rec is_output_constrained_in_hypothesis ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let output_index_hyps = List.concat_map (fun (ind, args) -> fst (split_indices args ois)) recursive_hyps in
  if List.exists (fun arg -> match arg with
    | Constrained _ -> true
    | Unconstrained _ -> false) output_index_hyps
    then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": output constrained in hypothesis") ++ fnl ()); true) else false

and is_output_hyps_require_unification ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let collect_vars = function
    | Constrained (args,_) -> args
    | Unconstrained arg -> [arg] in
  let output_index_hyps : ty_param list list = List.map (fun (ind,args) -> List.concat_map collect_vars (fst (split_indices args ois))) recursive_hyps in
  Feedback.msg_notice (str (String.concat ", " (List.map string_of_int ois)) ++ fnl ());
  if not_pairwise_disjoint output_index_hyps then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": output hyps require unification") ++ fnl ()); true) else false

and is_input_conclusion_require_unification ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let conclusion_args = snd conc in
  let (_,input_conc_args) = split_indices conclusion_args ois in
  let collect_vars = function
    | Constrained (args,_) -> args
    | Unconstrained arg -> [arg] in
  let all_input_conc_vars = List.concat_map collect_vars input_conc_args in
  if has_duplicates all_input_conc_vars then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": input conc requires unification") ++ fnl ()); true) else false

and are_functions_constraining_conclusion_inputs_or_hyp_outputs ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let conclusion_args = snd conc in
  let (_,input_conc_args) = split_indices conclusion_args ois in
  let fun_constrained = function
    | Constrained (args, FunConstraint) | Constrained (args, FunConConstraint) -> true
    | _ -> false in
  if List.exists fun_constrained input_conc_args then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": functions constrain conclusion inputs") ++ fnl ()); true) else
  let recursive_hyps = List.filter (fun (ind, args) -> ind = ind_name) hyps in
  let output_index_hyps : constrained_arg list list = List.map (fun (ind, args) -> fst (split_indices args ois)) recursive_hyps in
  if List.exists (fun args -> List.exists fun_constrained args) output_index_hyps then (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": functions constrain hypothesis outputs") ++ fnl ()); true) else false

and nonrecursive_disjoint_strictly_output_vars ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : (ty_ctr * (output_index * ty_param) list) list =
  let (conclusion_output_args,conclusion_input_args) = split_indices (snd conc) ois in
  let args_to_vars arg_list = List.concat_map (function Constrained (args,_) -> args | Unconstrained arg -> [arg]) arg_list in
  let conclusion_output_vars = args_to_vars conclusion_output_args in
  let conclusion_input_vars = args_to_vars conclusion_input_args in
  let (nonrecursive_hyps, recursive_hyps) = List.partition (fun (ind, args) -> ind <> ind_name) hyps in
  let recursive_output_vars = List.concat_map (fun (ind, args) -> args_to_vars (fst (split_indices args ois))) recursive_hyps in
  let nonrecursive_output_vars = List.map (fun (ind, args) -> 
    let numbered_args = List.mapi (fun i arg -> (i, arg)) args in
    let unconstrained_vars = List.concat_map (function (n,Unconstrained arg) -> [(n,arg)] | _ -> []) numbered_args in
    let unconstrained_output_vars = List.filter (fun (_,v) -> List.mem v conclusion_output_vars) unconstrained_vars in
    let unconstrained_output_noninput_vars = List.filter (fun (_,v) -> not (List.mem v conclusion_input_vars)) unconstrained_output_vars in
    let unconstrained_disjoint_output_noninput_vars = List.filter (fun (_,v) -> not (List.mem v recursive_output_vars)) unconstrained_output_noninput_vars in
    ind,unconstrained_disjoint_output_noninput_vars) nonrecursive_hyps in
  nonrecursive_output_vars
  
and filter_nonrecursive_empty_densities (nonrecurse : (ty_ctr * (output_index * ty_param) list)) =
  let (ind, output_vars) = nonrecurse in
  let rocq_relation = ty_ctr_to_rocq_relation ind in
  let output_subsets = subsets output_vars in
  let filtered_ovars = List.filter_map (fun ois_vars ->
    let density = final_density rocq_relation (List.map fst ois_vars) false D_Gen in
    match density with
    | Checking -> None
    | Backtracking | Partial | Total -> Some (ois_vars, density)) output_subsets in
  ind,filtered_ovars

and nonrecursive_binding (nonrecursives : (ty_ctr * ((output_index * ty_param) list * rule_density) list) list) : ((ty_ctr * (output_index * ty_param) list * rule_density) list) option =
  match nonrecursives with
  | [] -> Some []
  | (ind, []) :: rest -> None
  | (ind, (oi_vs,Partial) :: ovars) :: rest ->
    let updated_rest = List.map (fun (ind, ovars) -> (ind, List.filter (fun (oi_vs',_) -> not (has_intersection oi_vs oi_vs')) ovars)) rest in
    (match nonrecursive_binding updated_rest with
    | None -> nonrecursive_binding ((ind, ovars) :: rest)
    | Some bindings -> Some ((ind, oi_vs, Partial) :: bindings))
  | (ind, (oi_vs,Backtracking) :: ovars) :: rest -> 
    let updated_rest = List.map (fun (ind, ovars) -> (ind, List.filter (fun (oi_vs',_) -> not (has_intersection oi_vs oi_vs')) ovars)) rest in
    (match nonrecursive_binding ((ind,ovars) :: rest) with
     | Some ((ind',oi_vs',Partial) :: bindings) -> Some ((ind', oi_vs', Partial) :: bindings)
     | _ -> (match nonrecursive_binding updated_rest with | None -> None | Some bindings -> Some ((ind, oi_vs, Backtracking) :: bindings)) 
    )
    
and is_nonrecursive_checked_or_overlapping_or_empty ((ind_name, ctr_name, arity, hyps, conc) : rule) (ois : output_index list) : bool =
  let nonrecursive_output_vars = nonrecursive_disjoint_strictly_output_vars (ind_name, ctr_name, arity, hyps, conc) ois in
  let filtered_nonrecursive_output_vars = List.map filter_nonrecursive_empty_densities nonrecursive_output_vars in
  match nonrecursive_binding filtered_nonrecursive_output_vars with
  | None -> (Feedback.msg_notice (str (constructor_to_string ctr_name ^ ": >= 1 nonrecursive bindings must be checked") ++ fnl ()) ; true)
  | Some [] -> false
  | Some bindings -> 
    Feedback.msg_notice (str "Printing nonrecursive bindings for: " ++ str (constructor_to_string ctr_name) ++ fnl ()); 
    List.iter (fun (ind, oi_vs, density) -> Feedback.msg_notice (str (ty_ctr_to_string ind ^ " argument #s: " ^ String.concat "," (List.map (fun (o,_) -> string_of_int o) oi_vs) ^ "; var names: " ^ String.concat "," (List.map (fun (_,v) -> ty_param_to_string v) oi_vs) ^ "; density: " ^ density_to_string density) ++ fnl ())) bindings;
    false (*In the future these bindings should be output and prederived.*)

and analyze_rule (r : rule) (ois : output_index list) : rule_density =
  msg_debug (str (List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());
  if is_output_hyps_require_unification r ois 
    || is_input_conclusion_require_unification r ois
    || are_functions_constraining_conclusion_inputs_or_hyp_outputs r ois
    || is_nonrecursive_checked_or_overlapping_or_empty r ois 
  then 
    Checking 
  else if is_output_constrained_in_hypothesis r ois then
    Backtracking
  else 
    Partial

and analyze_rules (rs : rule list) ois : (constructor * rule_density) list =
  List.map (fun (ind, cons, arity, hyps, conc) -> (cons, analyze_rule (ind, cons, arity, hyps, conc) ois)) rs

and final_density (dt : rocq_relation) ois (should_print : bool) (ds : derive_sort) : rule_density =
  let (ind_name, _, _, _) = dt in
  if RelationInstMap.mem (ind_name, ois, ds) !density_memo then RelationInstMap.find (ind_name, ois, ds) !density_memo
  else
  let inductive = (match get_inductive_name ind_name with | Some i -> i | None -> failwith "final_density: not an inductive type") in
  let tree = cover_tuple_patterns (input_patterns_of_rocq_relation dt ois) (rocq_relation_arity dt) (types_to_constructor_lookup (seek_rocq_relations inductive)) in
  let covered_patterns = collect_leaves tree in
  let densities = analyze_rules (rocq_relation_rules dt) ois in
  if should_print then (Feedback.msg_notice (str ("Rule densities for: " ^ ty_ctr_to_string ind_name ^ " with output indices: " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois) ++ fnl ());
  print_rule_densities densities);
  (* let filter_empty_constructors = List.map (fun (p, cs) -> p, List.filter (fun c -> match List.assoc c densities with | Checking -> false | Partial | Backtracking -> true) cs) covered_patterns in
  let any_uncovered = List.exists (fun (p,cs) -> cs = []) filter_empty_constructors in
  let all_has_partial = List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities = Partial) cs) filter_empty_constructors in
  let result = if any_uncovered then Checking else if all_has_partial then Partial else Backtracking in *)
  let filter_uncovered_patterns = List.filter (fun (p, cs) -> match cs with | [] -> false | _ -> true) covered_patterns in
  let all_covered_has_nonempty = List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities <> Checking) cs) filter_uncovered_patterns in
  let result = if not all_covered_has_nonempty then 
                Checking 
               else if List.for_all (fun (p,cs) -> List.exists (fun c -> List.assoc c densities = Partial) cs) filter_uncovered_patterns 
               then 
                Partial 
               else 
                Backtracking in
  density_memo := RelationInstMap.add (ind_name, ois, ds) result !density_memo;
  if should_print then (Feedback.msg_notice (str "Rule pattern coverage tree:" ++ fnl ());
                        print_coverage_tree ind_name tree ois; Feedback.msg_notice (fnl ());
                        Feedback.msg_notice (str "Set of patterns and densities of their covering rules:" ++ fnl ());
                        print_pattern_leaves ind_name tree ois densities; 
                        Feedback.msg_notice (str ("Inductive relation " ^ ty_ctr_to_string ind_name ^ " with output indices:"
                                                  ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" ois 
                                                  ^ " has overall density: " 
                                                  ^ (density_to_string result)) ++ fnl ()));
  result

let rec traverse (f : 'a -> 'b option) (l : 'a list) : 'b list option =
  match l with
  | [] -> Some []
  | x :: xs -> 
    match f x with
    | None -> None
    | Some y -> 
      match traverse f xs with
      | None -> None
      | Some ys -> Some (y :: ys)

type schedule_with_density = (schedule_step * rule_density) list * schedule_sort

let densest (schedule : schedule_with_density) : rule_density =
  let (steps, sort) = schedule in
  let densities = List.map snd steps in
  let max_dense a b =
    match a,b with
    | Checking, _ -> Checking
    | _, Checking -> Checking
    | Backtracking, _ -> Backtracking
    | _, Backtracking -> Backtracking
    | Partial, _ -> Partial
    | _, Partial -> Partial
    | Total, Total -> Total in
  List.fold_left (fun acc d -> max_dense acc d) Total densities

let sparsest (schedule : schedule_with_density) : rule_density =
  let (steps, _) = schedule in
  let densities = List.map snd steps in
  let min_dense a b =
    match a,b with
    | Total, _ -> Total
    | _, Total -> Total
    | Partial, _ -> Partial
    | _, Partial -> Partial
    | Backtracking, _ -> Backtracking
    | _, Backtracking -> Backtracking
    | Checking, Checking -> Checking in
  List.fold_left (fun acc d -> min_dense acc d) Checking densities

let are_schedule_steps_valid i ((steps, sort) : schedule_with_density) : bool = true

let num_source_variables (s : source) : int =
  match s with
  | SrcNonrec (hyp) -> List.length (variables_in_hypothesis hyp)
  | SrcRec (_, args) -> List.length (List.concat_map variables_in_hypothesis args)
  | SrcMutrec (_, args) -> List.length (List.concat_map variables_in_hypothesis args)

let num_source_bound_vars env (s : source) : int =
  List.length (match s with
  | SrcNonrec (hyp) -> List.filter (fun v -> List.mem v env) (variables_in_hypothesis hyp)
  | SrcRec (_, args) -> List.filter (fun v -> List.mem v env) (List.concat_map variables_in_hypothesis args)
  | SrcMutrec (_, args) -> List.filter (fun v -> List.mem v env) (List.concat_map variables_in_hypothesis args))

let add_bound_vars env step = 
  match step with
  | S_UC (v, _, _) -> v :: env
  | S_Check _ -> env
  | S_ST (vs,_,_) -> List.map fst vs @ env
  | S_Match (_, pat) -> pat_vars pat @ env

let get_schedule_score ((steps, sort) : schedule_with_density) : int =
  let get_step_score env (step, density) =
    match step with
    | S_UC (_,s,_) -> num_source_bound_vars env s
    | S_Check (s,_) -> num_source_bound_vars env s
    | S_ST (_, s, _) -> num_source_bound_vars env s
    | S_Match (v, _) -> (if List.mem v env then 1 else 0) in
  
  let rec aux env = function
    | [] -> 0
    | (step,density) :: rest -> get_step_score env (step, density) + aux (add_bound_vars env step) rest in

  aux [] steps


(* let schedule_density schedule : schedule_with_density =
  let step_density (step : schedule_step) ds : rule_density =
    match step with
    | S_UC _  -> Total (* For enumerations during a checker should unconstrained be empty? *)
    | S_Check _  -> Checking
    | S_ST (_, SrcRec _, _) -> (match ds with D_Gen | D_Thm -> Total | D_Check | D_Enum -> Checking) 
    | S_Match _ -> Backtracking
    | S_ST (output_var_tys, SrcNonrec (DTyCtr (ind,args)), _) -> 
      let output_vars = List.map fst output_var_tys in
      let rec is_output i = (function
        | DTyVar j -> List.mem j output_vars
        | DCtr (_, args) -> List.exists (is_output i) args
        | _ -> false) in
      let output_indices = filter_mapi (fun i arg -> if is_output i arg then Some i else None) args in
      (match final_density (ty_ctr_to_rocq_relation ind) output_indices false with
      | Checking -> Feedback.msg_notice (str ("Relation " ^ ty_ctr_to_string ind ^ " with ois: " ^ List.fold_left (fun acc oi -> acc ^ " " ^ string_of_int oi) "" output_indices ^ " is checking") ++ fnl ()); Checking
      | d -> d)
    | S_ST (_, SrcNonrec _, _) -> failwith "is_schedule_valid: Nonrecursive source should have DTyCtr at toplevel" 
  in
  let (steps, sort) = schedule in
  let ds = match sort with
    | TheoremSchedule _ -> D_Thm
    | ProducerSchedule (_,PS_E,_) -> D_Enum
    | ProducerSchedule (_,PS_G,_) -> D_Gen
    | CheckerSchedule -> D_Check in
  let step_densities = List.map (fun step -> (step, step_density step ds)) steps in
  (step_densities, sort) *)

let schedule_with_densities_to_string (s : schedule_with_density) =
  let (steps, sort) = s in
  Printf.sprintf "do %s \n=> %s\n" (String.concat " ;\n " (List.map (fun (step, density) -> schedule_step_to_string step ^ " " ^ density_to_string density) steps)) (schedule_sort_to_string sort)

let producer_sort_to_derive_sort (ps : producer_sort) : derive_sort =
  match ps with
  | PS_E -> D_Enum
  | PS_G -> D_Gen

let check_eq (u1,u2) = S_Check (SrcNonrec (DTyCtr (ty_ctr_of_string "Coq.Init.Logic.eq", [DHole; DTyVar u1; DTyVar u2])), true)

let rec arrows_to_products typ =
  match typ with
  | DArrow (t1, t2) -> 
    let name = make_up_name () in
    DProd ((name, t1), arrows_to_products t2)
  | DProd ((name, t1), t2) -> DProd ((name, t1), arrows_to_products t2)
  | _ -> typ

let rec schedule_density schedule : schedule_with_density =
  let step_density (step : schedule_step) ds : rule_density =
    match step with
    | S_UC (v,SrcNonrec ty,ps) ->
      (ignore (best_inductive_schedule_from_instance ty [] (producer_sort_to_derive_sort ps) false);
      Total) (* For enumerations during a checker should unconstrained be empty? *)
    | S_UC (_,SrcRec _,_) -> Total
    | S_Check (SrcNonrec ty,pol) ->
      (ignore (best_inductive_schedule_from_instance ty [] D_Check true);
      if pol then Checking else Partial)
    | S_Check (SrcRec _, pol) -> if pol then Checking else Partial
    | S_ST (_, SrcRec _, _) -> (match ds with D_Gen | D_Thm -> Total | D_Check | D_Enum -> Checking) 
    | S_ST (output_var_tys, SrcNonrec (DTyCtr (ind,args)), ps) -> 
      let output_vars = List.map fst output_var_tys in
      let rec is_output i = (function
        | DTyVar j -> List.mem j output_vars
        | DCtr (_, args) -> List.exists (is_output i) args
        | _ -> false) in
      let output_indices = filter_mapi (fun i arg -> if is_output i arg then Some i else None) args in
      snd (inductive_best_valid_schedule (ty_ctr_to_rocq_relation ind) output_indices (producer_sort_to_derive_sort ps) true)
    | S_ST (_, SrcNonrec _, _) -> failwith "is_schedule_valid: Nonrecursive source should have DTyCtr at toplevel" 
    | S_Match _ -> Backtracking
    | S_ST (_, SrcMutrec _, _)
    | S_UC (_,SrcMutrec _, _)
    | S_Check (SrcMutrec _, _) -> failwith "is_schedule_valid: Mutually recursive source should not be used at density calculation time, but inserted later."
  in

  let (steps, sort) = schedule in

  let ds = match sort with
    | TheoremSchedule concl -> 
      ignore (best_inductive_schedule_from_instance concl [] D_Check true);
      D_Thm
    | ProducerSchedule (_,PS_E,_) -> D_Enum
    | ProducerSchedule (_,PS_G,_) -> D_Gen
    | CheckerSchedule -> D_Check in

  let step_densities = List.map (fun step -> (step, step_density step ds)) steps in
  (* Check for unifications and heuristics! *)

  

  (step_densities, sort)


(* let does_schedule_satisfy_heuristics ((steps, sort) : schedule) =
  let rec aux (ois : output_index list) (outputs : var list) (inputs : var list) =
    (* Need *)

   *)

(* let is_binding_selection_valid i ((bindings,unbound) : bindings_and_unbound) =
  let is_binding_valid (v, ty, opt) =
    match opt with
    | None -> Some (v,ty,opt, Partial)
    | Some (DTyCtr (ind,_), i) ->
      (match final_density (ty_ctr_to_dep_dt ind) [i] false with
      | Checking -> None
      | d -> Some (v, ty, opt, d))
    | _ -> failwith "is_binding_selection_valid: Binding relation should have DTyCtr at toplevel" in
  match traverse is_binding_valid bindings with
  | None -> None
  | Some bs -> Some (i, (bs, unbound)) *)

(* Create a map from types * outputs => inductive_schedules which can be reused and referenced. *)

(** There will always exist at least one partial schedule for producers, b/c you can just arb all variables and check all hyps.*)

and constructor_valid_schedules (ind_name : ty_ctr) (ctr : rocq_ctr) (result_vars : (var * rocq_constr) list) (output_vars : var list) (ds : derive_sort) (opt : bool) : (int * schedule_with_density) list =
  let (ctr_name, typ) = ctr in
  let typ = if opt then typ else arrows_to_products typ in
  let schedule_matches = NewUnifyQC.type_to_schedules typ (Some ind_name) (Some ctr_name) result_vars output_vars ds opt in
  let schedules = List.mapi (fun i ((steps, sort), ms, eqs) -> i,(List.map (fun (v,p) -> S_Match (v,p)) ms @ List.map check_eq eqs @ steps, sort)) schedule_matches in
  let schedule_densities = List.map (fun (i,schd) -> i, schedule_density schd) schedules in
  List.filter (fun (i,schd) -> are_schedule_steps_valid i schd) schedule_densities

and select_best_schedule (schedules : (int * schedule_with_density) list) (ds : derive_sort) : (int * schedule) option =
  (* let compare_checks_then_length_then_backtracks (_, steps, _) (_, steps', _) =
    let checks_length_and_backtracks steps = List.fold_left (fun (c,l,b) (step,d) ->
      let c' = match step, ds with S_Check _, D_Check -> c | S_UC _, D_Check | S_Check _, _ -> c + 1 | _ -> c in
      let l' = l + 1 in
      let b' = match d with | Backtracking -> b + 1 | _ -> b in
      (c',l',b')) (0,0,0) steps in
    let (c,l,b) = checks_length_and_backtracks steps in
    let (c',l',b') = checks_length_and_backtracks steps' in
    match compare c c' with
    | 0 -> (match compare l l' with
            | 0 -> compare b b'
            | rl -> rl)
    | rc -> rc in *)

    
  let density_dense = function
    | Checking -> 0
    | Backtracking -> 1
    | Partial -> 2
    | Total -> 3 in

  let density_sparse = function
    | Total -> 0
    | Partial -> 1
    | Backtracking -> 2
    | Checking -> 3 in

  let compare_scores (_, schd) (_, schd') =
    match ds with
    | D_Check | D_Enum ->
      (match compare (density_dense (sparsest schd)) (density_dense (sparsest schd')) with
          | 0 -> - compare (get_schedule_score schd) (get_schedule_score schd')
          | c -> c)
    | D_Gen | D_Thm -> 
      (match compare (density_sparse (densest schd)) (density_sparse (densest schd')) with
          | 0 -> compare (get_schedule_score schd) (get_schedule_score schd')
          | c -> c) in
  match List.sort compare_scores schedules with
  | [] -> None
  | (i, (steps, sort)) :: _ -> Some (i, (List.map fst steps, sort))

and constructor_best_valid_schedule (ind_name : ty_ctr) (ctr : rocq_ctr) (result_vars : (var * rocq_constr) list) (output_vars : var list) (ds : derive_sort) (opt : bool) : ty_ctr * (int * schedule) option =
  fst ctr, select_best_schedule (constructor_valid_schedules ind_name ctr result_vars output_vars ds opt) ds

and inductive_best_valid_schedule (rel : rocq_relation) (output_idxs : int list) (ds : derive_sort) (opt : bool) : inductive_schedule * rule_density =
  let (ind_name, params, ctrs, result_typ) = rel in
  msg_debug (str "SEEHERE Inductive name: " ++ str (ty_ctr_to_string ind_name) ++ fnl ());
  if RelationInstMap.mem (ind_name, output_idxs, ds) !density_inductive_memo then (msg_debug (str (ty_ctr_to_string ind_name ^ " found")); RelationInstMap.find (ind_name, output_idxs, ds) !density_inductive_memo)
  else begin
  Feedback.msg_notice (str "Inductive name: " 
  ++ str (ty_ctr_to_string ind_name)
  ++ str "\n Parameters: "
  ++ str (String.concat ", " (List.map ty_param_to_string params)) 
  ++ str "\n Result Type: "
  ++ str (rocq_constr_to_string result_typ) 
  ++ str "\n Output indices: "
  ++ str (String.concat ", " (List.map string_of_int output_idxs)) 
  ++ str "\n\n");

  let rec get_result_vars = function
  | DProd ((v,t), b) ->
    let v = make_up_name_str ("v_" ^ var_to_string v) in
    (v,t) :: get_result_vars b
  | DArrow (t1, t2) ->
    let v = make_up_name_str "v" in
    (v,t1) :: get_result_vars t2
  | _ -> [] in

  let result_vars = List.map (fun p -> (p, DHole)) params @ get_result_vars result_typ in

  let rec remake_result vars result = 
  match vars, result with
  | [], _ -> result
  | (v,t) :: rest, DProd  (_, t') 
  | (v,t) :: rest, DArrow (_, t') -> DProd ((v,t), remake_result rest t')
  | _ -> failwith "remake_result failed" in

  let output_vars = List.map fst (List.filteri (fun i _ -> List.mem i output_idxs) result_vars) in

  let modestring = String.init (List.length result_vars) (fun i -> if List.mem i output_idxs then 'O' else 'I') in

  let typeclass_name = function
    | (D_Check, _) -> "DecOpt"
    | (D_Thm, _) -> failwith "Inductives cannot make theorems"
    | (D_Gen, false) -> "GenSized" 
    | (D_Gen, true) -> "GenSizedSuchThat" 
    | (D_Enum, false) -> "EnumSized"
    | (D_Enum, true) -> "EnumSizedSuchThat" in

  let schedule_name = Printf.sprintf "%s%s_%s" (typeclass_name (ds, opt)) (ty_ctr_to_string ind_name) modestring in

  density_inductive_memo := RelationInstMap.add (ind_name, output_idxs, ds) ((schedule_name,[],[],[]), Partial) !density_inductive_memo;

  let constructor_schedules = List.filter_map (fun ctr -> 
    match constructor_best_valid_schedule ind_name ctr result_vars output_vars ds opt with
    | (ctr_name, None) -> failwith ("Should be at least one partial schedule for all constructors including this one: " ^ constructor_to_string ctr_name)
    | (ctr_name, Some (i, schd)) -> Some schd) ctrs in

  let is_recursive (steps,sort) = 
    List.exists (function | S_UC (_,SrcRec _,_) | S_ST (_,SrcRec _, _) | S_Check (SrcRec _,_) -> true | _ -> false) steps 
  in

  let (nonrecursive, recursive) = List.partition is_recursive constructor_schedules in

  let result_vars_mexps = filter_mapi (fun i (v,t) -> if List.mem i output_idxs then None else Some (v, NewGenericLib.product_free_rocq_type_to_mexp t)) result_vars in 

  let inductive_schedule : inductive_schedule =
    (schedule_name, result_vars_mexps, List.map (fun c -> (c, [])) recursive, List.map (fun c -> (c, [])) nonrecursive) 
  in
  density_inductive_memo := RelationInstMap.add (ind_name, output_idxs, ds) (inductive_schedule, Partial) !density_inductive_memo;
  inductive_schedule, Partial
end

and best_inductive_schedule_from_instance (ind_instance : rocq_type) (output_vars : var list) (ds : derive_sort) (opt : bool) : inductive_schedule * rule_density =
  match ind_instance with
  | DTyCtr (ind_name, args) -> 
    let output_idxs = filter_mapi (fun i -> function | DTyVar v -> if List.mem v output_vars then Some i else None | _ -> None) args in
    (* Feedback.msg_debug (str (ty_ctr_to_string ind_name ^ " with output indices: " ^ String.concat "," (List.map string_of_int output_idxs)) ++ fnl ()); *)
    inductive_best_valid_schedule (ty_ctr_to_rocq_relation ind_name) output_idxs ds opt
  | _ -> failwith "best_inductive_schedule_from_instance: not a DTyCtr"

let collect_inductive_dependents (instance : rocq_constr * int list * derive_sort * bool) : (rocq_constr * int list * derive_sort * bool) list =
  let (ind_instance, output_idxs, ds, opt) = instance in
  match ind_instance with
  | DTyCtr (ind_name,_) -> 
    let (inductive_schd, density) = RelationInstMap.find (ind_name, output_idxs, ds) !density_inductive_memo in
    inductive_schedule_dependents inductive_schd
  | DTyVar v -> failwith "collect_inductive_dependents: Need to handle instances of parameter type variables, like A in list A"
  | _ -> failwith "collect_inductive_dependents: not a DTyCtr or DTyVar"

let lookup_and_remove_inductive_schedule (instance : rocq_constr * int list * derive_sort * bool) (to_remove : bool) : (inductive_schedule * derive_sort * bool) option =
  let (ind_instance, output_idxs, ds, opt) = instance in
  match ind_instance with
  | DTyCtr (ind_name,_) -> 
    (try (let (inductive_schd, density) = RelationInstMap.find (ind_name, output_idxs, ds) !density_inductive_memo in
    if to_remove then density_inductive_memo := RelationInstMap.remove (ind_name, output_idxs, ds) !density_inductive_memo;
    Some (inductive_schd, ds, opt)) with Not_found -> None)
  | DTyVar v -> failwith "lookup_and_remove_inductive_schedule: Need to handle instances of parameter type variables, like A in list A"
  | _ -> failwith "lookup_and_remove_inductive_schedule: not a DTyCtr or DTyVar"

let update_source step src =
  match step with
  | S_UC (v,_,ps) -> S_UC (v, src, ps)
  | S_Check (_,pol) -> S_Check (src, pol)
  | S_ST (vs,_,ps) -> S_ST (vs, src, ps)
  | S_Match (v,pat) -> S_Match (v, pat)

let nonrec_to_mutrec_call name ois ty : source =
  match ty with
  | DTyCtr (ind, args) -> 
    let input_args = filter_mapi (fun i arg -> if List.mem i ois then None else Some arg) args in
    SrcMutrec (var_of_string name, input_args)
  | _ -> failwith "nonrec_to_mutrec_call: not a DTyCtr"

let nonrecursive_type step =
  match step with
  | S_UC (_,SrcNonrec ty,_)
  | S_ST (_,SrcNonrec ty,_) 
  | S_Check (SrcNonrec ty,_) -> ty
  | S_Match _ -> failwith "nonrecursive_type: step must not be a match"
  | _ -> failwith "nonrecursive_type: step must have nonrecursive source"

let insert_mutrec_call name ois step =
  update_source step (nonrec_to_mutrec_call name ois (nonrecursive_type step))

let insert_mutrec_calls ((schedule,matches) : schedule * (var * pat) list) : schedule * (var * pat) list =
  let (schedule_steps_deps,schd_sort_dep) = schedule_with_dependents schedule in
  let updated_steps = List.map (fun (step,depopt) -> 
                                    (match (depopt >>= fun dep -> lookup_and_remove_inductive_schedule dep false) with
                                    | None -> step
                                    | Some ((ind_schd_name,_,_,_),ds,opt) -> 
                                      let Some (_,ois,_,_) = depopt in insert_mutrec_call ind_schd_name ois step)) 
                        schedule_steps_deps in 
          
  let updated_sort = match schd_sort_dep with
    | (TheoremSchedule t, Some (ctr, ois, ds, opt)) -> 
      (match lookup_and_remove_inductive_schedule (ctr, ois, ds, opt) false with
      | None -> TheoremSchedule t
      | Some ((schd_name,_,_,_), _, _) ->
      (match t with
      | DTyCtr (_, args) -> 
        let input_args = filter_mapi (fun i arg -> if List.mem i ois then None else Some arg) args in
        let fuel_arg = DTyVar (var_of_string "size") in
        let new_conclusion = DApp (DTyVar (var_of_string schd_name), fuel_arg :: input_args) in
        TheoremSchedule new_conclusion
      | _ -> failwith "insert_mutrec_calls: TheoremSchedule must have DTyCtr at toplevel"))
    | (schd_sort,_) -> schd_sort in

  (updated_steps, updated_sort), matches

module InductiveSchedSet = Set.Make(struct type t = inductive_schedule * derive_sort * bool let compare = compare end)


let dec_eq_sched_phony = ("DecOpteq", [], [(([],CheckerSchedule),[])], [(([],CheckerSchedule),[])])
   
let init_density_inductive_memo = RelationInstMap.add (ty_ctr_of_string "Coq.Init.Logic.eq", [], D_Check) (dec_eq_sched_phony, Checking) RelationInstMap.empty

let inductive_set_init = InductiveSchedSet.singleton (dec_eq_sched_phony, D_Check, false)

let inductive_set = ref inductive_set_init

let rec collect_all_used_inductives ((ind_schd, ds, opt) : inductive_schedule * derive_sort * bool) : (inductive_schedule * derive_sort * bool) list =
  if InductiveSchedSet.mem (ind_schd, ds, opt) !inductive_set then []
  else begin
  inductive_set := InductiveSchedSet.add (ind_schd, ds, opt) !inductive_set;
  let (schedule_name, result_vars, nonrecursive_hyps, recursive_hyps) = ind_schd in
  Feedback.msg_notice (str ("Collecting inductive schedule: " ^ schedule_name) ++ fnl ());
  let fill_nonrecursive_dependents = (schedule_name, result_vars, (List.map insert_mutrec_calls nonrecursive_hyps), (List.map insert_mutrec_calls recursive_hyps)) in
  let dependents = List.filter_map (fun dep -> lookup_and_remove_inductive_schedule dep false) (inductive_schedule_dependents ind_schd) in
  (fill_nonrecursive_dependents, ds, opt) :: List.concat_map collect_all_used_inductives dependents
  end

let valid_schedules =
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        density_memo := RelationInstMap.empty;
        let schedules = NewUnifyQC.type_to_schedules dt None None [] [] D_Thm false in
        let schedules' = List.map (fun ((steps, sort), ms, eqs) -> (List.map (fun (v,p) -> S_Match (v,p)) ms @ List.map check_eq eqs @ steps, sort)) schedules in
        Feedback.msg_notice (str "Printing all bindings" ++ fnl ());
        (* List.iteri (fun i (steps, sort) ->
          Feedback.msg_notice (str (string_of_int i ^ ":\nAnalysis" ) ++ fnl ());
          let (steps_ds, sort) = schedule_density (steps, sort) in
          let schedule_score = get_schedule_score (steps_ds, sort) in
          Feedback.msg_notice (str ("Schedule Score: " ^ string_of_float schedule_score ^ "\n") ++
                              str (schedule_with_densities_to_string (steps_ds, sort) ^ "\n") ++                                           
                              str "\nconstrexpr: \n" ++ 
                              NewUnifyQC.match_schedule_as_pp_constr_expr (List.map fst steps_ds, sort) [] [] D_Gen
                                                          ++ str "\n==============================================\n")) schedules'; *)

        let schedules_w_densities = List.map schedule_density schedules' in
        let schedules_scored = List.map (fun schd -> schd, get_schedule_score schd) schedules_w_densities in
        let schedules_sorted = List.sort (fun (_,s) (_,s') -> - (compare s s')) schedules_scored in
        List.iteri (fun i ((steps_ds, sort), schedule_score) ->
          Feedback.msg_notice (str (string_of_int i ^ ":\n" ) ++ fnl ());
          (*let (steps_ds, sort) = schedule_density (steps, sort) in
          let schedule_score = get_schedule_score (steps_ds, sort) in *)
          Feedback.msg_notice (str ("Schedule Score: " ^ string_of_int schedule_score ^ "\n") ++
                              str (schedule_with_densities_to_string (steps_ds, sort) ^ "\n") ++                                           
                              str "\nconstrexpr: \n" ++ 
                              NewUnifyQC.match_schedule_as_pp_constr_expr (List.map fst steps_ds, sort) [] [] D_Thm
                                                          ++ str "\n==============================================\n")) schedules_sorted;                                                  
        Tacticals.tclIDTAC
      end 
    | None -> failwith "Failed to Parse type"
  end

let theorem_dependencies = 
  Proofview.Goal.enter begin fun gl ->
    
    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in

    match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
        let open NewGenericLib in
        let rec printlist : (var * (int * int list list) list) list -> unit = function
          | [] -> ()
          | (var, rels) :: rest ->
            let path_to_string (is : int list) = "[" ^ String.concat ", " (List.map string_of_int is) ^ "]" in
            let paths_to_string (iss : int list list) = "{" ^ String.concat "; " (List.map path_to_string iss) ^ "}" in
            let tuple_to_string ((i : int), (j : int list list)) = "(" ^ string_of_int i ^ ", " ^ paths_to_string j ^ ")" in
            msg_debug (str (var_to_string var) ++ str " : " ++ str (String.concat ", " (List.map (fun (i, j) -> (tuple_to_string (i, j))) rels)) ++ fnl ()); 
            printlist rest in
        
        printlist (NewGenericLib.rocq_constr_var_relation_uses' dt);          
        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end

  let schedules =
    Proofview.Goal.enter begin fun gl ->
    
      (* Convert goal to a constr_expr *)
      let c = Proofview.Goal.concl gl in
      let e = Proofview.Goal.env gl in
      let evd = Evd.from_env e in
  
      match NewGenericLib.parse_dependent_type (EConstr.to_constr evd c) with
      | Some dt ->
        begin
          density_memo := RelationInstMap.empty;
          msg_debug (str (NewGenericLib.rocq_constr_to_string dt) ++ fnl ());
          let scheds = (NewUnifyQC.type_to_schedules dt None None [] [] D_Thm false) in

          List.iteri (fun i (sch,ms,eqs) -> Feedback.msg_notice (str (string_of_int i) 
                                                          ++ str ":\n" 
                                                          ++ str (NewUnifyQC.match_schedule_to_string sch ms eqs) 
                                                          ++ str "\nconstrexpr: \n"
                                                          ++ (NewUnifyQC.match_schedule_as_pp_constr_expr sch ms eqs D_Thm)
                                                          ++ str "\n\n===================\n" 
                                                          ++ fnl ())) scheds;
          
          Tacticals.tclIDTAC
        end
      | None -> failwith "Failed to Parse type"
    end

 
}
TACTIC EXTEND quickchick
  | ["quickchick"] -> { quickchick_goal }
END

TACTIC EXTEND schedules 
  | ["schedules"] -> { schedules }
END

TACTIC EXTEND theorem_dependencies
  | ["theorem_dependencies"] -> { theorem_dependencies }
END

TACTIC EXTEND valid_schedules
  | ["valid_schedules"] -> { valid_schedules }
END

VERNAC COMMAND EXTEND Print CLASSIFIED AS SIDEFF
 | ["Print" "Typeclasses" "for" ident(ind)] ->
    { let ind' = Libnames.qualid_of_ident ind in 
      ignore (NewGenericLib.find_typeclass_bindings ind') }
END

(*type rocq_relation
  = ty_ctr        (* The name of the relation (e.g. IsSorted) *)
  * ty_param list (* The list of type parameters (e.g. "t" in IsSorted) *)
  * rocq_ctr list (* A list of constructors. Each constructor is a pair (name, type) *)
  * rocq_constr   (* The type of the overall relation (e.g. "list t -> Prop") *)*)

VERNAC COMMAND EXTEND DeriveSchedules CLASSIFIED AS SIDEFF
   | ["Derive" "Schedules" constr(ind) int_list(ois) "consnum" int(ctr_idx) "derive" string(ds)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) -> 
      let open NewGenericLib in
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in

      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params)) 
                        ++ str "\n Result Type: "
                        ++ str (rocq_constr_to_string result_typ) 
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois)) 
                        ++ str ("\n Derive Sort: " ^ ds) 
                        ++ str "\n\n");

      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Thm" -> D_Thm
      | "Enum" -> D_Enum
      | _ -> failwith ("Invalid derive sort " ^ ds)) in


      let rec get_result_vars = function
      | DProd ((v,t), b) ->
        let v = make_up_name_str ("v_" ^ var_to_string v) in
        (v,t) :: get_result_vars b
      | DArrow (t1, t2) ->
        let v = make_up_name_str "v" in
        (v,t1) :: get_result_vars t2
      | _ -> [] in

      let result_vars = List.map (fun p -> (p, DHole)) params @ get_result_vars result_typ in

      let rec remake_result vars result = 
        match vars, result with
        | [], _ -> result
        | (v,t) :: rest, DProd  (_, t') 
        | (v,t) :: rest, DArrow (_, t') -> DProd ((v,t), remake_result rest t')
        | _ -> failwith "remake_result failed" in

      let (ctr, constructor) = List.nth constructors ctr_idx in

      let output_vars = List.map fst (List.filteri (fun i _ -> List.mem i ois) result_vars) in

      let scheds = NewUnifyQC.type_to_schedules constructor (Some ind_name) (Some ctr) result_vars output_vars ds true in
      
      let rec take n l =
        if n <= 0 then [] else
        match l with
        | [] -> []
        | x :: xs -> x :: take (n - 1) xs in

      let rec drop n l =
        if n <= 0 then l else
        match l with
        | [] -> []
        | x :: xs -> drop (n - 1) xs in

      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name) 
                        ++ str "\n Constructor Name: " 
                        ++ str (ty_ctr_to_string ctr)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params))
                        ++ str "\n Constructor Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string constructor)
                        ++ str "\n Result Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string (remake_result (drop (List.length params) result_vars) result_typ))
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois)) 
                        ++ str "\n\n");

      List.iteri (fun i (sch,ms,eqs) -> Feedback.msg_notice (str (string_of_int i) 
                                                          ++ str ":\n" 
                                                          ++ str (NewUnifyQC.match_schedule_to_string sch ms eqs) 
                                                          ++ str "\nconstrexpr: \n"
                                                          ++ (NewUnifyQC.match_schedule_as_pp_constr_expr sch ms eqs ds)
                                                          ++ str "\n\n===================\n" 
                                                          ++ fnl ())) (take 300 scheds) 
    | None -> failwith "Failed to parse inductive type" 
    }
END

VERNAC COMMAND EXTEND DeriveValidSchedules CLASSIFIED AS SIDEFF
   | ["Derive" "Valid" "Schedules" constr(ind) int_list(ois) "consnum" int(ctr_idx) "derive" string(ds)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) -> 
      let open NewGenericLib in
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in
      density_inductive_memo := init_density_inductive_memo;
      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params)) 
                        ++ str "\n Result Type: "
                        ++ str (rocq_constr_to_string result_typ) 
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois))
                        ++ str ("\n Derive Sort: " ^ ds) 
                        ++ str "\n\n");

      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Thm" -> D_Thm
      | "Enum" -> D_Enum
      | _ -> failwith ("Invalid derive sort " ^ ds)) in

      let rec get_result_vars = function
      | DProd ((v,t), b) ->
        let v = make_up_name_str ("v_" ^ var_to_string v) in
        (v,t) :: get_result_vars b
      | DArrow (t1, t2) ->
        let v = make_up_name_str "v" in
        (v,t1) :: get_result_vars t2
      | _ -> [] in

      let result_vars = List.map (fun v -> (v,DHole)) params @ get_result_vars result_typ in

      let rec remake_result vars result = 
        match vars, result with
        | [], _ -> result
        | (v,t) :: rest, DProd  (_, t') 
        | (v,t) :: rest, DArrow (_, t') -> DProd ((v,t), remake_result rest t')
        | _ -> failwith ("remake_result failed on: " ^ rocq_constr_to_string result) in

      let (ctr, constructor) = List.nth constructors ctr_idx in

      let output_vars = List.map fst (List.filteri (fun i _ -> List.mem i ois) result_vars) in

      let scheds = NewUnifyQC.type_to_schedules constructor (Some ind_name) (Some ctr) result_vars output_vars ds true in

      let rec take n l =
        if n <= 0 then [] else
        match l with
        | [] -> []
        | x :: xs -> x :: take (n - 1) xs in

      let rec drop n l =
        if n <= 0 then l else
        match l with
        | [] -> []
        | x :: xs -> drop (n - 1) xs in

      Feedback.msg_notice (str "Inductive name: " 
                        ++ str (ty_ctr_to_string ind_name) 
                        ++ str "\n Constructor Name: " 
                        ++ str (ty_ctr_to_string ctr)
                        ++ str "\n Parameters: "
                        ++ str (String.concat ", " (List.map ty_param_to_string params))
                        ++ str "\n Constructor Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string constructor)
                        ++ str "\n Result Type: "
                        ++ str (NewGenericLib.rocq_constr_to_string (remake_result (drop (List.length params) result_vars) result_typ))
                        ++ str "\n Output indices: "
                        ++ str (String.concat ", " (List.map string_of_int ois)) 
                        ++ str "\n\n");

      density_memo := RelationInstMap.empty;
      let schedules = take 300 scheds in
      let schedules' = List.map (fun ((steps, sort), ms, eqs) -> (List.map (fun (v,p) -> S_Match (v,p)) ms @ List.map check_eq eqs @ steps, sort)) schedules in
      Feedback.msg_notice (str "Printing all bindings" ++ fnl ());
      let schedules_w_densities = List.map schedule_density schedules' in
      let schedules_scored = List.map (fun schd -> schd, get_schedule_score schd) schedules_w_densities in
      let schedules_sorted = List.sort (fun (_,s) (_,s') -> (compare s s')) schedules_scored in
      List.iteri (fun i ((steps_ds, sort), schedule_score) ->
        Feedback.msg_notice (str (string_of_int i ^ ":\n" ) ++ fnl ());
        (*let (steps_ds, sort) = schedule_density (steps, sort) in
        let schedule_score = get_schedule_score (steps_ds, sort) in *)
        Feedback.msg_notice (str ("Schedule Score: " ^  string_of_int schedule_score ^ "\n") ++
                             str (schedule_with_densities_to_string (steps_ds, sort) ^ "\n") ++                                           
                             str "\nconstrexpr: \n" ++ 
                             NewUnifyQC.match_schedule_as_pp_constr_expr (List.map fst steps_ds, sort) [] [] ds
                                                        ++ str "\n==============================================\n")) schedules_sorted
        (* match get_schedule_score i (steps_ds, sort) with
        | Some (i, steps_ds, sort) -> Feedback.msg_notice (str ("Schedule Valid:\n" ^ schedule_with_densities_to_string (steps_ds, sort))                                          
                                                        ++ str "\nconstrexpr: \n"
                                                        ++ NewUnifyQC.match_schedule_as_pp_constr_expr (List.map fst steps_ds, sort) [] D_Gen
                                                        ++ str "\n==============================================\n")
        | None -> Feedback.msg_notice (str ( "Schedule Invalid\n==============================================") ++ fnl ())) schedules'

     *)
    | None -> failwith "Failed to parse inductive type" 
    }
END

      

VERNAC COMMAND EXTEND DeriveUsedInds CLASSIFIED AS SIDEFF
   | ["Derive" "Used" "Inds" constr(ind)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) ->
        let (ind_name, params, constructors, result_typ) = List.nth rs idx in
        (match get_inductive_name ind_name with
        | Some i -> print_type_names (List.map (fun (n,_,_,_) -> n) (seek_rocq_relations i))
        | None -> failwith "Failed to get inductive name")
    | None -> failwith "Failed to parse inductive type"  
    }
END

VERNAC COMMAND EXTEND DeriveDensity CLASSIFIED AS SIDEFF
   | ["Derive" "Density" constr(ind) int_list(ois) "derive" string(ds)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) ->
      density_memo := RelationInstMap.empty;
      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Thm" -> D_Thm
      | "Enum" -> D_Enum) in
      ignore (final_density (List.nth rs idx) ois true ds)
    | None -> failwith "Failed to parse inductive type" 
    }
END

VERNAC COMMAND EXTEND DeriveInductiveSchedule CLASSIFIED AS SIDEFF
   | ["Derive" "Inductive" "Schedule" constr(ind) int_list(ois) "derive" string(ds) "opt" string(opt)] ->
    { match NewGenericLib.ind_reference_to_rocq_relations ind with
    | Some (idx, rs) ->
      density_inductive_memo := init_density_inductive_memo;
      inductive_set := inductive_set_init;
      let (ind_name, params, constructors, result_typ) = List.nth rs idx in
      let ds = (match ds with
      | "Check" -> D_Check
      | "Gen" -> D_Gen
      | "Enum" -> D_Enum
      | _ -> failwith "Can only derive inductive schedules for Check, Gen, or Enum") in
      let opt = (match opt with
      | "true" -> true
      | "false" -> false
      | _ -> failwith "Opt must be true or false") in
      msg_debug (str "LOOOK HERE Deriving inductive schedule for " ++ str (ty_ctr_to_string ind_name) ++ fnl ());
      let (inductive_schedule, density) = inductive_best_valid_schedule (ind_name, params, constructors, result_typ) ois ds opt in
      Feedback.msg_notice (str "Inductive Schedule:\n" ++ str (inductive_schedule_to_string inductive_schedule) ++ fnl ());
      msg_debug (str "LOOOK HERE Density: " ++ str (density_to_string density) ++ fnl ());
      density_inductive_memo := RelationInstMap.remove (ty_ctr_of_string "eq", [], D_Check) !density_inductive_memo;
      let used_inductives = collect_all_used_inductives (inductive_schedule, ds, opt) in
      (* Capture dependencies
      let dependency_chain = get_inductive_dependencies inductive_schedule in
      let (ischd_name, _,_,_) = inductive_schedule
      let mutual_fixpoint = mutfix ischd_name (flatten dependency_chain) *)
      List.iter (fun (ind, ds, opt) -> Feedback.msg_notice (str "Used Inductive Schedule:\n" ++ str (inductive_schedule_to_string ind) ++ fnl ())) used_inductives;

      let ind_schd_name = match inductive_schedule with (n,_,_,_) -> n in

      let mutrec_constr_expr = inductive_schedule_with_dependencies_to_constr_expr used_inductives ind_schd_name in

      let define c env evd =
        let fn = fresh_name ind_schd_name in
        (* TODO: Maxime - which of the new internal flags should be used here? The names aren't as clear :) *)
        let (c_constr, univ_info) = (Constrintern.interp_constr env evd c) in
        let univ_entry = UState.univ_entry ~poly:false univ_info in
        let constr = (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr) in

        let cinfo = Declare.CInfo.make ~name:fn ~typ:None () in
        let info = Declare.Info.make ~poly:false () in
        Declare.declare_definition ~info ~cinfo ~opaque:false ~body:c_constr evd

         (* Declare.declare_definition ~kind:Decls.(IsDefinition Definition) fn (constr,univ_entry) *)


        (*val declare_definition : info:Info.t -> cinfo:EConstr.t option CInfo.t -> opaque:bool -> body:EConstr.t -> ?using:Vernacexpr.section_subset_expr -> Evd.evar_map -> Names.GlobRef.t
Declares a non-interactive constant; body and types will be normalized w.r.t. the passed evar_map sigma. Universes should be handled properly, including minimization and restriction. Note that sigma is checked for unresolved evars, thus you should be careful not to submit open terms

val declare_mutual_definitions : info:Info.t -> cinfo:Constr.t CInfo.t list -> opaque:bool -> uctx:UState.t -> bodies:(Constr.t list * Sorts.relevance list) -> possible_guard:Pretyping.possible_guard -> ?using:Vernacexpr.section_subset_expr -> unit -> Names.GlobRef.t list
Declaration of interactive constan*)

        (* let _ : Names.Constant.t = Declare.declare_constant ~name:fn ~kind:Decls.(IsDefinition Definition)
            (DefinitionEntry (Declare.definition_entry (EConstr.to_constr ~abort_on_undefined_evars:false evd c_constr))) in
        fn *)
      in
      (*TODO: MAKE SURE THESE ARE CORRECT ENV + EVD*)
      let env = Global.env () in
      let evd = Evd.from_env env in
      Feedback.msg_notice (str "We shouldn't have a constant");
      ignore (define mutrec_constr_expr env evd);
      Feedback.msg_notice (str "We really should have a constant");
      (* ignore (declare_constant (var_of_string ind_schd_name) ) *)

      let constr_expr = inductive_schedule_to_constr_expr inductive_schedule ds opt in
      Feedback.msg_notice (str "Inductive Schedule ConstrExpr:\n" ++ str (NewGenericLib.constr_expr_to_string mutrec_constr_expr) ++ fnl ())
    | None -> failwith "Failed to parse inductive type " 
    }
END

TACTIC EXTEND merge_sound_core
  | ["merge_sound_core"] -> { merge_sound }
END

TACTIC EXTEND remember_induct
  | ["remember_induct" ident(h)] -> { remember_induct h }
END
