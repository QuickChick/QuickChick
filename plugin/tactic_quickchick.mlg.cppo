{
(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

  open Ltac_plugin
  open Error
  open Pp
  open Stdarg
  open GenericLib

}

DECLARE PLUGIN "coq-quickchick.plugin"

{
let merge_sound =
  let rec get_hyps (s : Evd.evar_map) (c : EConstr.constr) =
    if EConstr.isProd s c then
      let (x,t1,t2) = EConstr.destProd s c in
      (x,t1) :: get_hyps s t2
    else []
  in 
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let s = Proofview.Goal.sigma gl in
    let to_intro = get_hyps s c in
    let rec calc_ids acc opts =
      match opts with
      | [] -> begin match acc with
              | to_ind::rest -> (to_ind, List.rev acc)
              | _ -> failwith "No product/merge_sound"
              end
      | (nb,_) :: nbs ->
         begin match Context.binder_name nb with
         | Names.Name id -> calc_ids (id :: acc) nbs
         | Names.Anonymous -> calc_ids (Names.Id.of_string "H" :: acc) nbs
         end in
    match calc_ids [] to_intro with
    | (_to_induct, opts) ->
       Tactics.intros_using_then opts (fun ids ->
           Tacticals.tclTHENLIST
             [ Tacticals.onLastHyp Tactics.simplest_elim
             ; Tactics.intros 
         ])
  end;;

let remember_induct h =
  Proofview.Goal.enter begin fun gl ->
    let s = Proofview.Goal.sigma gl in
    let env = Proofview.Goal.env gl in
    let cn = EConstr.mkVar h in
    Tacticals.tclTYPEOFTHEN cn (fun evm ct -> 
        msg_debug (str "Here: " ++ Printer.pr_constr_env env s (EConstr.to_constr s ct) ++ fnl());
        let to_remember = 
          if EConstr.isApp s ct then begin
              let (ctr, cs) = EConstr.destApp s ct in
              let to_remember = ref [] in
              Array.iter (fun cx ->
                  if EConstr.isApp s cx then
                    to_remember := cx :: !to_remember
                  else if EConstr.isConstruct s cx then
                    to_remember := cx :: !to_remember
                  else msg_debug (str "All good" ++ fnl ())) cs;
              !to_remember
            end
          else failwith "Not App" in
        let eqpat = CAst.make @@ Namegen.IntroAnonymous in 
        let cl =
          { Locus.onhyps = None
          ; Locus.concl_occs = Locus.AllOccurrences } in 
        let rec do_remembers (pats : EConstr.constr list) =
          match pats with
          | [] ->
#if COQ_VERSION >= (8, 19, 0)
            Induction.induction false None cn None None
#else
            Tactics.induction false None cn None None
#endif
          | p :: ps ->
             Tacticals.tclTHEN
#if COQ_VERSION >= (8, 18, 0)             
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (Some s, p) cl)
#else
                   (Tactics.letin_pat_tac false (Some (true, eqpat)) (Names.Name.Anonymous) (s, p) cl)
#endif                 
                   (do_remembers ps) in
        msg_debug (int (List.length to_remember) ++ fnl ());
        do_remembers to_remember
      )
    end 

let decOpt_fuel = 1000

(* variable v, type of v, if None then 
                             unbound 
                          else 
                             (bound inductive, index of binding argument)*)
type binding = var * dep_type * (dep_type * int) option

type bindings_and_unbound = binding list * dep_type list 
type relation_variables = (int * var list) list
type var_uses_in_relations = (var * (int * int) list) list
type dep_type_var_map_views = relation_variables * var_uses_in_relations

(* 1. list of bindings
   2. list of unbound inductives  *)

let list_pair_with_rest l =
  let rec aux before current =
    match current with
    | [] -> []
    | now :: after -> (before @ after, now) :: aux (now :: before) after in
  aux [] l

let safe_assoc i l = try List.assoc i l with _ -> []

let rec assoc_remove_all_in_set k_set l =
  match l with
  | [] -> []
  | (k, v) :: rest -> if List.mem k k_set then assoc_remove_all_in_set k_set rest else (k, v) :: assoc_remove_all_in_set k_set rest

let list_bind (l : 'a list) (f : 'a -> 'b list) : 'b list =
  List.concat (List.map f l)

let print_all_bindings' (bindings : bindings_and_unbound list) : unit =
  if bindings = [] then msg_debug (str "No bindings found" ++ fnl ())
  else
    let string_of_option f = function
      | None -> "None"
      | Some x -> "Some " ^ (f x) in
    List.iteri (fun j (b, i) ->
        msg_debug (str "Bindings: " ++ str (string_of_int j) ++ fnl ());
      List.iter (fun (v, t, opt) ->
          msg_debug (str (var_to_string v) ++ str " : " ++ str (dep_type_to_string t) ++ str " : " ++ str (string_of_option (fun (r, i) -> dep_type_to_string r ^ " " ^ string_of_int i) opt) ++ fnl ())
      ) b;
      List.iter (fun i -> msg_debug (str (dep_type_to_string i) ++ fnl ())) i
    ) bindings  

let rec binding_options' ((ind_vars, var_uses) : dep_type_var_map_views) (typed_vars : (var * dep_type) list) : var_uses_in_relations list =
  msg_debug (str "Size of typed_vars: " ++ int (List.length typed_vars) ++ fnl ());
  if typed_vars = [] then [var_uses] else begin
  let var_to_bind_options = list_pair_with_rest typed_vars in
  let bind_variable_to_relation var ty idx_var_idx_opt : dep_type_var_map_views * (var * dep_type) list =
    match idx_var_idx_opt with
    | None -> 
        let ind_vars' = List.map (fun (i, vs) -> (i, List.filter (fun v -> v <> var) vs)) ind_vars in
        let var_uses' = (var, []) :: List.remove_assoc var var_uses in
        let typed_vars' = List.remove_assoc var typed_vars in
        ((ind_vars', var_uses'), typed_vars')
    | Some (idx, var_idx) -> 
        let ind_uses : var list = safe_assoc idx ind_vars in
        let ind_uses' = List.filter (fun v -> v <> var) ind_uses in
        let var_uses' = (var, [(idx, var_idx)]) :: (List.map (fun v -> (v,[])) ind_uses') @ (assoc_remove_all_in_set ind_uses var_uses) in
        let typed_vars' = assoc_remove_all_in_set ind_uses typed_vars in
        let ind_vars' = List.map (fun (i, vs) -> (i, List.filter (fun v -> not (List.mem v ind_uses)) vs)) ind_vars in
            ((ind_vars', var_uses'), typed_vars') in
  let bind_variable_to_relations var ty : (dep_type_var_map_views * (var * dep_type) list) list =
    let uses = None :: List.map (fun x -> Some x) (safe_assoc var var_uses) in
    List.map (fun idx_var_idx_opt -> bind_variable_to_relation var ty idx_var_idx_opt) uses in
  list_bind (list_bind var_to_bind_options (fun (_,(var, ty)) -> bind_variable_to_relations var ty)) ((fun (dtvm_views, typed_vars) -> binding_options' dtvm_views typed_vars))
  end
        
let binding_options ((ind_vars, var_uses) : dep_type_var_map_views) (typed_vars : (var * dep_type) list) theorem_relations 
  : bindings_and_unbound list =
  let options = binding_options' (ind_vars, var_uses) typed_vars in
  List.map (fun var_uses' ->
    let var_uses_typed = List.map (fun (v, uses) -> (v, List.assoc v typed_vars, List.map (fun (idx, var_idx) -> (List.assoc idx theorem_relations,var_idx)) uses)) var_uses' in
    let var_uses_typed_list_to_option = List.map (fun (v, ty, uses) -> (v, ty, match uses with [] -> None | [x] -> Some x | _ -> failwith "binding_options: multiple uses")) var_uses_typed in
    let used_theorems = List.fold_right (fun (_, _, opt) acc -> match opt with None -> acc | Some (r, _) -> r :: acc) var_uses_typed_list_to_option [] in
    let unused_theorems = List.map snd (List.filter (fun (_,thm) -> not (List.mem thm used_theorems)) theorem_relations) in
    (var_uses_typed_list_to_option, unused_theorems)
  ) options 

let remove_duplicates l =
  let rec remove_duplicates' l acc =
    match l with
    | [] -> acc
    | x :: xs -> if List.mem x acc then remove_duplicates' xs acc else remove_duplicates' xs (x :: acc) in
  remove_duplicates' l []

(*Sort bindings so all vars that are associated with a None option come before Some associated vars, and for None associated vars the vars are sorted in alphabetical order*)
let sort_bindings (bindings : ((var * dep_type * (dep_type * int) option) list) * dep_type list) : ((var * dep_type * (dep_type * int) option) list) * dep_type list =
  let (vars, theorems) = bindings in
  let (none_bindings, some_bindings) = List.partition (fun (_,_,opt) -> opt = None) vars in
  let sorted_none_bindings = List.sort (fun (v1,_,_) (v2,_,_) -> compare v1 v2) none_bindings in
  (some_bindings @ sorted_none_bindings, theorems)

let makeAllBindings (theorem : dep_type) : bindings_and_unbound list =
  let type_vars = dep_type_quantified theorem in
  let variable_uses = dep_type_var_relation_uses theorem in
  let ind_vars = dep_type_relation_variables theorem in
  let theorem_relations = dep_type_relations theorem in
  remove_duplicates (List.map sort_bindings (binding_options (ind_vars, variable_uses) type_vars theorem_relations))


let print_all_bindings (theorem : dep_type) : unit =
  let bindings_and_unbound = makeAllBindings theorem in
  msg_debug (str "Printing all bindings" ++ fnl ());
  print_all_bindings' bindings_and_unbound

let print_bindings_tactic =
  Proofview.Goal.enter begin fun gl ->
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
    match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt -> 
      begin
        print_all_bindings dt;
        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end

let quickchick_goal =
  Proofview.Goal.enter begin fun gl ->

    (* Convert goal to a constr_expr *)
    let c = Proofview.Goal.concl gl in
    let e = Proofview.Goal.env gl in
    let evd = Evd.from_env e in
(*
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif
 *)  
  match GenericLib.parse_dependent_type (EConstr.to_constr evd c) with
    | Some dt ->
      begin
        msg_debug (str (GenericLib.dep_type_to_string dt) ++ fnl ());
        let open GenericLib in 
        let decide prop = decOptToBool (g_decOpt prop (gInt decOpt_fuel)) in
        let rec mkProperty = function
          | DProd ((var, _),body) -> 
              g_forAll g_arbitrary (gFun [var_to_string var] (fun [_] ->
                mkProperty body
                )) 
          | DArrow (x,y) -> GenericLib.debug_coq_expr (gType' [] x); gIf (decide (gType' [] x)) (mkProperty y) (g_checker gTT)
          | p -> g_checker (decide (gType' [] p)) 
              in     
        GenericLib.debug_coq_expr (mkProperty dt);
        (*run the generator called checker using QuickCheck.*)
        let to_run = GenericLib.interp_open_coq_expr e evd (g_show (g_quickCheck (mkProperty dt))) in
#if COQ_VERSION >= (8, 20, 0)
        (* FRAGILE probably won't be allowed in the future? *)
        let opaque_access = Library.indirect_accessor[@@warning "-3"] in
        QuickChick.define_and_run ~opaque_access to_run e evd;
#else
        QuickChick.define_and_run to_run e evd;
#endif

        Tacticals.tclIDTAC
      end
    | None -> failwith "Failed to Parse type"
  end
(*Create dependency graph, anything that lacks a dependency, print becuase we need it to *)
(*    
    (* Make an evar with the goal as the type *)
    let evd, evar = Evarutil.new_pure_evar (Environ.named_context_val e) evd c in

    Printf.printf "So far so good\n"; flush stdout;
    
    (* Externalize it *)
#if COQ_VERSION >= (8, 17, 0)
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, SList.empty)) in
#else
    let ct = Constrextern.extern_constr e evd (EConstr.mkEvar (evar, [])) in
#endif

    (* Construct : show (quickCheck (_ : ct)) *)
    let  qct = CAst.make @@ Constrexpr.CApp (QuickChick.quickCheck, [ct, None]) in
    let sqct = CAst.make @@ Constrexpr.CApp (QuickChick.show, [(qct,None)]) in

    Printf.printf "So far so good2\n"; flush stdout;

    (* From here on I've tried a couple of things. 
       Calling run_test directly with qct. Fails.
       Internalize here before calling define and run, fails.

       It always seems to fail in the 'interp' phase, with an 
       unknown existential variable error. So I'm probably doing something
       stupid with the evar maps *)
    let evd, to_run = Constrintern.interp_open_constr e evd sqct in

    Printf.printf "So far so good 2.5\n"; flush stdout;
    
    QuickChick.define_and_run to_run e evd;

    Printf.printf "So far so good3\n"; flush stdout;

    (* TODO: This whole block doesn't look very monadic... *)
    Tacticals.tclIDTAC
  end

    (*
    (* Admit a constant with that type *)
    let tmpid = QuickChick.fresh_name "temporary_constant" in
    let _interp_st = Vernacentries.interp (CAst.make @@ Vernacexpr.VernacExpr ([],
      (* TODO: NoDischarge or DoDischarge? *)
      Vernacexpr.VernacAssumption ((NoDischarge, Decl_kinds.Conjectural),
                        NoInline,
                        [
                          (false,
                           (
                             [CAst.make tmpid, None]
                           ,
                             ct
                           )
                          )
                        ]
                       ))) in

    let s = QuickChick.runTest @@ CAst.make @@
      Constrexpr.CApp (QuickChick.quickCheck, [CAst.make @@ CRef (Libnames.qualid_of_ident tmpid,None), None]) in
    (* I need to create an existential of type Checkable ct, and then
       call QuickChick.quickChick on that in the ast, before running
       QuickChick.runTest on the constr_expr. *)

    
    (*

       HACK (there *has* to be a better way): 
         (\x : Checkable ct -> x) _ *)

    let base = Names.Id.of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in

    let binder_list = [CLocalAssum ([CAst.make @@ Names.Name xid], Default Explicit, ct)]  in
    let f_body = CAst.make @@ CRef (CAst.make @@ Libnames.Ident xid,None) in
    let f = mkCLambdaN binder_list f_body in
    let hack_value = mkAppC (f , [ CAst.make @@ CEVarHole (None, Misctypes.IntroAnonymous, None) ] ) in
     *)
(*

    (* Refactor - needs to see internals... *)
    let base = Names.id_of_string "x" in
    let is_visible_name id =
      try
        ignore (Nametab.locate (Libnames.qualid_of_ident id));
        true
      with Not_found -> false
    in
    (** Safe fresh name generation. *)
    let xid = Namegen.next_ident_away_from base is_visible_name in


    let f_body = mkAppC (QuickChick.show, [mkAppC (QuickChick.quickCheck, [mkAppC (QuickChick.mk_ref "checker", [ CRef (Ident ((Loc.dummy_loc, xid)),None) ])])]) in
    let f = mkCLambdaN Loc.dummy_loc bind_list f_body in

    let env = Global.env () in
    let evd = Evd.from_env env in
    let (cf,evd) = Constrintern.interp_constr env evd f in

    let actual_term = Constr.mkApp (cf, Array.of_list [c]) in
 *)



(*
    let concl = Proofview.Goal.concl gl in
    let sigma = Tacmach.project gl in
    let hyps = named_context_val (Proofview.Goal.env gl) in
    let store = Proofview.Goal.extra gl in
    let env = Proofview.Goal.env gl in
    let () = if check && mem_named_context_val id hyps then
      errorlabstrm "Tactics.introduction"
        (str "Variable " ++ pr_id id ++ str " is already declared.")
    in
    match kind_of_term (whd_evar sigma concl) with
    | Prod (_, t, b) -> unsafe_intro env store (LocalAssum (id, t)) b
    | LetIn (_, c, t, b) -> unsafe_intro env store (LocalDef (id, c, t)) b
    | _ -> raise (RefinerError IntroNeedsProduct)
  end
 *)

*)
}
TACTIC EXTEND quickchick
  | ["quickchick"] -> { quickchick_goal }
END

TACTIC EXTEND print_all_bindings 
  | ["print_all_bindings"] -> { print_bindings_tactic }
END

TACTIC EXTEND merge_sound_core
  | ["merge_sound_core"] -> { merge_sound }
END

TACTIC EXTEND remember_induct
  | ["remember_induct" ident(h)] -> { remember_induct h }
END
