(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

From Coq Require Import ZArith Ascii String.

From Coq Require Extraction ExtrOcamlBasic ExtrOcamlString ExtrOcamlNatInt ExtrOCamlInt63.

#if COQ_VERSION >= (8, 15, 0)
From Coq Require ExtrOcamlZBigInt.
#else
From Coq Require ExtrOcamlZInt.
#endif

From QuickChick Require Import
  RoseTrees Test Show Checker.

From QuickChick Require
  Random RandomSplitMix.

Extraction Blacklist Bool Int String List Nat Uint63 Random Seq.

(** Extraction of [Random] *)

Extract Inductive Random.random => "PureSplitMix.t" [ "(fun _ _ -> failwith ""The constructor of random should not be used"")" ] "(fun _ _ -> failwith ""The destructor of random should not be used"")".
Extract Constant Random.split => "(fun s _ -> PureSplitMix.split s)".
Extract Constant Random.bits => "(fun s _ -> Uint63.of_int (PureSplitMix.int_signed s))".

Extract Inlined Constant RandomSplitMix.seed => "PureSplitMix.t".
Extract Inlined Constant RandomSplitMix.generate => "(fun x -> x)".
Extract Inlined Constant RandomSplitMix.split_seed => "PureSplitMix.split".
Extract Inlined Constant RandomSplitMix.new_seed => "(fun _ -> PureSplitMix.auto_seed ())".

#if COQ_VERSION >= (8, 12, 0)
#if COQ_VERSION >= (8, 13, 0)
#define Number_int Number.int
#else
#define Number_int Numeral.int
#endif
Extract Inductive Hexadecimal.int => "((Obj.t -> Obj.t) -> (Obj.t -> Obj.t) -> Obj.t) (* Hexadecimal.int *)"
  [ "(fun x pos _ -> pos (Obj.magic x))"
    "(fun y _ neg -> neg (Obj.magic y))"
  ] "(fun i pos neg -> Obj.magic i pos neg)".
Extract Inductive Number_int => "((Obj.t -> Obj.t) -> (Obj.t -> Obj.t) -> Obj.t) (* Number_int *)"
  [ "(fun x dec _ -> dec (Obj.magic x))"
    "(fun y _ hex -> hex (Obj.magic y))"
  ] "(fun i dec hex -> Obj.magic i dec hex)".
#else
(* Hexadecimal.int and Numeral.int don't exist before 8.12 *)
#endif

(** Temporary fix for https://github.com/coq/coq/issues/7017. *)
(** Scott encoding of [Decimal.int] as [forall r. (uint -> r) -> (uint -> r) -> r]. *)
Extract Inductive Decimal.int => "((Obj.t -> Obj.t) -> (Obj.t -> Obj.t) -> Obj.t) (* Decimal.int *)"
  [ "(fun x pos _ -> pos (Obj.magic x))"
    "(fun y _ neg -> neg (Obj.magic y))"
  ] "(fun pos neg i -> Obj.magic i pos neg)".

Extract Constant show_nat =>
  "(fun i ->
  let s = string_of_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
Extract Constant show_bool =>
  "(fun i ->
  let s = string_of_bool i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".

#if COQ_VERSION >= (8, 15, 0)
Extract Constant show_Z =>
  "(fun i ->
  let s = Big_int_Z.string_of_big_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
Extract Constant show_N =>
  "(fun i ->
  let s = Big_int_Z.string_of_big_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
#else
Extract Constant show_Z =>
  "(fun i ->
  let s = string_of_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
Extract Constant show_N =>
  "(fun i ->
  let s = string_of_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
#endif

Extract Inductive Lazy => "Lazy.t" [lazy].
Extract Constant force => "Lazy.force".

(* Extract Constant Test.ltAscii => "(<=)". *)
(* Extract Constant Test.strEq   => "(=)". *)
Extract Constant Test.gte => "(>=)".
Extract Constant le_gt_dec => "(<=)".
Extract Constant trace =>
  "(fun l -> print_string (
   let s = Bytes.create (List.length l) in
   let rec copy i = function
    | [] -> s
    | c :: l -> Bytes.set s i c; copy (i+1) l
   in Bytes.to_string (copy 0 l)); flush stdout; fun y -> y)".

Set Extraction AccessOpaque.

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssreflect ssrnat ssrbool div eqtype.
Extract Constant divn => "(fun m -> function 0 -> 0 | d -> m / d)".
Extract Constant modn => "(fun m -> function 0 -> m | d -> m mod d)".
Extract Constant eqn => "(==)".

Extract Constant Nat.add => "(+)".
Extract Constant Nat.mul => "( * )".
Extract Constant Nat.sub => "(-)".
Extract Constant Nat.log2 => "(let rec log2 x = if x <= 1 then 0 else 1 + log2 (x / 2) in log2)".
Extract Constant Nat.eqb => "(=)".
Extract Constant Coq.Init.Nat.eqb => "(=)".
Extract Constant Nat.div => "(fun x -> function 0 -> 0 | y -> x / y)".
Extract Constant Coq.Init.Nat.div => "(fun x -> function 0 -> 0 | y -> x / y)".

Axiom print_extracted_coq_string : string -> unit.
Extract Constant print_extracted_coq_string =>
 "fun l -> print_string (
   let s = Bytes.create (List.length l) in
   let rec copy i = function
    | [] -> s
    | c :: l -> s.[i] <- c; copy (i+1) l
   in Bytes.to_string (copy 0 l))".

(* For Nat and N we need to remember that a negative [x] in OCaml really
   represents [x + 2^64], so we adjust the result accordingly. *)

Extract Constant Nat.modulo => "fun x y ->
  if y < 0 then failwith ""negative modulo""
  else if max_int / 2 < y then failwith ""too big divisor""
  else if y = 0 then x
  else if x < 0 then ((((x mod y) - 2 * (min_int mod y)) mod y) + y) mod y else x mod y".

Extract Constant Nat.add => "(+)".
Extract Constant Nat.mul => "( * )".
Extract Constant Nat.sub => "(-)".
Extract Constant Nat.log2 => "(let rec log2 x = if x <= 1 then 0 else 1 + log2 (x / 2) in log2)".
Extract Constant Nat.div => "(fun x y -> if y = 0 then 0 else x / y)".
Extract Constant Coq.Init.Nat.div => "(fun x y -> if y = 0 then 0 else x / y)".

#define EXTRACT_SHIFTR \
"(fun i j -> if j < 0 || Sys.int_size < j then failwith (Printf.sprintf ""overflow: shiftr %d %d"" i j) else i asr j)"

(* shiftl checks its result for overflow *)
#define EXTRACT_SHIFTL \
"(let overflow i j = failwith (Printf.sprintf ""overflow: shiftl %d %d"" i j) in fun i j -> if j < 0 || Sys.int_size < j then overflow i j else let r = i lsl j in if r asr j = i then r else overflow i j)"

Extract Constant Nat.shiftr => EXTRACT_SHIFTR.
Extract Constant Nat.shiftl => EXTRACT_SHIFTL.

#if COQ_VERSION < (8, 15, 0)
Extract Constant N.modulo => "fun x y ->
  if y < 0 then failwith ""negative modulo""
  else if max_int / 2 < y then failwith ""too big divisor""
  else if y = 0 then x
  else if x < 0 then ((((x mod y) - 2 * (min_int mod y)) mod y) + y) mod y else x mod y".

Extract Constant Z.modulo => "fun x y ->
  if y = 0 then x
  else let r = x mod y in
  if (y < 0 && r <= 0) || (y > 0 && r >= 0) then r else r + y".

Extract Constant N.shiftr => EXTRACT_SHIFTR.
Extract Constant N.shiftl => EXTRACT_SHIFTL.

Extract Constant Z.shiftr =>
  "(let overflow i j = failwith (Printf.sprintf ""overflow: shiftr %d %d"" i j) in
   fun i j -> if Sys.int_size < j || Sys.int_size < -j then overflow i j else
   if 0 < j then i asr j else let r = i lsl (-j) in if r asr (-j) = i then r else overflow i j)".
Extract Constant Z.shiftl =>
  "(let overflow i j = failwith (Printf.sprintf ""overflow: shiftl %d %d"" i j) in
   fun i j -> if Sys.int_size < j || Sys.int_size < -j then overflow i j else
   if j < 0 then i asr (-j) else let r = i lsl j in if r asr j = i then r else overflow i j)".
#endif

#if COQ_VERSION < (8, 16, 0)
Extract Constant Nat.compare =>
 "(fun n m -> if n=m then 0 else if n<m then -1 else 1)".
#if COQ_VERSION >= (8, 15, 0)
Extract Constant Pos.compare =>
 "(fun x y -> let s = Big_int_Z.compare_big_int x y in
  if s = 0 then 0 else if s < 0 then -1 else 1)".
Extract Constant Pos.compare_cont =>
 "(fun c x y -> let s = Big_int_Z.compare_big_int x y in
  if s = 0 then c else if s < 0 then -1 else 1)".
Extract Constant N.compare =>
 "(fun x y -> let s = Big_int_Z.compare_big_int x y in
  if s = 0 then 0 else if s < 0 then -1 else 1)".
Extract Constant Z.compare =>
 "(fun x y -> let s = Big_int_Z.compare_big_int x y in
  if s = 0 then 0 else if s < 0 then -1 else 1)".
#else
Extract Constant Pos.compare =>
 "(fun x y -> let s = Int.compare x y in
  if s = 0 then 0 else if s < 0 then -1 else 1)".
Extract Constant Pos.compare_cont =>
 "(fun c x y -> let s = Int.compare x y in
  if s = 0 then c else if s < 0 then -1 else 1)".
Extract Constant N.compare =>
 "(fun x y -> let s = Int.compare x y in
  if s = 0 then 0 else if s < 0 then -1 else 1)".
Extract Constant Z.compare =>
 "(fun x y -> let s = Int.compare x y in
  if s = 0 then 0 else if s < 0 then -1 else 1)".
#endif
#endif
