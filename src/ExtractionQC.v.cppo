(*

THIS FILE IS PREPROCESSED USING cppo
MAKE SURE TO EDIT THE .cppo SOURCE OF THIS FILE RATHER THAN THE GENERATED RESULT

*)

Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

#if COQ_VERSION < (8, 15, 0)
#define Uint63 Int63
#endif
From Coq Require Import ZArith Ascii String Uint63.

From Coq Require Extraction ExtrOcamlBasic ExtrOcamlString ExtrOcamlNatInt.

#if COQ_VERSION >= (8, 15, 0)
From Coq Require ExtrOcamlZBigInt.
#else
From Coq Require ExtrOcamlZInt.
#endif

From QuickChick Require Import
  RoseTrees Test Show Checker.

From QuickChick Require
  Random RandomSplitMix.

Extraction Blacklist String List Nat.

(** Extraction of [Random] *)

Extract Inductive Random.random => "PureSplitMix.t" [ "(fun _ _ -> failwith ""The constructor of random should not be used"")" ] "(fun _ _ -> failwith ""The destructor of random should not be used"")".
Extract Constant Random.split => "(fun s _ -> PureSplitMix.split s)".
Extract Constant Random.bits => "(fun s _ -> PureSplitMix.int_signed s)".

Extract Inlined Constant RandomSplitMix.seed => "PureSplitMix.t".
Extract Inlined Constant RandomSplitMix.generate => "(fun x -> x)".
Extract Inlined Constant RandomSplitMix.split_seed => "PureSplitMix.split".
Extract Inlined Constant RandomSplitMix.new_seed => "(fun _ -> PureSplitMix.auto_seed ())".

#if COQ_VERSION >= (8, 12, 0)
#if COQ_VERSION >= (8, 13, 0)
#define Number_int Number.int
#else
#define Number_int Numeral.int
#endif
Extract Inductive Hexadecimal.int => "((Obj.t -> Obj.t) -> (Obj.t -> Obj.t) -> Obj.t) (* Hexadecimal.int *)"
  [ "(fun x pos _ -> pos (Obj.magic x))"
    "(fun y _ neg -> neg (Obj.magic y))"
  ] "(fun i pos neg -> Obj.magic i pos neg)".
Extract Inductive Number_int => "((Obj.t -> Obj.t) -> (Obj.t -> Obj.t) -> Obj.t) (* Number_int *)"
  [ "(fun x dec _ -> dec (Obj.magic x))"
    "(fun y _ hex -> hex (Obj.magic y))"
  ] "(fun i dec hex -> Obj.magic i dec hex)".
#else
(* Hexadecimal.int and Numeral.int don't exist before 8.12 *)
#endif

(** Temporary fix for https://github.com/coq/coq/issues/7017. *)
(** Scott encoding of [Decimal.int] as [forall r. (uint -> r) -> (uint -> r) -> r]. *)
Extract Inductive Decimal.int => "((Obj.t -> Obj.t) -> (Obj.t -> Obj.t) -> Obj.t) (* Decimal.int *)"
  [ "(fun x pos _ -> pos (Obj.magic x))"
    "(fun y _ neg -> neg (Obj.magic y))"
  ] "(fun pos neg i -> Obj.magic i pos neg)".

Extract Constant show_nat =>
  "(fun i ->
  let s = string_of_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
Extract Constant show_bool =>
  "(fun i ->
  let s = string_of_bool i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".

#if COQ_VERSION >= (8, 15, 0)
Extract Constant show_Z =>
  "(fun i ->
  let s = Big_int_Z.string_of_big_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
Extract Constant show_N =>
  "(fun i ->
  let s = Big_int_Z.string_of_big_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
#else
Extract Constant show_Z =>
  "(fun i ->
  let s = string_of_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
Extract Constant show_N =>
  "(fun i ->
  let s = string_of_int i in
  let rec copy acc i =
    if i < 0 then acc else copy (s.[i] :: acc) (i-1)
  in copy [] (String.length s - 1))".
#endif

Extract Inductive Lazy => "Lazy.t" [lazy].
Extract Constant force => "Lazy.force".

(* Extract Constant Test.ltAscii => "(<=)". *)
(* Extract Constant Test.strEq   => "(=)". *)
Extract Constant Test.gte => "(>=)".
Extract Constant le_gt_dec => "(<=)".
Extract Constant trace =>
  "(fun l -> print_string (
   let s = Bytes.create (List.length l) in
   let rec copy i = function
    | [] -> s
    | c :: l -> Bytes.set s i c; copy (i+1) l
   in Bytes.to_string (copy 0 l)); flush stdout; fun y -> y)".

Set Extraction AccessOpaque.

Require Import mathcomp.ssreflect.ssreflect.
From mathcomp Require Import ssreflect ssrnat ssrbool div eqtype.
Extract Constant divn => "(fun m -> function 0 -> 0 | d -> m / d)".
Extract Constant modn => "(fun m -> function 0 -> m | d -> m mod d)".
Extract Constant eqn => "(==)".

Extract Constant Nat.add => "(+)".
Extract Constant Nat.mul => "( * )".
Extract Constant Nat.sub => "(-)".
Extract Constant Nat.log2 => "(let rec log2 x = if x <= 1 then 0 else 1 + log2 (x / 2) in log2)".
Extract Constant Nat.eqb => "(=)".
Extract Constant Coq.Init.Nat.eqb => "(=)".
Extract Constant Nat.div => "(fun x -> function 0 -> 0 | y -> x / y)".
Extract Constant Coq.Init.Nat.div => "(fun x -> function 0 -> 0 | y -> x / y)".

Axiom print_extracted_coq_string : string -> unit.
Extract Constant print_extracted_coq_string =>
 "fun l -> print_string (
   let s = Bytes.create (List.length l) in
   let rec copy i = function
    | [] -> s
    | c :: l -> s.[i] <- c; copy (i+1) l
   in Bytes.to_string (copy 0 l))".

(* For Nat and N we need to remember that a negative [x] in OCaml really
   represents [x + 2^64], so we adjust the result accordingly. *)

Extract Constant Nat.modulo => "fun x y ->
  if y < 0 then failwith ""negative modulo""
  else if max_int / 2 < y then failwith ""too big divisor""
  else if y = 0 then x
  else if x < 0 then ((((x mod y) - 2 * (min_int mod y)) mod y) + y) mod y else x mod y".

Extract Constant Nat.add => "(+)".
Extract Constant Nat.mul => "( * )".
Extract Constant Nat.sub => "(-)".
Extract Constant Nat.log2 => "(let rec log2 x = if x <= 1 then 0 else 1 + log2 (x / 2) in log2)".
Extract Constant Nat.div => "(fun x y -> if y = 0 then 0 else x / y)".
Extract Constant Coq.Init.Nat.div => "(fun x y -> if y = 0 then 0 else x / y)".

#define EXTRACT_SHIFTR \
"(fun i j -> if j < 0 || Sys.int_size < j then failwith (Printf.sprintf ""overflow: shiftr %d %d"" i j) else i asr j)"

(* shiftl checks its result for overflow *)
#define EXTRACT_SHIFTL \
"(let overflow i j = failwith (Printf.sprintf ""overflow: shiftl %d %d"" i j) in fun i j -> if j < 0 || Sys.int_size < j then overflow i j else let r = i lsl j in if r asr j = i then r else overflow i j)"

Extract Constant Nat.shiftr => EXTRACT_SHIFTR.
Extract Constant Nat.shiftl => EXTRACT_SHIFTL.

#if COQ_VERSION < (8, 15, 0)
Extract Constant N.modulo => "fun x y ->
  if y < 0 then failwith ""negative modulo""
  else if max_int / 2 < y then failwith ""too big divisor""
  else if y = 0 then x
  else if x < 0 then ((((x mod y) - 2 * (min_int mod y)) mod y) + y) mod y else x mod y".

Extract Constant Z.modulo => "fun x y ->
  if y = 0 then x
  else let r = x mod y in
  if (y < 0 && r <= 0) || (y > 0 && r >= 0) then r else r + y".

Extract Constant N.shiftr => EXTRACT_SHIFTR.
Extract Constant N.shiftl => EXTRACT_SHIFTL.

Extract Constant Z.shiftr =>
  "(let overflow i j = failwith (Printf.sprintf ""overflow: shiftr %d %d"" i j) in
   fun i j -> if Sys.int_size < j || Sys.int_size < -j then overflow i j else
   if 0 < j then i asr j else let r = i lsl (-j) in if r asr (-j) = i then r else overflow i j)".
Extract Constant Z.shiftl =>
  "(let overflow i j = failwith (Printf.sprintf ""overflow: shiftl %d %d"" i j) in
   fun i j -> if Sys.int_size < j || Sys.int_size < -j then overflow i j else
   if j < 0 then i asr (-j) else let r = i lsl j in if r asr j = i then r else overflow i j)".
#endif

(** Override the extraction of [int].

    Coq also extracts [int] literals [n] to [Uint63.of_int n].
    That cannot be configured, so our QuickChick plugin postprocesses
    the extracted OCaml to erase that unbound [Uint63.of_int]. *)

(* Note: this does not yet cover all of [Uint63]. *)

Extract Inlined Constant Uint63.int => "int".

Extract Inlined Constant Uint63.is_zero => "((=) 0)".
#if COQ_VERSION >= (8, 15, 0)
Extract Constant Uint63.of_Z => "Big_int_Z.(fun x -> Int64.to_int (int64_of_big_int (extract_big_int x 0 63)))".
Extract Constant Uint63.to_Z => "Big_int_Z.(fun x -> big_int_of_int64 (Int64.(logand max_int (of_int x))))".
#else
Extract Inlined Constant Uint63.of_Z => "(fun x -> x)".  (* Assumes [Z] extract to [int]. *)
Extract Inlined Constant Uint63.to_Z => "(fun x -> x)".
#endif

Extract Constant Uint63.lsl => "(fun i j ->
  if j < 0 || Sys.int_size < j then failwith ""shift overflow"" else i lsl j)".
Extract Constant Uint63.lsr => "(fun i j ->
  if j < 0 || Sys.int_size < j then failwith ""shift overflow"" else i lsr j)".
Extract Inlined Constant Uint63.land => "(land)".
Extract Inlined Constant Uint63.lor => "(lor)".
Extract Inlined Constant Uint63.lxor => "(lxor)".
Extract Inlined Constant Uint63.add => "(+)".
Extract Inlined Constant Uint63.sub => "(-)".
Extract Inlined Constant Uint63.mul => "( * )".
Extract Constant Uint63.div => "(fun i j ->
  if j = 0 then 0 else if i < 0 || j < 0 then failwith ""Negative modulo"" else i / j)".
Extract Constant Uint63.mod => "(fun i j ->
  if j = 0 then i else if i < 0 || j < 0 then failwith ""Negative modulo"" else i mod j)".

(* Note: Uint63 in Coq is unsigned *)
Extract Constant Uint63.ltb => "(fun x y -> if x < 0 then x < y && y < 0 else x < y || y < 0)".
Extract Constant Uint63.leb => "(fun x y -> if x < 0 then x <= y && y < 0 else x <= y || y < 0)".
Extract Constant Uint63.compare =>
  "(fun x y -> if x = y then Eq else
    if x < 0 then if x < y && y < 0 then Lt else Gt else if x < y || y < 0 then Lt else Gt)".

